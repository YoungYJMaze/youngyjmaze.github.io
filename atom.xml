<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>injune&#39;zone</title>
  
  <subtitle>injune的个人空间</subtitle>
  <link href="http://youngyjmaze.github.io/atom.xml" rel="self"/>
  
  <link href="http://youngyjmaze.github.io/"/>
  <updated>2021-10-21T12:34:30.482Z</updated>
  <id>http://youngyjmaze.github.io/</id>
  
  <author>
    <name>injune</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://youngyjmaze.github.io/2021/10/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://youngyjmaze.github.io/2021/10/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-10-19T09:30:46.000Z</published>
    <updated>2021-10-21T12:34:30.482Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划的三部曲：</p><ol><li>找到初始状态， 比如在背包问题中，初始状态就是背包中都为空，没有任何物品被选中。</li><li>找到状态的变量， 在找零钱中，总钱数或者说剩余钱数是目的状态，在背包问题中，选中的价值和重量都是变量，所以是一个二元的状态转移方程，也就是两个变量，我们一般使用二维 以表的形式展示</li><li>找到状态的转移， 一般可以归纳为取或者不取 ， 取当前位置的变量 造成状态转移， 不取当前位置的变量，保持上一个状态。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态规划的三部曲：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到初始状态， 比如在背包问题中，初始状态就是背包中都为空，没有任何物品被选中。&lt;/li&gt;
&lt;li&gt;找到状态的变量， 在找零钱中，总钱数或者说剩余钱数是目的状态，在背包问题中，选中的价值和重量都是变量，所以是一个二元的状态转移方</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://youngyjmaze.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://youngyjmaze.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://youngyjmaze.github.io/tags/leetcode/"/>
    
    <category term="动态规划" scheme="http://youngyjmaze.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 垃圾回收</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:48:08.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA垃圾回收"><a href="#JAVA垃圾回收" class="headerlink" title="JAVA垃圾回收"></a>JAVA垃圾回收</h1><h2 id="垃圾回收的意义"><a href="#垃圾回收的意义" class="headerlink" title="垃圾回收的意义"></a>垃圾回收的意义</h2><p>如果不进行垃圾回收，内存迟早会被消耗空。<br>垃圾回收机制的引入可以有效的防止内存泄露、保证内存的有效使用，也减轻了 Java 程序员的对内存管理的工作量。</p><p>内存泄露：指该内存空间使用完毕后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有是也将其称为“对象游离”。</p><hr><h2 id="垃圾回收机制中的算法"><a href="#垃圾回收机制中的算法" class="headerlink" title="垃圾回收机制中的算法"></a>垃圾回收机制中的算法</h2><p>垃圾回收算法需要做的基本事情：</p><p>发现无用对象<br>回收被无用对象占用的内存空间，使该空间可被程序再次使用</p><h2 id="1-可达性检测算法"><a href="#1-可达性检测算法" class="headerlink" title="1. 可达性检测算法"></a>1. 可达性检测算法</h2><h3 id="1-1-引用计数法（Reference-Counting-Collector）"><a href="#1-1-引用计数法（Reference-Counting-Collector）" class="headerlink" title="1.1 引用计数法（Reference Counting Collector）"></a>1.1 引用计数法（Reference Counting Collector）</h3><p>引用计数是垃圾收集器中的早期策略。<br>此方法中，堆中的每个对象都会添加一个引用计数器。每当一个地方引用这个对象时，计数器值 +1；当引用失效时，计数器值 -1。任何时刻计数值为 0 的对象就是不可能再被使用的。</p><p>这种算法无法解决对象之间相互引用的情况。<br>比如对象有一个对子对象的引用，子对象反过来引用父对象，它们的引用计数永远不可能为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyObject object1 = new MyObject();</span><br><span class="line">        MyObject object2 = new MyObject();</span><br><span class="line">          </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">          </span><br><span class="line">        object1 = null;</span><br><span class="line">        object2 = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后面两句将 object1 和 object2 赋值为 null，也就是说 object1 和 object2 指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。</p><h3 id="1-2-根搜索算法（可达性分析算法）"><a href="#1-2-根搜索算法（可达性分析算法）" class="headerlink" title="1.2 根搜索算法（可达性分析算法）"></a>1.2 根搜索算法（可达性分析算法）</h3><p>由于引用计数法存在缺陷，所有现在一般使用根搜索算法。</p><p><img src="https://upload-images.jianshu.io/upload_images/8878793-b776e959ecfd4c35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><center>根搜索算法图解</center><p>根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。<br>如上图中的 ObjF、ObjD、ObjE通过 GC Root 是无法找到的，所以它们是无用节点。</p><p>Java 中可作为 GC Root 的对象：</p><p>虚拟机栈中引用的对象（本地变量表）<br>方法区中静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中引用的对象（Native对象）<br>可参考：<a href="https://blog.csdn.net/justloveyou_/article/details/71189093">《JVM 内存模型概述》</a></p><p>小结：无论是引用计数法还是跟搜索法，都是为了找到可回收的对象（内存块）。</p><h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2.垃圾收集算法"></a>2.垃圾收集算法</h2><p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的就是进行垃圾的回收，有下面的几中算法：</p><h3 id="2-1-标记-清除（Mark-Sweep）算法"><a href="#2-1-标记-清除（Mark-Sweep）算法" class="headerlink" title="2.1 标记-清除（Mark-Sweep）算法"></a>2.1 标记-清除（Mark-Sweep）算法</h3><p>标记-清除算法分为两个阶段：</p><p>标记阶段：标记出需要被回收的对象。<br>清除阶段：回收被标记的可回收对象的内部空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/8878793-6a9f7afe94d5c9ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><center>标记-清除算法图</center><p>标记-清除算法实现较容易，不需要移动对象，但是存在较严重的问题：</p><ul><li><p>算法过程需要暂停整个应用，效率不高。</p></li><li><p>标记清除后会产生大量不连续的内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作</p></li></ul><h3 id="2-2-复制（Copying）算法"><a href="#2-2-复制（Copying）算法" class="headerlink" title="2.2 复制（Copying）算法"></a>2.2 复制（Copying）算法</h3><p>  为了解决标志-清除算法的缺陷，由此有了复制算法。<br>  复制算法将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。</p><p><img src="https://upload-images.jianshu.io/upload_images/8878793-f8843f83aad30e99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/749/format/webp" alt="img"></p><center>复制算法图</center>小结：<ul><li><p>优点：实现简单，不易产生内存碎片，每次只需要对半个区进行内存回收。</p></li><li><p>缺点：内存空间缩减为原来的一半；算法的效率和存活对象的数目有关，存活对象越多，效率越低。</p></li></ul><h3 id="2-3-标记-整理（Mark-Compact）算法"><a href="#2-3-标记-整理（Mark-Compact）算法" class="headerlink" title="2.3 标记-整理（Mark-Compact）算法"></a>2.3 标记-整理（Mark-Compact）算法</h3><p>  为了更充分利用内存空间，提出了标记-整理算法。<br>  此算法结合了“标记-清除”和“复制”两个算法的优点。<br>  该算法标记阶段和“标志-清除”算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</p><p><img src="https://upload-images.jianshu.io/upload_images/8878793-147802e319c69914.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/679/format/webp" alt="img"></p><center>标志-整理算法图</center><h3 id="2-4-分代收集（Generational-Collection）算法"><a href="#2-4-分代收集（Generational-Collection）算法" class="headerlink" title="2.4 分代收集（Generational Collection）算法"></a>2.4 分代收集（Generational Collection）算法</h3><p>分代收集算法是目前大部分 JVM 的垃圾收集器采用的算法。<br>核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p><p><img src="https://upload-images.jianshu.io/upload_images/8878793-23e72c97b64a692b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/563/format/webp" alt="img"></p><center>分代算法图</center><p>区域划分：</p><blockquote><p>年轻代（Young Generation）</p></blockquote><blockquote><ol><li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li><li>新生代内存按照8:1:1的比例分为一个 eden 区和两个 survivor(survivor0,survivor1) 区。一个 Eden 区，两个 Survivor 区(一般而言)。大部分对象在 Eden 区中生成。回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的，然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。</li><li>当 survivor1区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次 Full GC ，也就是新生代、老年代都进行回收。</li><li>新生代发生的 GC 也叫做 Minor GC ，Minor GC 发生频率比较高(不一定等 Eden 区满了才触发)。</li></ol></blockquote><blockquote><p>年老代（Old Generation）</p></blockquote><blockquote><ol><li>在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</li><li>内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li></ol></blockquote><blockquote><p>持久代（Permanent Generation）</p></blockquote><blockquote><p> 用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class ，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p></blockquote><p>GC 类型：</p><blockquote><ol><li>Minor GC(新生代 GC):<br>新生代 GC，指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生熄灭的特点，所以 Minor GC 十分频繁，回收速度也较快。<br>Major GC(老年代 GC):</li><li>老年代 GC，指发生在老年代的垃圾收集动作，当出现 Major GC 时，一般也会伴有至少一次的 Minor GC（并非绝对，例如 Parallel Scavenge 收集器会单独直接触发 Major GC 的机制）。 Major GC 的速度一般会比 Minor GC 慢十倍以上。</li><li>Full GC:<br>清理整个堆空间—包括年轻代和老年代。Major GC == Full GC。参考： </li></ol></blockquote><blockquote><p>产生 Full GC 可能的原因：</p></blockquote><blockquote><ol><li>年老代被写满。</li><li>持久代被写满。</li><li>System.gc() 被显式调用。</li><li>上一次 GC 之后 Heap 的各域分配策略动态变化。</li></ol></blockquote><h2 id="垃圾收集器（GC）"><a href="#垃圾收集器（GC）" class="headerlink" title="垃圾收集器（GC）"></a>垃圾收集器（GC）</h2><p>不同虚拟机所提供的垃圾收集器可能会有很大差别，下面的例子是 HotSpot。</p><p>新生代收集器使用的收集器：<code>Serial</code>、<code>PraNew</code>、<code>Parallel Scavenge</code>。<br>老年代收集器使用的收集器：<code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/8878793-fecb38bcfee88c25.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp" alt="img"></p><center>垃圾收集器图</center><ol><li><p>Serial 收集器（复制算法)<br>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p></li><li><p>Serial Old收集器(标记-整理算法)<br>老年代单线程收集器，Serial 收集器的老年代版本。</p></li><li><p>ParNew 收集器(停止-复制算法) 　<br>新生代收集器，可以认为是 Serial 收集器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现。</p></li><li><p>Parallel Scavenge 收集器(停止-复制算法)<br>并行收集器，追求高吞吐量，高效利用 CPU。吞吐量一般为 99%， 吞吐量 = 用户线程时间 / (用户线程时间 + GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p></li><li><p>Parallel Old 收集器(停止-复制算法)<br>Parallel Scavenge 收集器的老年代版本，并行收集器，吞吐量优先。</p></li><li><p>CMS(Concurrent Mark Sweep) 收集器（标记-清理算法）<br>高并发、低停顿，追求最短 GC 回收停顿时间，cpu 占用比较高，响应时间快，停顿时间短，多核 cpu 追求高响应时间的选择。</p></li></ol><p>根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。</p><h2 id="四种引用状态"><a href="#四种引用状态" class="headerlink" title="四种引用状态"></a>四种引用状态</h2><p>在实际开发中，我们对 new 出来的对象也会根据重要程度，有个等级划分。有些必须用到的对象，我们希望它在其被引用的周期内能一直存在；有些对象可能没那么重要，当内存空间还足够时，可以保留在内存中，如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。<br>由此，Java 对引用划分为四种：强引用、软引用、弱引用、虚引用，四种引用强度依次减弱。</p><ol><li><p>强引用<br>代码中普遍存在的类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。2.</p></li><li><p>软引用<br>描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java 中的类 SoftReference 表示软引用。</p></li><li><p>弱引用</p><p>描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java 中的类 WeakReference 表示弱引用。</p></li><li><p>虚引用<br>这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java 中的类 PhantomReference 表示虚引用。</p></li></ol><p>作者：安静的蓝孩子<br>链接：<a href="https://www.jianshu.com/p/b78ac4bf13ae">https://www.jianshu.com/p/b78ac4bf13ae</a><br>来源：简书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA垃圾回收&quot;&gt;&lt;a href=&quot;#JAVA垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;JAVA垃圾回收&quot;&gt;&lt;/a&gt;JAVA垃圾回收&lt;/h1&gt;&lt;h2 id=&quot;垃圾回收的意义&quot;&gt;&lt;a href=&quot;#垃圾回收的意义&quot; class=&quot;header</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="gc" scheme="http://youngyjmaze.github.io/tags/gc/"/>
    
    <category term="转载" scheme="http://youngyjmaze.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Lambda 表达式</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:52:55.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式是使用<strong>最小可能</strong>语法编写的函数定义：</p><ol><li>Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。</li><li>Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。</li></ol><p>我们在 <strong>Strategize.java</strong> 中看到了一个 Lambda 表达式，但还有其他语法变体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/LambdaExpressions.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Description</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">brief</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">detailed</span><span class="params">(String head)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Multi</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">twoArg</span><span class="params">(String head, Double d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExpressions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Body bod = h -&gt; h + <span class="string">&quot; No Parens!&quot;</span>; <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Body bod2 = (h) -&gt; h + <span class="string">&quot; More details&quot;</span>; <span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Description desc = () -&gt; <span class="string">&quot;Short info&quot;</span>; <span class="comment">// [3]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Multi mult = (h, n) -&gt; h + n; <span class="comment">// [4]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Description moreLines = () -&gt; &#123; <span class="comment">// [5]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;moreLines()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;from moreLines()&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(bod.detailed(<span class="string">&quot;Oh!&quot;</span>));</span><br><span class="line">    System.out.println(bod2.detailed(<span class="string">&quot;Hi!&quot;</span>));</span><br><span class="line">    System.out.println(desc.brief());</span><br><span class="line">    System.out.println(mult.twoArg(<span class="string">&quot;Pi! &quot;</span>, <span class="number">3.14159</span>));</span><br><span class="line">    System.out.println(moreLines.brief());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Oh! No Parens!</span><br><span class="line">Hi! More details</span><br><span class="line">Short info</span><br><span class="line">Pi! <span class="number">3.14159</span></span><br><span class="line">moreLines()</span><br><span class="line"><span class="function">from <span class="title">moreLines</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>我们从三个接口开始，每个接口都有一个单独的方法（很快就会理解它的重要性）。但是，每个方法都有不同数量的参数，以便演示 Lambda 表达式语法。</p><p>任何 Lambda 表达式的基本语法是：</p><ol><li>参数。</li><li>接着 <code>-&gt;</code>，可视为“产出”。</li><li><code>-&gt;</code> 之后的内容都是方法体。</li></ol><ul><li><strong>[1]</strong> 当只用一个参数，可以不需要括号 <code>()</code>。 然而，这是一个特例。</li><li><strong>[2]</strong> 正常情况使用括号 <code>()</code> 包裹参数。 为了保持一致性，也可以使用括号 <code>()</code> 包裹单个参数，虽然这种情况并不常见。</li><li><strong>[3]</strong> 如果没有参数，则必须使用括号 <code>()</code> 表示空参数列表。</li><li><strong>[4]</strong> 对于多个参数，将参数列表放在括号 <code>()</code> 中。</li></ul><p>到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 <strong>return</strong> 关键字是非法的。 这是 Lambda 表达式简化相应语法的另一种方式。</p><ul><li>**[5] **如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 <strong>return</strong>。</li></ul><p>Lambda 表达式通常比<strong>匿名内部类</strong>产生更易读的代码，因此我们将在本书中尽可能使用它们。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h2&gt;&lt;p&gt;Lambda 表达式是使用&lt;strong&gt;最小可能&lt;/strong&gt;语法编写的函数定</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="匿名函数" scheme="http://youngyjmaze.github.io/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
    <category term="函数式编程" scheme="http://youngyjmaze.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Javassist</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/JavaAssist/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/JavaAssist/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:48:06.941Z</updated>
    
    <content type="html"><![CDATA[<p>Javassist是用来处理java字节码的类库。字节码保存在二进制文件中称为类文件。每个类文件夹包括一个java类或接口。</p><p>Javasssist.CtClass这个类是一个类文件的抽象表示。一个CtClass(compile-time class编译时类)对象处理一个类文件。下面是个简单的例子：</p><pre><code>ClassPool pool = ClassPool.getDefault();CtClass cc = pool.get(&quot;test.Rectangle&quot;);cc.setSuperclass(pool.get(&quot;test.Point&quot;));cc.writeFile();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Javassist是用来处理java字节码的类库。字节码保存在二进制文件中称为类文件。每个类文件夹包括一个java类或接口。&lt;/p&gt;
&lt;p&gt;Javasssist.CtClass这个类是一个类文件的抽象表示。一个CtClass(compile-time class编译时类)对</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="字节码" scheme="http://youngyjmaze.github.io/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
    <category term="javaassist" scheme="http://youngyjmaze.github.io/tags/javaassist/"/>
    
  </entry>
  
  <entry>
    <title>JAVA ThreadLocal</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/ThreadLocal%20%E6%BA%90%E7%A0%81/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/ThreadLocal%20%E6%BA%90%E7%A0%81/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:50:10.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal-源码解读"><a href="#ThreadLocal-源码解读" class="headerlink" title="ThreadLocal 源码解读"></a>ThreadLocal 源码解读</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>首先每个threadLocal类都具有一个其自身的threadlocalhashcode，通过nextHashCode(),获取下一个hashcode，<br>Thread 可以具有初始值，通过withInitial进行设置，它的入参是一个supplier 接口。</p><p>get 函数通过拿到当前Thread ，然后再通过getMap 函数得到当前Thread 绑定的threadlocals (一个ThreadLocalMap)，Map 的Entry是各种各样的ThreadLocal类，通过对应的ThreadLocal类得到对应的Entry，如果找到了当前ThreadLocal对象(即threadLocalHashCode映射在了table中，并且table中对应位置不为空)。<br>如果没有找到通过这个函数进行下一步的处理</p><pre><code>getEntryAfterMiss(key, i, e)</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           int len = tab.length;</span><br><span class="line"></span><br><span class="line">           while (e != null) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               if (k == key)</span><br><span class="line">                   return e;</span><br><span class="line">               if (k == null)</span><br><span class="line">                   expungeStaleEntry(i);</span><br><span class="line">               else</span><br><span class="line">                   i = nextIndex(i, len);</span><br><span class="line">               e = tab[i];</span><br><span class="line">           &#125;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这个函数通过一个while循环，只要没找到存在的Entry，就继续通过一定的策略进行查找。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThreadLocal-源码解读&quot;&gt;&lt;a href=&quot;#ThreadLocal-源码解读&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 源码解读&quot;&gt;&lt;/a&gt;ThreadLocal 源码解读&lt;/h1&gt;&lt;h2 id=&quot;1&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="ThreadLocal" scheme="http://youngyjmaze.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>代码段及容器</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/static%E4%BB%A3%E7%A0%81%E6%AE%B5%20addall%20aslist/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/static%E4%BB%A3%E7%A0%81%E6%AE%B5%20addall%20aslist/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:49:29.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="static代码段"><a href="#static代码段" class="headerlink" title="static代码段"></a>static代码段</h2><p>仅仅在类被初始化的时候加载一次，之后都不再加载,比如业务代码中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        MessageFieldTagNums.addAll(Arrays.asList(</span><br><span class="line">            <span class="string">&quot;7193&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7198&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7300&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7301&quot;</span>));</span><br><span class="line">        MessageFieldTags.addAll(Arrays.asList(</span><br><span class="line">            <span class="string">&quot;ErrorMessage&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ClientConnInfo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FunctionInfo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CheckInfo&quot;</span>));</span><br><span class="line">        MessageFieldTypes.addAll(Arrays.asList(</span><br><span class="line">            (Class) ErrorMessage.class,</span><br><span class="line">            (Class) ClientConnInfo.class,</span><br><span class="line">            (Class) FunctionInfo.class,</span><br><span class="line">            (Class) CheckInfo.class));</span><br><span class="line">        MessageFieldDataTypes.addAll(Arrays.asList(</span><br><span class="line">            DataType.COMPONENT,</span><br><span class="line">            DataType.COMPONENT,</span><br><span class="line">            DataType.COMPONENT,</span><br><span class="line">            DataType.COMPONENT));</span><br><span class="line">        MessageFieldRequireds.addAll(Arrays.asList(</span><br><span class="line">                Boolean.FALSE,</span><br><span class="line">                Boolean.FALSE,</span><br><span class="line">                Boolean.FALSE,</span><br><span class="line">                Boolean.FALSE));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么类什么时候首次被加载呢？就是在主类中（包含main函数的类）new一个对象实例（包含static代码段的类没有main函数）或者此类有main函数，那么在进入main函数的时候首次加载此类，加载类的时候初始化顺序如下：如有父类，则按照静态成员、静态代码段、静态方法、一般成员、父类构造函数的顺序初始化父类，然后是子类的初始化，顺序与上述相同。</p><h2 id="addAll-函数"><a href="#addAll-函数" class="headerlink" title="addAll()函数"></a>addAll()函数</h2><p>addAll()函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">boolean</span>   <span class="title">addAll</span><span class="params">(Collection   c)</span>   </span>&#123; </span><br><span class="line">                         Object[]   a   =   c.toArray(); </span><br><span class="line">                         <span class="keyword">int</span>   numNew   =   a.length; </span><br><span class="line">ensureCapacity(size   +   numNew);      <span class="comment">//   Increments   modCount </span></span><br><span class="line">                         System.arraycopy(a,   <span class="number">0</span>,   elementData,   size,   numNew); </span><br><span class="line">                         size   +=   numNew; </span><br><span class="line"><span class="keyword">return</span>   numNew   !=   <span class="number">0</span>; </span><br><span class="line">             &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到其中用了一个arraycopy函数，这个函数是System函数内的，它调用的是一个本地的native函数，就是系统定义的接口，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                    Object dest, int destPos,</span><br><span class="line">                                    int length);</span><br></pre></td></tr></table></figure><p>在这个接口里，将内存某块地址的一些信息直接复制到内存的另一块中，所以针对于比较大的数据量来说，addAll()方法可以拥有更快的速度。</p><p>所谓addAll()就是将一个数据集合内的信息直接赋给另一个数据集合。</p><h2 id="ArrayList的asList-函数"><a href="#ArrayList的asList-函数" class="headerlink" title="ArrayList的asList()函数"></a>ArrayList的asList()函数</h2><p>asList使用的一些注意事项：</p><ol><li><p>由API可以知道返回的List称得上是对数组的一个引用，对List或者数组的更改都会传递给另一方。</p></li><li><p>使用这个函数还需注意不能使用基本数据类型的数组作为参数，因为函数参数是泛型，故需要引用数据类型的数组作为参数，若使用基本数据类型数组则会将该数组作为单个元素存进List中（因为数组也是引用数据类型）。若要使用基本数据类型数组，只能使用它们的包装类数组。</p></li><li><p>该List不能使用add()和remove()函数，虽然他有这两个函数，因为它的大小是固定的，所以这两个函数只有定义而没有实现，使用这两个函数会报java.lang.UnsupportedOperationException错误</p></li><li><p>可以通过创建一个ArrayList对象并以List作为参数使用addAll函数，就可以获得一个可以add和remove的列表了。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">aslistest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        List list = Arrays.asList(a);</span><br><span class="line">        <span class="keyword">for</span>(Object i:list)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println((<span class="keyword">int</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(Object i:list)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println((<span class="keyword">int</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;static代码段&quot;&gt;&lt;a href=&quot;#static代码段&quot; class=&quot;headerlink&quot; title=&quot;static代码段&quot;&gt;&lt;/a&gt;static代码段&lt;/h2&gt;&lt;p&gt;仅仅在类被初始化的时候加载一次，之后都不再加载,比如业务代码中的：&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="代码段" scheme="http://youngyjmaze.github.io/tags/%E4%BB%A3%E7%A0%81%E6%AE%B5/"/>
    
    <category term="静态" scheme="http://youngyjmaze.github.io/tags/%E9%9D%99%E6%80%81/"/>
    
    <category term="容器" scheme="http://youngyjmaze.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>内部类和迭代器</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:55:15.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部类和迭代器删除数组元素"><a href="#内部类和迭代器删除数组元素" class="headerlink" title="内部类和迭代器删除数组元素"></a>内部类和迭代器删除数组元素</h1><h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><p>因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外部类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/InheritInner.java</span></span><br><span class="line"><span class="comment">// Inheriting an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//- InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>InheritInner</strong> 只继承自内部类，而不是外部类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外部类对象的引用。此外，必须在构造器内使用如下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内部类的引用.super();</span><br></pre></td></tr></table></figure><p>这样才提供了必要的引用，然后程序才能编译通过。</p><h2 id="内部类的覆盖"><a href="#内部类的覆盖" class="headerlink" title="内部类的覆盖"></a>内部类的覆盖</h2><p>如果创建了一个内部类，然后继承其外部类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？这看起来似乎是个很有用的思想，但是“覆盖”内部类就好像它是外部类的一个方法，其实并不起什么作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg.java</span></span><br><span class="line"><span class="comment">// An inner class cannot be overridden like a method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Egg() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">        y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New Egg()</span><br><span class="line">Egg.Yolk()</span><br></pre></td></tr></table></figure><p>默认的无参构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了 <strong>BigEgg</strong> 的对象，那么所使用的应该是“覆盖后”的 <strong>Yolk</strong> 版本，但从输出中可以看到实际情况并不是这样的。</p><p>这个例子说明，当继承了某个外部类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg2.java</span></span><br><span class="line"><span class="comment">// Proper inheritance of an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Yolk y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    Egg2() &#123; System.out.println(<span class="string">&quot;New Egg2()&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span> </span>&#123; y = yy; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; y.f(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg2</span> <span class="keyword">extends</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg2</span>.<span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigEgg2</span><span class="params">()</span> </span>&#123; insertYolk(<span class="keyword">new</span> Yolk()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Egg2 e2 = <span class="keyword">new</span> BigEgg2();</span><br><span class="line">        e2.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Egg2.Yolk()</span><br><span class="line"><span class="function">New <span class="title">Egg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Egg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.Yolk.<span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>现在 <strong>BigEgg2.Yolk</strong> 通过 <strong>extends Egg2.Yolk</strong> 明确地继承了此内部类，并且覆盖了其中的方法。<code>insertYolk()</code> 方法允许 <strong>BigEgg2</strong> 将它自己的 <strong>Yolk</strong> 对象向上转型为 <strong>Egg2</strong> 中的引用 <strong>y</strong>。所以当 <code>g()</code> 调用 <code>y.f()</code> 时，覆盖后的新版的 <code>f()</code> 被执行。第二次调用 <code>Egg2.Yolk()</code>，结果是 <strong>BigEgg2.Yolk</strong> 的构造器调用了其基类的构造器。可以看到在调用 <code>g()</code> 的时候，新版的 <code>f()</code> 被调用了。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外部类的一部分；但是它可以访问当前代码块内的常量，以及此外部类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/LocalInnerClass.java</span></span><br><span class="line"><span class="comment">// Holds a sequence of Objects</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A local inner class:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">            LocalCounter() &#123;</span><br><span class="line">                <span class="comment">// Local inner class can have a constructor</span></span><br><span class="line">                System.out.println(<span class="string">&quot;LocalCounter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Repeat, but with an anonymous inner class:</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            <span class="comment">// Anonymous inner class cannot have a named</span></span><br><span class="line">            <span class="comment">// constructor, only an instance initializer:</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Counter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">        Counter</span><br><span class="line">                c1 = lic.getCounter(<span class="string">&quot;Local inner &quot;</span>),</span><br><span class="line">                c2 = lic.getCounter2(<span class="string">&quot;Anonymous inner &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c1.next());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c2.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalCounter()</span><br><span class="line">Counter()</span><br><span class="line">Local inner <span class="number">0</span></span><br><span class="line">Local inner <span class="number">1</span></span><br><span class="line">Local inner <span class="number">2</span></span><br><span class="line">Local inner <span class="number">3</span></span><br><span class="line">Local inner <span class="number">4</span></span><br><span class="line">Anonymous inner <span class="number">5</span></span><br><span class="line">Anonymous inner <span class="number">6</span></span><br><span class="line">Anonymous inner <span class="number">7</span></span><br><span class="line">Anonymous inner <span class="number">8</span></span><br><span class="line">Anonymous inner <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>Counter</strong> 返回的是序列中的下一个值。我们分别使用局部内部类和匿名内部类实现了这个功能，它们具有相同的行为和能力，既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。</p><p><strong>所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。</strong></p><h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>由于编译后每个类都会产生一个**.class** 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个”meta-class”，叫做 <strong>Class</strong> 对象）。</p><p>你可能猜到了，内部类也必须生成一个**.class** 文件以包含它们的 <strong>Class</strong> 对象信息。这些类文件的命名有严格的规则：外部类的名字，加上“**$<strong>“，再加上内部类的名字。例如，</strong>LocalInnerClass.java** 生成的 <strong>.class</strong> 文件包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter.class</span><br><span class="line">LocalInnerClass$1.class</span><br><span class="line">LocalInnerClass$LocalCounter.class</span><br><span class="line">LocalInnerClass.class</span><br></pre></td></tr></table></figure><p>如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外部类标识符与“**$**”的后面。</p><p>虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是 java 的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java 编译器会尽可能地转换它们。） </p><h2 id="java集合遍历删除的方法"><a href="#java集合遍历删除的方法" class="headerlink" title="java集合遍历删除的方法"></a>java集合遍历删除的方法</h2><p>一般地，我们有两种方式进行Java集合的遍历删除:</p><p>1、实现方式就是讲遍历与移除操作分离，即在遍历的过程中，将需要移除的数据存放在另外一个集合当中，遍历结束之后，统一移除。</p><p>2、使用Iterator遍历删除。</p><p>使用Iterator遍历删除的原因：</p><p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。<br>所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象， Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; famous = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    famous.add(<span class="string">&quot;liudehua&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;madehua&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;liushishi&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;tangwei&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : famous) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;madehua&quot;</span>)) &#123;</span><br><span class="line">            famous.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>运行出异常:</p><p>Exception in thread “main” java.util.ConcurrentModificationException</p><p>at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)</p><p>at java.util.AbstractList$Itr.next(AbstractList.java:343)</p><p>at com.bes.Test.main(Test.java:15)</p><p>Java新手最容易犯的错误，对JAVA集合进行遍历删除时务必要用迭代器。切记。</p><p>其实对于如上for循环，运行过程中还是转换成了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it = famous.iterator();it.hasNext();)&#123;</span><br><span class="line">         String s = it.next();</span><br><span class="line">         <span class="keyword">if</span>(s.equals(<span class="string">&quot;madehua&quot;</span>))&#123;</span><br><span class="line">             famous.remove(s);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然采用的是迭代器，但删除操作却用了错误的方法。如将famous.remove(s)改成it.remove()</p><p>为什么用了迭代码器就不能采用famous.remove(s)操作? 这种因为ArrayList与Iterator混合使用时会导致各自的状态出现不一样，最终出现异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内部类和迭代器删除数组元素&quot;&gt;&lt;a href=&quot;#内部类和迭代器删除数组元素&quot; class=&quot;headerlink&quot; title=&quot;内部类和迭代器删除数组元素&quot;&gt;&lt;/a&gt;内部类和迭代器删除数组元素&lt;/h1&gt;&lt;h2 id=&quot;继承内部类&quot;&gt;&lt;a href=&quot;#继承内部</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="迭代" scheme="http://youngyjmaze.github.io/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>可变参数和枚举</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8Cenum/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8Cenum/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:54:39.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可变参数和enum"><a href="#可变参数和enum" class="headerlink" title="可变参数和enum"></a>可变参数和enum</h1><h2 id="JAVA的可变参数列表"><a href="#JAVA的可变参数列表" class="headerlink" title="JAVA的可变参数列表"></a>JAVA的可变参数列表</h2><p>如下面这段代码所呈现的一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object obj : args)</span><br><span class="line">      System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;</span><br><span class="line">      <span class="keyword">new</span> Integer(<span class="number">47</span>), <span class="keyword">new</span> Float(<span class="number">3.14</span>), <span class="keyword">new</span> Double(<span class="number">11.11</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span> &#125;);</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A()&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">47 3.14 11.11</span></span><br><span class="line"><span class="comment">one two three</span></span><br><span class="line"><span class="comment">A@1a46e30 A@3e25a5 A@19821f</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>第一段里我们插入了一个Object数组，但是其实可以以另外一种更加优雅的形式呈现：</p><p>类似于我们在python中经常使用到的*args,**kwargs来收集剩余的参数一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTrailingArguments</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> required, String... trailing)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;required: &quot;</span> + required + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : trailing)</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">    f(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">required: 1 one</span></span><br><span class="line"><span class="comment">required: 2 two three</span></span><br><span class="line"><span class="comment">required: 0</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时，在使用可变参数时，应注意，在如下情况发生时可能会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(Character c : args)</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(Integer i : args)</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Long... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">    f(<span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//! f(); // Won&#x27;t compile -- ambiguous</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">first a b c</span></span><br><span class="line"><span class="comment">second 1</span></span><br><span class="line"><span class="comment">second 2 1</span></span><br><span class="line"><span class="comment">second 0</span></span><br><span class="line"><span class="comment">third</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当上例的f()被直接调用时可能会出现错误。</p><p>只有给两个方法都添加一个非可变参数，才能解决这个二义性问题，</p><h2 id="enum关键字"><a href="#enum关键字" class="headerlink" title="enum关键字"></a>enum关键字</h2><p>可以定义如下的enum类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Spiciness</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span> </span>&#123; <span class="keyword">this</span>.degree = degree;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:    System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM: System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:     System.out.println(<span class="string">&quot;maybe too hot.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Burrito</span><br><span class="line">                plain = <span class="keyword">new</span> Burrito(Spiciness.NOT),</span><br><span class="line">                greenChile = <span class="keyword">new</span> Burrito(Spiciness.MEDIUM),</span><br><span class="line">                jalapeno = <span class="keyword">new</span> Burrito(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们可以发现Spiciness实际上被定义成了一个对象，所以在这里的switch绝不仅仅是对enum中类型序号的输入，更多的是输入了一个限定对象中的某些成员。</p><p>如果在需要传入Spiciness对象的位置仅仅传入int数值则会报错，必须传入Spiciness.***</p><p>以上也是enum类型经常使用的一种情况，即在switch语句中使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;可变参数和enum&quot;&gt;&lt;a href=&quot;#可变参数和enum&quot; class=&quot;headerlink&quot; title=&quot;可变参数和enum&quot;&gt;&lt;/a&gt;可变参数和enum&lt;/h1&gt;&lt;h2 id=&quot;JAVA的可变参数列表&quot;&gt;&lt;a href=&quot;#JAVA的可变参数列表&quot; c</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="枚举" scheme="http://youngyjmaze.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
    <category term="方法" scheme="http://youngyjmaze.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E5%A4%9A%E6%80%81/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E5%A4%9A%E6%80%81/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:51:34.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的意义其中之一就是上转型</p><p>如果针对于每个导出类我们都进行重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Stringed.play() &quot;</span> + n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Brass.play() &quot;</span> + n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Wind i)</span> </span>&#123;</span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Stringed i)</span> </span>&#123;</span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Brass i)</span> </span>&#123;</span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">    Stringed violin = <span class="keyword">new</span> Stringed();</span><br><span class="line">    Brass frenchHorn = <span class="keyword">new</span> Brass();</span><br><span class="line">    tune(flute); <span class="comment">// No upcasting</span></span><br><span class="line">    tune(violin);</span><br><span class="line">    tune(frenchHorn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Wind.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">Stringed.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">Brass.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>这将是很大的工作量，并且如果这样做，如果有时我们忘记了去重写父类的方法，那么我们就会收获未知的错误，因为他会继承父类的方法，并且不会有任何的提示。</p><h3 id="方法调用绑定"><a href="#方法调用绑定" class="headerlink" title="方法调用绑定"></a>方法调用绑定</h3><p>将一个方法调用和一个方法主体关联起来被称作绑定，若在程序执行前进行绑定，叫做前期绑定，它是面向过程的语言中默认的绑定方式，例如C语言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">    tune(flute); <span class="comment">// Upcasting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Wind.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>像这段代码，编译器如何确定传入的Instrument就是Wind类型而非其他类型呢？</p><p>主要是通过后期绑定:</p><p>后期绑定是在运行时根据对象的类型进行绑定，后期绑定也叫做动态绑定或运行时绑定，如果一种语言想实现后期绑定，就必须有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法，后期绑定机制随编程语言的不同而有所不同，但是不管怎么样都必须在对象中安置某种“类型信息”。</p><p>java中除了static 和 final 方法之外，其他所有的方法都是后期绑定，也就是说，final方法可以有效地解除动态绑定，即我们不需要这个类继续被继承。</p><h3 id="产生正确的行为"><a href="#产生正确的行为" class="headerlink" title="产生正确的行为"></a>产生正确的行为</h3><p>向上转型可以像以下的语句一样简单：</p><p><code>Shape s= new Circle();</code></p><p>如果这时你调用一个基类的方法，它会调用的是导出类中重写过的方法（如果存在）而非基类的方法。这里就是动态绑定的体现。</p><h3 id="多态使用的注意事项"><a href="#多态使用的注意事项" class="headerlink" title="多态使用的注意事项"></a>多态使用的注意事项</h3><h4 id="1、私有方法不可覆盖"><a href="#1、私有方法不可覆盖" class="headerlink" title="1、私有方法不可覆盖"></a>1、私有方法不可覆盖</h4><h4 id="2、域与静态方法，静态方法不具有多态的意义"><a href="#2、域与静态方法，静态方法不具有多态的意义" class="headerlink" title="2、域与静态方法，静态方法不具有多态的意义"></a>2、域与静态方法，静态方法不具有多态的意义</h4><h3 id="构造器与多态"><a href="#构造器与多态" class="headerlink" title="构造器与多态"></a>构造器与多态</h3><p>构造器实际上是static方法，只不过它的static声明是隐式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  Meal() &#123; print(<span class="string">&quot;Meal()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</span><br><span class="line">  Bread() &#123; print(<span class="string">&quot;Bread()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</span><br><span class="line">  Cheese() &#123; print(<span class="string">&quot;Cheese()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</span><br><span class="line">  Lettuce() &#123; print(<span class="string">&quot;Lettuce()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  Lunch() &#123; print(<span class="string">&quot;Lunch()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">  PortableLunch() &#123; print(<span class="string">&quot;PortableLunch()&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">  <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese();</span><br><span class="line">  <span class="keyword">private</span> Lettuce l = <span class="keyword">new</span> Lettuce();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sandwich</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;Sandwich()&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Sandwich();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Meal()</span></span><br><span class="line"><span class="comment">Lunch()</span></span><br><span class="line"><span class="comment">PortableLunch()</span></span><br><span class="line"><span class="comment">Bread()</span></span><br><span class="line"><span class="comment">Cheese()</span></span><br><span class="line"><span class="comment">Lettuce()</span></span><br><span class="line"><span class="comment">Sandwich()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子实际上展示了构造器的构造顺序</p><h4 id="继承与清理"><a href="#继承与清理" class="headerlink" title="继承与清理"></a>继承与清理</h4><p>如果我们在清理方法上对导出类做了一些特殊的处理，但是同时还要用到基类中的方法，这时候一定要记得使用super()来调用父类的清理方法，否则不会进行。</p><h4 id="构造器内部多态方法的行为"><a href="#构造器内部多态方法的行为" class="headerlink" title="构造器内部多态方法的行为"></a>构造器内部多态方法的行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;Glyph.draw()&quot;</span>); &#125;</span><br><span class="line">  Glyph() &#123;</span><br><span class="line">    print(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">    draw();</span><br><span class="line">    print(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">  RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">    radius = r;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Glyph() before draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.draw(), radius = 0  由动态绑定得到的答案。</span></span><br><span class="line"><span class="comment">Glyph() after draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.RoundGlyph(), radius = 5</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如这个例子，在glyph的构造方法中调用了draw，这是一个需要被覆盖的方法。</p><p>这里引出了实际的初始化过程，首先第一步，将所有要分配的空间都初始化为二进制的0；</p><p>在构造器内唯一能够安全调用的方法就是基类中的final方法。</p><h3 id="向下转型与运行时类型识别"><a href="#向下转型与运行时类型识别" class="headerlink" title="向下转型与运行时类型识别"></a>向下转型与运行时类型识别</h3><p>RTTI 运行时类型识别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreUseful</span> <span class="keyword">extends</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RTTI</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Useful[] x = &#123;</span><br><span class="line">      <span class="keyword">new</span> Useful(),</span><br><span class="line">      <span class="keyword">new</span> MoreUseful()</span><br><span class="line">    &#125;;</span><br><span class="line">    x[<span class="number">0</span>].f();</span><br><span class="line">    x[<span class="number">1</span>].g();</span><br><span class="line">    <span class="comment">// Compile time: method not found in Useful:</span></span><br><span class="line">    <span class="comment">//! x[1].u();</span></span><br><span class="line">    ((MoreUseful)x[<span class="number">1</span>]).u(); <span class="comment">// Downcast/RTTI</span></span><br><span class="line">    ((MoreUseful)x[<span class="number">0</span>]).u(); <span class="comment">// Exception thrown</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上直接调用x[1].u()是无法实现的。但是向下转型之后可以进行调用，但是X[0]即使向下转型也无法调用。</p><h2 id="java-中-add-offer，element-peek，remove-poll"><a href="#java-中-add-offer，element-peek，remove-poll" class="headerlink" title="java 中 add/offer，element/peek，remove/poll"></a>java 中 add/offer，element/peek，remove/poll</h2><p>java LinkedList和Queue中 add/offer，element/peek，remove/poll中的三个方法均为重复的方法，在选择使用时不免有所疑惑，这里简单区别一下：</p><p>1、add()和offer()区别:</p><p>add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</p><p> 2、poll()和remove()区别：</p><p>remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p><p>3、element() 和 peek() 区别：</p><p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p><p>**下面是Java中Queue的一些常用方法：<br>add         增加一个元索                      如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove   移除并返回队列头部的元素     如果队列为空，则抛出一个NoSuchElementException异常<br>element  返回队列头部的元素              如果队列为空，则抛出一个NoSuchElementException异常<br>offer       添加一个元素并返回true        如果队列已满，则返回false<br>poll         移除并返问队列头部的元素     如果队列为空，则返回null<br>peek       返回队列头部的元素              如果队列为空，则返回null<br>put         添加一个元素                       如果队列满，则阻塞<br>take        移除并返回队列头部的元素   **</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这种方法是不完整的，仅有方法声明而没有方法体，包含抽象方法的类叫做抽象类，如果一个类包含一个或者多个抽象方法，该类必须被限定为抽象类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h2&gt;&lt;p&gt;多态的意义其中之一就是上转型&lt;/p&gt;
&lt;p&gt;如果针对于每个导出类我们都进行重写：&lt;/p&gt;
&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="多态" scheme="http://youngyjmaze.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="基础知识" scheme="http://youngyjmaze.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>常量及构造函数</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E5%B8%B8%E9%87%8F%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E5%B8%B8%E9%87%8F%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:51:13.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0717"><a href="#0717" class="headerlink" title="0717"></a>0717</h1><h2 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h2><p>当生成一个常量时，如果我们想要明确的八进制、十六进制或是单精度双精度，可以像以下方式一样声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i1=0x2f; //十六进制</span><br><span class="line">int i2=0144; //八进制</span><br><span class="line">char c = 0xffff //最大的char值</span><br></pre></td></tr></table></figure><h2 id="指数记数法"><a href="#指数记数法" class="headerlink" title="指数记数法"></a>指数记数法</h2><p>编译器通常会把指数记数法，形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f=1e-43;</span><br></pre></td></tr></table></figure><p>当做是双精度数来处理，所以此时应该明确声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f=1e-43f;</span><br></pre></td></tr></table></figure><p>这样就可以确保f为一个单精度数了。</p><h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>Java，子类不是必须重写父类所有方法的，分为以下两种情况：</p><ol><li>父类方法为抽象方法时，子类必须重写（实现）所有父类的抽象方法（或者放到当前类的子类实现也可以）；</li><li>父类方法为普通方法时，子类可以重写父类方法，也可以不重写。</li></ol><p>一个类实现接口和继承抽象类对于抽象方法的实现原则是相同的：</p><ol><li>如果这个类是个普通类，那么必须实现这个接口/抽象类的所有抽象方法；</li><li>如果这个类是个抽象类，那么不必实现这个接口/抽象类的抽象方法，因为抽象类中可以定义抽象方法。</li></ol><h2 id="关于截尾和舍入"><a href="#关于截尾和舍入" class="headerlink" title="关于截尾和舍入"></a>关于截尾和舍入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float a=29.7;</span><br><span class="line">int b=(int)a;</span><br></pre></td></tr></table></figure><p>答案得到的是29，float和double在转型为整数型时，总是对数字进行结尾操作，如果要得到四舍五入之后的结果，需要使用Math.round()函数。</p><pre><code>Math.ceil() //向上取整Math.floor() //向下取整</code></pre><h2 id="Java的goto语句"><a href="#Java的goto语句" class="headerlink" title="Java的goto语句"></a>Java的goto语句</h2><p>通过使用标签来进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lable:</span><br><span class="line">whilecodeblock</span><br><span class="line">&#123;</span><br><span class="line">coutinue Lable;</span><br><span class="line">    Lable1:</span><br><span class="line">    whilecodeblock1</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">continue</span> Lable;</span><br><span class="line">    <span class="keyword">break</span> Lable1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是加入了两个循环代码块，并且利用Label和Label1进行跳转操作。</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>主要利用不同的参数列表来构造一个对象。主要就是通过不同的参数列表来实现不同的构造（也可以通过返回值类型的不同来进行方法的重载）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Class person()</span><br><span class="line">&#123;</span><br><span class="line">    person()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    person(int age)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    person(int age,int id)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    char person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveOverloading</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(char) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(byte) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(short) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(int) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(byte) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(short) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(int) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(short) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(int) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f4(int) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f4(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f4(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f4(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f5(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f5(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f5(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f6(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f6(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f7</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f7(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testConstVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printnb(<span class="string">&quot;5: &quot;</span>);</span><br><span class="line">    f1(<span class="number">5</span>);f2(<span class="number">5</span>);f3(<span class="number">5</span>);f4(<span class="number">5</span>);f5(<span class="number">5</span>);f6(<span class="number">5</span>);f7(<span class="number">5</span>); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    printnb(<span class="string">&quot;char: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;byte: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;short: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;int: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;long: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;float: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;double: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PrimitiveOverloading p =</span><br><span class="line">      <span class="keyword">new</span> PrimitiveOverloading();</span><br><span class="line">    p.testConstVal();</span><br><span class="line">    p.testChar();</span><br><span class="line">    p.testByte();</span><br><span class="line">    p.testShort();</span><br><span class="line">    p.testInt();</span><br><span class="line">    p.testLong();</span><br><span class="line">    p.testFloat();</span><br><span class="line">    p.testDouble();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">short: f1(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">int: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">long: f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">float: f1(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">double: f1(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>像上述代码段所展示的一样，在重载实现时，如果传入的数据类型小于方法生命中的形式参数类型，实际数据类型就会被提升，char类型不太一样，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demotion</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(short)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(int)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(long)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(float)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(double)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(short)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(int)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(long)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(float)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(short)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(int)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(long)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f4(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f4(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f4(short)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; print(<span class="string">&quot;f4(int)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f5(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f5(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f5(short)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f6(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f6(byte)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f7</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f7(char)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">    print(<span class="string">&quot;double argument:&quot;</span>);</span><br><span class="line">    f1(x);f2((<span class="keyword">float</span>)x);f3((<span class="keyword">long</span>)x);f4((<span class="keyword">int</span>)x);</span><br><span class="line">    f5((<span class="keyword">short</span>)x);f6((<span class="keyword">byte</span>)x);f7((<span class="keyword">char</span>)x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Demotion p = <span class="keyword">new</span> Demotion();</span><br><span class="line">    p.testDouble();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">double argument:</span></span><br><span class="line"><span class="comment">f1(double)</span></span><br><span class="line"><span class="comment">f2(float)</span></span><br><span class="line"><span class="comment">f3(long)</span></span><br><span class="line"><span class="comment">f4(int)</span></span><br><span class="line"><span class="comment">f5(short)</span></span><br><span class="line"><span class="comment">f6(byte)</span></span><br><span class="line"><span class="comment">f7(char)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出，同时如果传入的参数类型过于大，就需要用到强制转换转换为参数类型比较低的类型进行执行。</p><h2 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">    Apple peeled = apple.getPeeled();</span><br><span class="line">    System.out.println(<span class="string">&quot;Yummy&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peeler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... remove peel</span></span><br><span class="line">    <span class="keyword">return</span> apple; <span class="comment">// Peeled</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">  <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassingThis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Person().eat(<span class="keyword">new</span> Apple());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Yummy</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>this的用法：</p><ol><li>如上述例子一样，我们通过一个剥皮器进行苹果的剥皮，通过this关键字传入apple对象，在一个对象内部实现类中传入当前对象，如果是实例化之后的实例则传入的是当前实例。</li><li>返回当前对象的引用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return this;</span><br></pre></td></tr></table></figure><ol start="3"><li>在构造函数中调用构造函数 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">  String s = <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">  Flower(<span class="keyword">int</span> petals) &#123;</span><br><span class="line">    petalCount = petals;</span><br><span class="line">    print(<span class="string">&quot;Constructor w/ int arg only, petalCount= &quot;</span></span><br><span class="line">      + petalCount);</span><br><span class="line">  &#125;</span><br><span class="line">  Flower(String ss) &#123;</span><br><span class="line">    print(<span class="string">&quot;Constructor w/ String arg only, s = &quot;</span> + ss);</span><br><span class="line">    s = ss;</span><br><span class="line">  &#125;</span><br><span class="line">  Flower(String s, <span class="keyword">int</span> petals) &#123;</span><br><span class="line">    <span class="keyword">this</span>(petals);</span><br><span class="line"><span class="comment">//!    this(s); // Can&#x27;t call two!</span></span><br><span class="line">    <span class="keyword">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line">    print(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Flower() &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    print(<span class="string">&quot;default constructor (no args)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printPetalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//! this(11); // Not inside non-constructor!</span></span><br><span class="line">    print(<span class="string">&quot;petalCount = &quot;</span> + petalCount + <span class="string">&quot; s = &quot;</span>+ s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Flower x = <span class="keyword">new</span> Flower();</span><br><span class="line">    x.printPetalCount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Constructor w/ int arg only, petalCount= 47</span></span><br><span class="line"><span class="comment">String &amp; int args</span></span><br><span class="line"><span class="comment">default constructor (no args)</span></span><br><span class="line"><span class="comment">petalCount = 47 s = hi</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="finalize-的使用"><a href="#finalize-的使用" class="headerlink" title="finalize()的使用"></a>finalize()的使用</h2><p>在知道了java的垃圾回收机制之后，就可以明白finalize()是如何使用的了，在进行垃圾回收准备回收一个对应的类时，我们在类中定义的finalize()函数会被调用，在finalize()中进行一些特殊的操作，并且在下一次垃圾回收的时候才会真正回收对象所占用的内存。也就是用于在垃圾回收时刻做一些重要的清理工作。但是一般使用较少，如果我们真的需要在不使用某个对象的时候进行清理操作，我们需要自己定义一个特定的函数进行清理操作。</p><h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class test</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  test()</span><br><span class="line">  &#123;</span><br><span class="line">    i=1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里的变量i在对象的值就在创建时被设为0，在进行构造器初始化之后i的值变为1。</p><h2 id="构造器初始化顺序"><a href="#构造器初始化顺序" class="headerlink" title="构造器初始化顺序"></a>构造器初始化顺序</h2><p>在类的内部，变量定义的先后顺序决定了初始化的先后顺序，即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When the constructor is called to create a</span></span><br><span class="line"><span class="comment">// Window object, you&#x27;ll see a message:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">  Window(<span class="keyword">int</span> marker) &#123; print(<span class="string">&quot;Window(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">  Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>); <span class="comment">// Before constructor</span></span><br><span class="line">  House() &#123;</span><br><span class="line">    <span class="comment">// Show that we&#x27;re in the constructor:</span></span><br><span class="line">    print(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">    w3 = <span class="keyword">new</span> Window(<span class="number">33</span>); <span class="comment">// Reinitialize w3</span></span><br><span class="line">  &#125;</span><br><span class="line">  Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>); <span class="comment">// After constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;f()&quot;</span>); &#125;</span><br><span class="line">  Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>); <span class="comment">// At end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    House h = <span class="keyword">new</span> House();</span><br><span class="line">    h.f(); <span class="comment">// Shows that construction is done</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Window(1)</span></span><br><span class="line"><span class="comment">Window(2)</span></span><br><span class="line"><span class="comment">Window(3)</span></span><br><span class="line"><span class="comment">House()</span></span><br><span class="line"><span class="comment">Window(33)</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码段中，虽然构造函数直接调用了Window(33)，但是我们可以发现，Window(33)在所有变量定义的代码都被调用之后才进行了构造函数的调用。</p><h2 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span> </span>&#123;</span><br><span class="line">  Bowl(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">  Table() &#123;</span><br><span class="line">    print(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">    bowl2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span> </span>&#123;</span><br><span class="line">  Bowl bowl3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">  Cupboard() &#123;</span><br><span class="line">    print(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">    bowl4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">  <span class="keyword">static</span> Cupboard cupboard = <span class="keyword">new</span> Cupboard();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Bowl(1)</span></span><br><span class="line"><span class="comment">Bowl(2)</span></span><br><span class="line"><span class="comment">Table()</span></span><br><span class="line"><span class="comment">f1(1)</span></span><br><span class="line"><span class="comment">Bowl(4)</span></span><br><span class="line"><span class="comment">Bowl(5)</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">f2(1)</span></span><br><span class="line"><span class="comment">f3(1)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察以上的初始化过程，我们可以发现，bowl4和bowl5为static类型，bowl3非static，在输出中，可以看到Bowl4和Bowl5比Bowl3更早被调用，在包含主函数的类中，static对象优先调用生成，我们可以看到Bowl(1)和Bowl(2)更早被输出之后才是构造函数的Table()被输出，在之后又是紧随static Table的static Cupboard被构造出，之后再进行对应非静态变量实例的初始化，静态对象的非构造函数的执行顺序就按一般的函数执行顺序进行。</p><h2 id="非静态实例的初始化"><a href="#非静态实例的初始化" class="headerlink" title="非静态实例的初始化"></a>非静态实例的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mug</span> </span>&#123;</span><br><span class="line">  Mug(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mugs</span> </span>&#123;</span><br><span class="line">  Mug mug1;</span><br><span class="line">  Mug mug2;</span><br><span class="line">  &#123;</span><br><span class="line">    mug1 = <span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">    mug2 = <span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">    print(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Mugs() &#123;</span><br><span class="line">    print(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Mugs(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    print(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Mugs();</span><br><span class="line">    print(<span class="string">&quot;new Mugs() completed&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Mugs(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">&quot;new Mugs(1) completed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Inside main()</span></span><br><span class="line"><span class="comment">Mug(1)</span></span><br><span class="line"><span class="comment">Mug(2)</span></span><br><span class="line"><span class="comment">mug1 &amp; mug2 initialized</span></span><br><span class="line"><span class="comment">Mugs()</span></span><br><span class="line"><span class="comment">new Mugs() completed</span></span><br><span class="line"><span class="comment">Mug(1)</span></span><br><span class="line"><span class="comment">Mug(2)</span></span><br><span class="line"><span class="comment">mug1 &amp; mug2 initialized</span></span><br><span class="line"><span class="comment">Mugs(int)</span></span><br><span class="line"><span class="comment">new Mugs(1) completed</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面可以看出，虽然没有static类型的对象实例，但是由于在Mugs类中通过一个代码段新建了mug1，mug2两个实例，所以在执行创建Mugs实例时会先执行赋值的语句，并且在这里，与两个赋值语句同属一个代码段的print语句也被执行了。（这是匿名函数类中的一个值得注意的用法）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0717&quot;&gt;&lt;a href=&quot;#0717&quot; class=&quot;headerlink&quot; title=&quot;0717&quot;&gt;&lt;/a&gt;0717&lt;/h1&gt;&lt;h2 id=&quot;直接常量&quot;&gt;&lt;a href=&quot;#直接常量&quot; class=&quot;headerlink&quot; title=&quot;直接常量&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="基础知识" scheme="http://youngyjmaze.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="常量" scheme="http://youngyjmaze.github.io/tags/%E5%B8%B8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E6%8E%A5%E5%8F%A3/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:53:16.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h3><p>复用代码的第一种方式是客户端程序员遵循该接口来编写他们自己的类，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String s =</span><br><span class="line">    <span class="string">&quot;If she weighs the same as a duck, she&#x27;s made of wood&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Apply.process(<span class="keyword">new</span> Upcase(), s);</span><br><span class="line">    Apply.process(<span class="keyword">new</span> Downcase(), s);</span><br><span class="line">    Apply.process(<span class="keyword">new</span> Splitter(), s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123; <span class="comment">// Covariant return</span></span><br><span class="line">    <span class="keyword">return</span> ((String)input).toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((String)input).toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(((String)input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">  &#125;    </span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Using Processor Upcase</span></span><br><span class="line"><span class="comment">IF SHE WEIGHS THE SAME AS A DUCK, SHE&#x27;S MADE OF WOOD</span></span><br><span class="line"><span class="comment">Using Processor Downcase</span></span><br><span class="line"><span class="comment">if she weighs the same as a duck, she&#x27;s made of wood</span></span><br><span class="line"><span class="comment">Using Processor Splitter</span></span><br><span class="line"><span class="comment">[If, she, weighs, the, same, as, a, duck,, she&#x27;s, made, of, wood]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><h3 id="组合接口中的命名冲突："><a href="#组合接口中的命名冲突：" class="headerlink" title="组合接口中的命名冲突："></a>组合接口中的命名冲突：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; <span class="comment">// overloaded</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; <span class="comment">// overloaded</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Identical, no problem:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods differ only by return type:</span></span><br><span class="line"><span class="comment">//! class C5 extends C implements I1 &#123;&#125;</span></span><br><span class="line"><span class="comment">//! interface I4 extends I1, I3 &#123;&#125; ///:~</span></span><br></pre></td></tr></table></figure><p>正如上面所展示的一样。实际上C5继承C并实现I1，I4继承 I2,I3，但是C、I1，I2、I3都有f()方法，在进行实现时，f()方法m无法仅仅根据返回类型来进行足够的判断，所以被当做是一个编译时错误。</p><h2 id="JAVA正则表达式"><a href="#JAVA正则表达式" class="headerlink" title="JAVA正则表达式"></a>JAVA正则表达式</h2><p>利用(!=)()(!?)可以实现类似python中匹配的效果，如果不使用(!=)他在匹配过我们的结尾之后直接就从这次的结尾开始继续匹配，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;h3 id=&quot;代码复用&quot;&gt;&lt;a href=&quot;#代码复用&quot; class=&quot;headerlink&quot; title=&quot;代码复用&quot;&gt;&lt;/a&gt;代码复用&lt;/h</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="基础知识" scheme="http://youngyjmaze.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="接口" scheme="http://youngyjmaze.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>接口与工厂</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:54:12.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口与工厂"><a href="#接口与工厂" class="headerlink" title="接口与工厂"></a>接口与工厂</h2><p>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方法就是<code>工厂方法</code>设计模式，它与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象，理论上，通过这种方式，我们的代码将完全与接口的实现分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  Implementation1() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation1 method1&quot;</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation1 method2&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  Implementation2() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation2 method1&quot;</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation2 method2&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Implementation2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span> </span>&#123;</span><br><span class="line">    Service s = fact.getService();</span><br><span class="line">    s.method1();</span><br><span class="line">    s.method2();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    serviceConsumer(<span class="keyword">new</span> Implementation1Factory());</span><br><span class="line">    <span class="comment">// Implementations are completely interchangeable:</span></span><br><span class="line">    serviceConsumer(<span class="keyword">new</span> Implementation2Factory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Implementation1 method1</span></span><br><span class="line"><span class="comment">Implementation1 method2</span></span><br><span class="line"><span class="comment">Implementation2 method1</span></span><br><span class="line"><span class="comment">Implementation2 method2</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有使用工厂方法，代码就必须在某处指定将要创建的Service的确切类型，以便调用合适的构造器。</p><p>对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h3><p>一种典型的创建内部类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">// Using inner classes looks just like</span></span><br><span class="line">  <span class="comment">// using any other class, within Parcel1:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">    Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">    Destination d = <span class="keyword">new</span> Destination(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>更加普遍的一种创建方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">    Contents c = contents();</span><br><span class="line">    Destination d = to(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel2 p = <span class="keyword">new</span> Parcel2();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    Parcel2 q = <span class="keyword">new</span> Parcel2();</span><br><span class="line">    <span class="comment">// Defining references to inner classes:</span></span><br><span class="line">    Parcel2.Contents c = q.contents();</span><br><span class="line">    Parcel2.Destination d = q.to(<span class="string">&quot;Borneo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>内部类被用来作为一种名字隐藏和组织代码的模式。但是它的更有用的作用是：</p><ul><li>当生成一个内部类的对象时，此对象与制造它的外围对象就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件，此外，内部类还拥有其外围类的所有元素的访问权：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; items = <span class="keyword">new</span> Object[size]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(next &lt; items.length)</span><br><span class="line">      items[next++] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i == items.length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> items[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(i &lt; items.length) i++; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      sequence.add(Integer.toString(i));</span><br><span class="line">    Selector selector = sequence.selector();</span><br><span class="line">    <span class="keyword">while</span>(!selector.end()) &#123;</span><br><span class="line">      System.out.print(selector.current() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      selector.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><h3 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h3><p>如果你需要生成对外部类对象的引用，可以使用外部类的名字后面跟着this，这样产生的引用自动地具有正确的类型，<strong>这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">    DotThis.Inner dti = dt.inner();</span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DotThis.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时你需要创建某个内部类的对象，需要在new表达式中提供对其他外部类对象的引用，同时需要使用.new语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">    DotNew.Inner dni = dn.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure><h2 id="内部类与上转型"><a href="#内部类与上转型" class="headerlink" title="内部类与上转型"></a>内部类与上转型</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;接口与工厂&quot;&gt;&lt;a href=&quot;#接口与工厂&quot; class=&quot;headerlink&quot; title=&quot;接口与工厂&quot;&gt;&lt;/a&gt;接口与工厂&lt;/h2&gt;&lt;p&gt;接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方法就是&lt;code&gt;工厂方法&lt;/code&gt;设计模式，它与直接</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="接口" scheme="http://youngyjmaze.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
    <category term="工厂" scheme="http://youngyjmaze.github.io/tags/%E5%B7%A5%E5%8E%82/"/>
    
  </entry>
  
  <entry>
    <title>接口嵌套、线程池</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:53:49.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口嵌套、线程池"><a href="#接口嵌套、线程池" class="headerlink" title="接口嵌套、线程池"></a>接口嵌套、线程池</h2><p>接口可以嵌套在类或其他接口中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp2</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CImp2</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp2</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> DImp2(); &#125;</span><br><span class="line">  <span class="keyword">private</span> D dRef;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line">    dRef = d;</span><br><span class="line">    dRef.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Redundant &quot;public&quot;:</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// Cannot be private within an interface:</span></span><br><span class="line">  <span class="comment">//! private interface I &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterfaces</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Cannot implement a private interface except</span></span><br><span class="line">  <span class="comment">// within that interface&#x27;s defining class:</span></span><br><span class="line">  <span class="comment">//! class DImp implements A.D &#123;</span></span><br><span class="line">  <span class="comment">//!  public void f() &#123;&#125;</span></span><br><span class="line">  <span class="comment">//! &#125;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">EImp</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">EGImp</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">EImp2</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EG</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="comment">// Can&#x27;t access A.D:</span></span><br><span class="line">    <span class="comment">//! A.D ad = a.getD();</span></span><br><span class="line">    <span class="comment">// Doesn&#x27;t return anything but A.D:</span></span><br><span class="line">    <span class="comment">//! A.DImp2 di2 = a.getD();</span></span><br><span class="line">    <span class="comment">// Cannot access a member of the interface:</span></span><br><span class="line">    <span class="comment">//! a.getD().f();</span></span><br><span class="line">    <span class="comment">// Only another A can do anything with getD():</span></span><br><span class="line">    A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    a2.receiveD(a.getD());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure><p>在类中嵌套接口的语法是相当显而易见的，就像非嵌套接口一样，可以拥有public和“包访问性”两种可视性。</p><p>接口也可以被实现为private，就像在A.D中所看到的，DImp2依然将这个接口实现为了一个public类，但是A.DImpl2只能被其自身所使用。因此，实现一个接口是一个方式，可以强制该接口中的方法定义不添加任何类型信息，也就是无法进行向上转型。</p><p>getD()方法是一个对private接口的引用的public方法，在main()中，数次尝试使用返回值都无法成功，只有一种方式可以成功，就是将返回值交给有权使用它的对象，在本例中，是另一个A通过receivedD()方法来实现的。</p><ul><li><p><strong>当我们实现某个接口时，并不需要实现其内部所嵌套的接口。</strong></p></li><li><p><strong>private接口只能在定义它的类中被实现。</strong></p></li></ul><h2 id="可缓存线程池newCachedThreadPool"><a href="#可缓存线程池newCachedThreadPool" class="headerlink" title="可缓存线程池newCachedThreadPool"></a>可缓存线程池newCachedThreadPool</h2><p> CachedThreadPool 是通过 java.util.concurrent.Executors 创建的 ThreadPoolExecutor 实例。这个实例会根据需要，在线程可用时，重用之前构造好的池中线程。这个线程池在执行 <strong>大量短生命周期的异步任务时（many short-lived asynchronous task）</strong>，可以显著提高程序性能。调用 <strong>execute</strong> 时，可以重用之前已构造的可用线程，如果不存在可用线程，那么会重新创建一个新的线程并将其加入到线程池中。如果线程超过 60 秒还未被使用，就会被中止并从缓存中移除。因此，线程池在长时间空闲后不会消耗任何资源。</p><p>注意队列实例是：new SynchronousQueue()</p><h2 id="固定数量线程池FixedThreadPool"><a href="#固定数量线程池FixedThreadPool" class="headerlink" title="固定数量线程池FixedThreadPool"></a>固定数量线程池FixedThreadPool</h2><p>FixedThreadPool 是通过 java.util.concurrent.Executors 创建的 ThreadPoolExecutor 实例。这个实例会复用 <strong>固定数量的线程</strong> 处理一个 <strong>共享的无边界队列</strong> 。任何时间点，最多有 nThreads 个线程会处于活动状态执行任务。如果当所有线程都是活动时，有多的任务被提交过来，那么它会一致在队列中等待直到有线程可用。如果任何线程在执行过程中因为错误而中止，新的线程会替代它的位置来执行后续的任务。所有线程都会一致存于线程池中，直到显式的执行 ExecutorService.shutdown() 关闭。</p><p>注意队列实例是：new LinkedBlockingQueue()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="slf4j-logback关系详解和相关用法"><a href="#slf4j-logback关系详解和相关用法" class="headerlink" title="slf4j  logback关系详解和相关用法"></a>slf4j  logback关系详解和相关用法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;接口嵌套、线程池&quot;&gt;&lt;a href=&quot;#接口嵌套、线程池&quot; class=&quot;headerlink&quot; title=&quot;接口嵌套、线程池&quot;&gt;&lt;/a&gt;接口嵌套、线程池&lt;/h2&gt;&lt;p&gt;接口可以嵌套在类或其他接口中。&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="接口" scheme="http://youngyjmaze.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
    <category term="多线程" scheme="http://youngyjmaze.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>私有方法和静态方法的测试</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:50:40.536Z</updated>
    
    <content type="html"><![CDATA[<pre><code>        testStatic mock = new testStatic();//私有方法的mock        testStatic spy=PowerMockito.spy(mock);</code></pre><p>//        PowerMockito.when(spy,”testPrivate”,any()).thenReturn(true);<br>           Object is=method.invoke(mock,””);<br>            Assert.assertEquals(is,true);</p><pre><code>    Object say = Whitebox.invokeMethod(mock, &quot;testPrivate&quot;, &quot;hi&quot;);    Assert.assertEquals(say,true);        测试私有方法（可行）                                        InOutValue inOutValueMock= Mockito.mock(OrderInOutValue.class);    IndexOptionOrder indexOptionOrderMock=Mockito.mock(IndexOptionOrder.class);    OptionOrder optionOrder=Mockito.mock(OptionOrder.class);</code></pre><p>//        Comm commMock=mock(Comm.class);</p><pre><code>    inOutValueMock.setPortfolioKey(&quot;11&quot;);    inOutValueMock.setFuturePositionKey(&quot;111&quot;);    inOutValueMock.setAssetKey(&quot;1111&quot;);    PowerMockito.mockStatic(Comm.class);    PowerMockito.when(Comm.isFutExchange(Mockito.any())).thenReturn(true);    PowerMockito.whenNew(IndexOptionOrder.class).withArguments(Mockito.any()).thenReturn(indexOptionOrderMock);    Assert.assertEquals(OptionUtil.getOptionTransaction(inOutValueMock),indexOptionOrderMock);    PowerMockito.when(Comm.isFutExchange(Mockito.any())).thenReturn(false);    PowerMockito.whenNew(OptionOrder.class).withArguments(Mockito.any()).thenReturn(optionOrder);    Assert.assertEquals(OptionUtil.getOptionTransaction(inOutValueMock),optionOrder);    测试 静态方法 （可行）</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;        testStatic mock = new testStatic();//私有方法的mock
        testStatic spy=PowerMockito.spy(mock);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;//        </summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="测试" scheme="http://youngyjmaze.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java 类</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:54:53.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><p>每个编译单元只能存在一个public类，(一个.java文件)，同时这个java文件的文件名必须和类确保一致，包括大小写，如果不存在public类，则文件命名没有特殊要求，其他的访问权限相关类似于方法和变量的访问权限。</p><p>除了内部类，其他类不可以是private 和protected的。只能是包访问权限和public之中的一种，</p><h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>继承的时候，父类的构造方法最先被调用，然后调用子类的构造方法，如果父类的构造方法中含有参数，就需要通过super()方法显式的调用并且传递合适的参数才能完成构造。</p><h2 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipDelegation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> SpaceShipControls controls =</span><br><span class="line">    <span class="keyword">new</span> SpaceShipControls();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpaceShipDelegation</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Delegated methods:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.back(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.down(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.forward(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.left(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.right(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    controls.turboBoost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.up(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpaceShipDelegation protector =</span><br><span class="line">      <span class="keyword">new</span> SpaceShipDelegation(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所呈现的一样，我们在spaceshipdelegation类中创建了一个spaceshipcontrols的实例，并且通过这一实例来进行spaceshipcontrols的方法的调用，这个过程就被称为代理，代理是通过另一个类来实现其功能，而装饰器是在原类上进行功能的拓展。</p><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><p>final 修饰变量用来指代这一变量是不可修改的，如果一个基本类型同时又用final进行修饰，代表这一变量成为编译时常量，即该变量在编译时就已经有一个确定的值了，对于对象的引用来说，final虽然也意味着引用无法指向别处，但是引用所指向的值可以进行改变，我们还可以不给静态final变量赋值，<strong>但是这也意味着我们需要在构造器中为final的对象进行赋值，否则将会产生错误；</strong>（这样的情况又被称为空白final）</p><p>像如下这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poppet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  Poppet(<span class="keyword">int</span> ii) &#123; i = ii; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// Initialized final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> j; <span class="comment">// Blank final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Poppet p; <span class="comment">// Blank final reference</span></span><br><span class="line">  <span class="comment">// Blank finals MUST be initialized in the constructor:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">// Initialize blank final</span></span><br><span class="line">    p = <span class="keyword">new</span> Poppet(<span class="number">1</span>); <span class="comment">// Initialize blank final reference</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    j = x; <span class="comment">// Initialize blank final</span></span><br><span class="line">    p = <span class="keyword">new</span> Poppet(x); <span class="comment">// Initialize blank final reference</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> BlankFinal();</span><br><span class="line">    <span class="keyword">new</span> BlankFinal(<span class="number">47</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h5><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味着你无法在方法中更改参数引用所指向的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spin</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalArguments</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">with</span><span class="params">(<span class="keyword">final</span> Gizmo g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//! g = new Gizmo(); // Illegal -- g is final</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">without</span><span class="params">(Gizmo g)</span> </span>&#123;</span><br><span class="line">    g = <span class="keyword">new</span> Gizmo(); <span class="comment">// OK -- g not final</span></span><br><span class="line">    g.spin();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// void f(final int i) &#123; i++; &#125; // Can&#x27;t change</span></span><br><span class="line">  <span class="comment">// You can only read from a final primitive:</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FinalArguments bf = <span class="keyword">new</span> FinalArguments();</span><br><span class="line">    bf.without(<span class="keyword">null</span>);</span><br><span class="line">    bf.with(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如代码中呈现的一样，final 指向的参数我们只能看，而不能对他做出任何的改变，对传入的参数仅仅能够读和返回，而不能做出改变。</p><h3 id="final-修饰方法"><a href="#final-修饰方法" class="headerlink" title="final 修饰方法"></a>final 修饰方法</h3><p>final修饰方法的原因有两个：第一个原因是把方法锁定，以防任何继承类修改它的含义，这是出于设计的考虑：想要确保在继承中使方法的行为保持不变，<strong>并且不会被覆盖。</strong></p><p>过去使用final方法的第二个原因是效率，在JAVA早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用，当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值。）并且以方法体中的实际代码的副本来替代方法调用，这将消除方法调用的开销。但是当代码段过长，程序代码过于膨胀，可能看不到内嵌带来的任何性能提高。<strong>在最近的java版本中，虚拟机可以探测到这些情况，并且优化去掉这些效率反而降低的额外内嵌调用</strong></p><p>！！！！所以现在用final修饰方法单纯是由于第一个原因！</p><h3 id="final-修饰类"><a href="#final-修饰类" class="headerlink" title="final 修饰类"></a>final 修饰类</h3><p>当将某个类整体定义为final时，就表明了你不打算继承该类，而且也不允许别人这样做，出于某种原因，你对该类的设计永远不需要做任何变动，或者出于安全的考虑，你不希望它有子类，</p><h3 id="继承与初始化"><a href="#继承与初始化" class="headerlink" title="继承与初始化"></a>继承与初始化</h3><p>static初始化的顺序按照定义类时的书写顺序依次初始化。</p><p>如以下这个程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: reusing/Beetle.java</span></span><br><span class="line"><span class="comment">// The full process of initialization.</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> j;</span><br><span class="line">  Insect() &#123;</span><br><span class="line">    print(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    j = <span class="number">39</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x1 =</span><br><span class="line">    printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printInit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    print(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> k = printInit(<span class="string">&quot;Beetle.k initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Beetle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;k = &quot;</span> + k);</span><br><span class="line">    print(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x2 =</span><br><span class="line">    printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">    Beetle b = <span class="keyword">new</span> Beetle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">static Insect.x1 initialized</span></span><br><span class="line"><span class="comment">static Beetle.x2 initialized</span></span><br><span class="line"><span class="comment">Beetle constructor</span></span><br><span class="line"><span class="comment">i = 9, j = 0</span></span><br><span class="line"><span class="comment">Beetle.k initialized</span></span><br><span class="line"><span class="comment">k = 47</span></span><br><span class="line"><span class="comment">j = 39</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在加载beetle的时候发现beetle具有一个基类insect 所以编译器继续加载了insect类，（不管是否有新建一个insect对象），加载完基类之后先加载根基类中的static，之后是下一个导出类，以此类推，这个过程结束完之后可以进行对象的创建了，即通过构造器进行对象的构建。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类的访问权限&quot;&gt;&lt;a href=&quot;#类的访问权限&quot; class=&quot;headerlink&quot; title=&quot;类的访问权限&quot;&gt;&lt;/a&gt;类的访问权限&lt;/h2&gt;&lt;p&gt;每个编译单元只能存在一个public类，(一个.java文件)，同时这个java文件的文件名必须和类确保一致</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="类" scheme="http://youngyjmaze.github.io/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/CGLIB/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/CGLIB/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:51:57.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是CGLIB"><a href="#什么是CGLIB" class="headerlink" title="什么是CGLIB"></a>什么是CGLIB</h1><p>CGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：<a href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a></p><h1 id="为什么使用CGLIB"><a href="#为什么使用CGLIB" class="headerlink" title="为什么使用CGLIB"></a>为什么使用CGLIB</h1><p>CGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。关于Java动态代理，可以参者这里<a href="http://blog.csdn.net/danchu/article/details/70146985">Java动态代理分析</a></p><h1 id="CGLIB组成结构"><a href="#CGLIB组成结构" class="headerlink" title="CGLIB组成结构"></a>CGLIB组成结构</h1><p><img src="http://jnb.ociweb.com/jnb/jnbNov2005_files/jnbNov2005-1.PNG" alt="image"></p><p>CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类。除了CGLIB库外，脚本语言（如Groovy何BeanShell）也使用ASM生成字节码。ASM使用类似SAX的解析器来实现高性能。我们不鼓励直接使用ASM，因为它需要对Java字节码的格式足够的了解</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>说了这么多，可能大家还是不知道CGLIB是干什么用的。下面我们将使用一个简单的例子来演示如何使用CGLIB对一个方法进行拦截。<br>首先，我们需要在工程的POM文件中引入cglib的dependency，这里我们使用的是2.2.2版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;12345</span><br></pre></td></tr></table></figure><p>依赖包下载后，我们就可以干活了，按照国际惯例，写个hello world</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before method run...&quot;</span>);</span><br><span class="line">                Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;after method run...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        SampleClass sample = (SampleClass) enhancer.create();</span><br><span class="line">        sample.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mian函数中，我们通过一个Enhancer和一个MethodInterceptor来实现对方法的拦截，运行程序后输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method run...</span><br><span class="line">hello world</span><br><span class="line">after method run...123</span><br></pre></td></tr></table></figure><p>在上面的程序中，我们引入了Enhancer和MethodInterceptor，可能有些读者还不太了解。别急，我们后面将会一一进行介绍。就目前而言，一个使用CGLIB的小demo就完成了</p><h1 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h1><p>目前网络上对CGLIB的介绍资料比较少，造成对cglib的学习困难。这里我将对cglib中的常用类进行一个介绍。为了避免解释的不清楚，我将为每个类都配有一个demo，用来做进一步的说明。首先就从Enhancer开始吧。</p><h2 id="Enhancer"><a href="#Enhancer" class="headerlink" title="Enhancer"></a>Enhancer</h2><p>Enhancer可能是CGLIB中最常用的一个类，和Java1.3动态代理中引入的Proxy类差不多(如果对Proxy不懂，可以参考<a href="http://blog.csdn.net/danchu/article/details/70146985">这里</a>)。和Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。基于同样的道理，Enhancer也不能对fianl类进行代理操作。这也是Hibernate为什么不能持久化final class的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们将以这个类作为主要的测试类，来测试调用各种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFixedValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello cglib&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    System.out.println(proxy.test(<span class="keyword">null</span>)); <span class="comment">//拦截test，输出Hello cglib</span></span><br><span class="line">    System.out.println(proxy.toString()); </span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    System.out.println(proxy.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello cglib</span><br><span class="line">Hello cglib</span><br><span class="line">class com.zeus.cglib.SampleClass$$EnhancerByCGLIB$$e3ea9b7</span><br><span class="line"></span><br><span class="line">java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number</span><br><span class="line"></span><br><span class="line">    at com.zeus.cglib.SampleClass$$EnhancerByCGLIB$$e3ea9b7.hashCode(&lt;generated&gt;)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上述代码中，FixedValue用来对所有拦截的方法返回相同的值，从输出我们可以看出来，Enhancer对非final方法test()、toString()、hashCode()进行了拦截，没有对getClass进行拦截。由于hashCode()方法需要返回一个Number，但是我们返回的是一个String，这解释了上面的程序中为什么会抛出异常。</p><p>Enhancer.setSuperclass用来设置父类型，从toString方法可以看出，使用CGLIB生成的类为被代理类的一个子类，形如：SampleClass$$EnhancerByCGLIB$$e3ea9b7</p><p>Enhancer.create(Object…)方法是用来创建增强对象的，其提供了很多不同参数的方法用来匹配被增强类的不同构造方法。（虽然类的构造放法只是Java字节码层面的函数，但是Enhancer却不能对其进行操作。Enhancer同样不能操作static或者final类）。我们也可以先使用Enhancer.createClass()来创建字节码(.class)，然后用字节码动态的生成增强后的对象。</p><p>可以使用一个InvocationHandler(如果对InvocationHandler不懂，可以参考<a href="http://blog.csdn.net/danchu/article/details/70146985">这里</a>)作为回调，使用invoke方法来替换直接访问类的方法，但是你必须注意死循环。因为invoke中调用的任何原代理类方法，均会重新代理到invoke方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInvocationHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;hello cglib&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Do not know what to do&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;hello cglib&quot;</span>, proxy.test(<span class="keyword">null</span>));</span><br><span class="line">    Assert.assertNotEquals(<span class="string">&quot;Hello cglib&quot;</span>, proxy.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免这种死循环，我们可以使用MethodInterceptor，MethodInterceptor的例子在前面的hello world中已经介绍过了，这里就不浪费时间了。</p><p>有些时候我们可能只想对特定的方法进行拦截，对其他的方法直接放行，不做任何操作，使用Enhancer处理这种需求同样很简单,只需要一个CallbackFilter即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallbackFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    CallbackHelper callbackHelper = <span class="keyword">new</span> CallbackHelper(SampleClass.class, <span class="keyword">new</span> Class[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">getCallback</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Hello cglib&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> NoOp.INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallbackFilter(callbackHelper);</span><br><span class="line">    enhancer.setCallbacks(callbackHelper.getCallbacks());</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, proxy.test(<span class="keyword">null</span>));</span><br><span class="line">    Assert.assertNotEquals(<span class="string">&quot;Hello cglib&quot;</span>,proxy.toString());</span><br><span class="line">    System.out.println(proxy.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ImmutableBean"><a href="#ImmutableBean" class="headerlink" title="ImmutableBean"></a>ImmutableBean</h2><p>通过名字就可以知道，不可变的Bean。ImmutableBean允许创建一个原来对象的包装类，这个包装类是不可变的，任何改变底层对象的包装类操作都会抛出IllegalStateException。但是我们可以通过直接操作底层对象来改变包装类对象。这有点类似于Guava中的不可变视图</p><p>为了对ImmutableBean进行测试，这里需要再引入一个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleBean</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected = IllegalStateException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImmutableBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    SampleBean bean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    SampleBean immutableBean = (SampleBean) ImmutableBean.create(bean); <span class="comment">//创建不可变类</span></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello world&quot;</span>,immutableBean.getValue()); </span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world, again&quot;</span>); <span class="comment">//可以通过底层对象来进行修改</span></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello world, again&quot;</span>, immutableBean.getValue());</span><br><span class="line">    immutableBean.setValue(<span class="string">&quot;Hello cglib&quot;</span>); <span class="comment">//直接修改将throw exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean-generator"><a href="#Bean-generator" class="headerlink" title="Bean generator"></a>Bean generator</h2><p>cglib提供的一个操作bean的工具，使用它能够在运行时动态的创建一个bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanGenerator</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanGenerator beanGenerator = <span class="keyword">new</span> BeanGenerator();</span><br><span class="line">    beanGenerator.addProperty(<span class="string">&quot;value&quot;</span>,String.class);</span><br><span class="line">    Object myBean = beanGenerator.create();</span><br><span class="line">    Method setter = myBean.getClass().getMethod(<span class="string">&quot;setValue&quot;</span>,String.class);</span><br><span class="line">    setter.invoke(myBean,<span class="string">&quot;Hello cglib&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Method getter = myBean.getClass().getMethod(<span class="string">&quot;getValue&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello cglib&quot;</span>,getter.invoke(myBean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用cglib动态的创建了一个和SampleBean相同的Bean对象，包含一个属性value以及getter、setter方法</p><h2 id="Bean-Copier"><a href="#Bean-Copier" class="headerlink" title="Bean Copier"></a>Bean Copier</h2><p>cglib提供的能够从一个bean复制到另一个bean中，而且其还提供了一个转换器，用来在转换的时候对bean的属性进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSampleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanCopier</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanCopier copier = BeanCopier.create(SampleBean.class, OtherSampleBean.class, <span class="keyword">false</span>);<span class="comment">//设置为true，则使用converter</span></span><br><span class="line">    SampleBean myBean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    myBean.setValue(<span class="string">&quot;Hello cglib&quot;</span>);</span><br><span class="line">    OtherSampleBean otherBean = <span class="keyword">new</span> OtherSampleBean();</span><br><span class="line">    copier.copy(myBean, otherBean, <span class="keyword">null</span>); <span class="comment">//设置为true，则传入converter指明怎么进行转换</span></span><br><span class="line">   assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, otherBean.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BulkBean"><a href="#BulkBean" class="headerlink" title="BulkBean"></a>BulkBean</h2><p>相比于BeanCopier，BulkBean将copy的动作拆分为getPropertyValues和setPropertyValues两个方法，允许自定义处理属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBulkBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BulkBean bulkBean = BulkBean.create(SampleBean.class,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">&quot;getValue&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">&quot;setValue&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">    SampleBean bean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    Object[] propertyValues = bulkBean.getPropertyValues(bean);</span><br><span class="line">    assertEquals(<span class="number">1</span>, bulkBean.getPropertyValues(bean).length);</span><br><span class="line">    assertEquals(<span class="string">&quot;Hello world&quot;</span>, bulkBean.getPropertyValues(bean)[<span class="number">0</span>]);</span><br><span class="line">    bulkBean.setPropertyValues(bean,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;Hello cglib&quot;</span>&#125;);</span><br><span class="line">    assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, bean.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注意：<br>\1. 避免每次进行BulkBean.create创建对象，一般将其声明为static的<br>\2. 应用场景：针对特定属性的get,set操作，一般适用通过xml配置注入和注出的属性，运行时才确定处理的Source,Target类，只需要关注属性名即可。</p><h2 id="BeanMap"><a href="#BeanMap" class="headerlink" title="BeanMap"></a>BeanMap</h2><p>BeanMap类实现了Java Map，将一个bean对象中的所有属性转换为一个String-to-Obejct的Java Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanGenerator generator = <span class="keyword">new</span> BeanGenerator();</span><br><span class="line">    generator.addProperty(<span class="string">&quot;username&quot;</span>,String.class);</span><br><span class="line">    generator.addProperty(<span class="string">&quot;password&quot;</span>,String.class);</span><br><span class="line">    Object bean = generator.create();</span><br><span class="line">    Method setUserName = bean.getClass().getMethod(<span class="string">&quot;setUsername&quot;</span>, String.class);</span><br><span class="line">    Method setPassword = bean.getClass().getMethod(<span class="string">&quot;setPassword&quot;</span>, String.class);</span><br><span class="line">    setUserName.invoke(bean, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    setPassword.invoke(bean,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    BeanMap map = BeanMap.create(bean);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;admin&quot;</span>, map.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;password&quot;</span>, map.get(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用BeanGenerator生成了一个含有两个属性的Java Bean，对其进行赋值操作后，生成了一个BeanMap对象，通过获取值来进行验证</p><h2 id="keyFactory"><a href="#keyFactory" class="headerlink" title="keyFactory"></a>keyFactory</h2><p>keyFactory类用来动态生成接口的实例，接口需要只包含一个newInstance方法，返回一个Object。keyFactory为构造出来的实例动态生成了Object.equals和Object.hashCode方法，能够确保相同的参数构造出的实例为单例的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SampleKeyFactory &#123;</span><br><span class="line">    Object newInstance(String first, int second);</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure><p>我们首先构造一个满足条件的接口，然后进行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testKeyFactory() throws Exception&#123;</span><br><span class="line">    SampleKeyFactory keyFactory = (SampleKeyFactory) KeyFactory.create(SampleKeyFactory.class);</span><br><span class="line">    Object key = keyFactory.newInstance(&quot;foo&quot;, 42);</span><br><span class="line">    Object key1 = keyFactory.newInstance(&quot;foo&quot;, 42);</span><br><span class="line">    Assert.assertEquals(key,key1);//测试参数相同，结果是否相等</span><br><span class="line">&#125;1234567</span><br></pre></td></tr></table></figure><h2 id="Mixin-混合"><a href="#Mixin-混合" class="headerlink" title="Mixin(混合)"></a>Mixin(混合)</h2><p>Mixin能够让我们将多个对象整合到一个对象中去，前提是这些对象必须是接口的实现。可能这样说比较晦涩，以代码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class MixinInterfaceTest &#123;</span><br><span class="line">    interface Interface1&#123;</span><br><span class="line">        String first();</span><br><span class="line">    &#125;</span><br><span class="line">    interface Interface2&#123;</span><br><span class="line">        String second();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Class1 implements Interface1&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String first() &#123;</span><br><span class="line">            return &quot;first&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Class2 implements Interface2&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String second() &#123;</span><br><span class="line">            return &quot;second&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface MixinInterface extends Interface1, Interface2&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMixin() throws Exception&#123;</span><br><span class="line">        Mixin mixin = Mixin.create(new Class[]&#123;Interface1.class, Interface2.class,</span><br><span class="line">                        MixinInterface.class&#125;, new Object[]&#123;new Class1(),new Class2()&#125;);</span><br><span class="line">        MixinInterface mixinDelegate = (MixinInterface) mixin;</span><br><span class="line">        assertEquals(&quot;first&quot;, mixinDelegate.first());</span><br><span class="line">        assertEquals(&quot;second&quot;, mixinDelegate.second());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011121314151617181920212223242526272829303132333435</span><br></pre></td></tr></table></figure><p>Mixin类比较尴尬，因为他要求Minix的类（例如MixinInterface）实现一些接口。既然被Minix的类已经实现了相应的接口，那么我就直接可以通过纯Java的方式实现，没有必要使用Minix类。</p><h2 id="String-switcher"><a href="#String-switcher" class="headerlink" title="String switcher"></a>String switcher</h2><p>用来模拟一个String到int类型的Map类型。如果在Java7以后的版本中，类似一个switch语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testStringSwitcher() throws Exception&#123;</span><br><span class="line">    String[] strings = new String[]&#123;&quot;one&quot;, &quot;two&quot;&#125;;</span><br><span class="line">    int[] values = new int[]&#123;10,20&#125;;</span><br><span class="line">    StringSwitcher stringSwitcher = StringSwitcher.create(strings,values,true);</span><br><span class="line">    assertEquals(10, stringSwitcher.intValue(&quot;one&quot;));</span><br><span class="line">    assertEquals(20, stringSwitcher.intValue(&quot;two&quot;));</span><br><span class="line">    assertEquals(-1, stringSwitcher.intValue(&quot;three&quot;));</span><br><span class="line">&#125;123456789</span><br></pre></td></tr></table></figure><h2 id="Interface-Maker"><a href="#Interface-Maker" class="headerlink" title="Interface Maker"></a>Interface Maker</h2><p>正如名字所言，Interface Maker用来创建一个新的Interface</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testInterfaceMarker() throws Exception&#123;</span><br><span class="line">    Signature signature = new Signature(&quot;foo&quot;, Type.DOUBLE_TYPE, new Type[]&#123;Type.INT_TYPE&#125;);</span><br><span class="line">    InterfaceMaker interfaceMaker = new InterfaceMaker();</span><br><span class="line">    interfaceMaker.add(signature, new Type[0]);</span><br><span class="line">    Class iface = interfaceMaker.create();</span><br><span class="line">    assertEquals(1, iface.getMethods().length);</span><br><span class="line">    assertEquals(&quot;foo&quot;, iface.getMethods()[0].getName());</span><br><span class="line">    assertEquals(double.class, iface.getMethods()[0].getReturnType());</span><br><span class="line">&#125;12345678910</span><br></pre></td></tr></table></figure><p>上述的Interface Maker创建的接口中只含有一个方法，签名为double foo(int)。Interface Maker与上面介绍的其他类不同，它依赖ASM中的Type类型。由于接口仅仅只用做在编译时期进行类型检查，因此在一个运行的应用中动态的创建接口没有什么作用。但是InterfaceMaker可以用来自动生成代码，为以后的开发做准备。</p><h2 id="Method-delegate"><a href="#Method-delegate" class="headerlink" title="Method delegate"></a>Method delegate</h2><p>MethodDelegate主要用来对方法进行代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface BeanDelegate&#123;</span><br><span class="line">    String getValueFromDelegate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testMethodDelegate()  throws Exception&#123;</span><br><span class="line">    SampleBean bean = new SampleBean();</span><br><span class="line">    bean.setValue(&quot;Hello cglib&quot;);</span><br><span class="line">    BeanDelegate delegate = (BeanDelegate) MethodDelegate.create(bean,&quot;getValue&quot;, BeanDelegate.class);</span><br><span class="line">    assertEquals(&quot;Hello cglib&quot;, delegate.getValueFromDelegate());</span><br><span class="line">&#125;1234567891011</span><br></pre></td></tr></table></figure><p>关于Method.create的参数说明：<br>\1. 第二个参数为即将被代理的方法<br>\2. 第一个参数必须是一个无参数构造的bean。因此MethodDelegate.create并不是你想象的那么有用<br>\3. 第三个参数为只含有一个方法的接口。当这个接口中的方法被调用的时候，将会调用第一个参数所指向bean的第二个参数方法</p><p>缺点：<br>\1. 为每一个代理类创建了一个新的类，这样可能会占用大量的永久代堆内存<br>\2. 你不能代理需要参数的方法<br>\3. 如果你定义的接口中的方法需要参数，那么代理将不会工作，并且也不会抛出异常；如果你的接口中方法需要其他的返回类型，那么将抛出IllegalArgumentException</p><h2 id="MulticastDelegate"><a href="#MulticastDelegate" class="headerlink" title="MulticastDelegate"></a>MulticastDelegate</h2><ol><li>多重代理和方法代理差不多，都是将代理类方法的调用委托给被代理类。使用前提是需要一个接口，以及一个类实现了该接口</li><li>通过这种interface的继承关系，我们能够将接口上方法的调用分散给各个实现类上面去。</li><li>多重代理的缺点是接口只能含有一个方法，如果被代理的方法拥有返回值，那么调用代理类的返回值为最后一个添加的被代理类的方法返回值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface DelegatationProvider &#123;</span><br><span class="line">    void setValue(String value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleMulticastBean implements DelegatationProvider &#123;</span><br><span class="line">    private String value;</span><br><span class="line">    @Override</span><br><span class="line">    public void setValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testMulticastDelegate() throws Exception&#123;</span><br><span class="line">    MulticastDelegate multicastDelegate = MulticastDelegate.create(DelegatationProvider.class);</span><br><span class="line">    SimpleMulticastBean first = new SimpleMulticastBean();</span><br><span class="line">    SimpleMulticastBean second = new SimpleMulticastBean();</span><br><span class="line">    multicastDelegate = multicastDelegate.add(first);</span><br><span class="line">    multicastDelegate  = multicastDelegate.add(second);</span><br><span class="line"></span><br><span class="line">    DelegatationProvider provider = (DelegatationProvider) multicastDelegate;</span><br><span class="line">    provider.setValue(&quot;Hello world&quot;);</span><br><span class="line"></span><br><span class="line">    assertEquals(&quot;Hello world&quot;, first.getValue());</span><br><span class="line">    assertEquals(&quot;Hello world&quot;, second.getValue());</span><br><span class="line">&#125;123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure><h2 id="Constructor-delegate"><a href="#Constructor-delegate" class="headerlink" title="Constructor delegate"></a>Constructor delegate</h2><p>为了对构造函数进行代理，我们需要一个接口，这个接口只含有一个Object newInstance(…)方法，用来调用相应的构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface SampleBeanConstructorDelegate&#123;</span><br><span class="line">    Object newInstance(String value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对构造函数进行代理</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testConstructorDelegate() throws Exception&#123;</span><br><span class="line">    SampleBeanConstructorDelegate constructorDelegate = (SampleBeanConstructorDelegate) ConstructorDelegate.create(</span><br><span class="line">            SampleBean.class, SampleBeanConstructorDelegate.class);</span><br><span class="line">    SampleBean bean = (SampleBean) constructorDelegate.newInstance(&quot;Hello world&quot;);</span><br><span class="line">    assertTrue(SampleBean.class.isAssignableFrom(bean.getClass()));</span><br><span class="line">    System.out.println(bean.getValue());</span><br><span class="line">&#125;12345678910111213141516</span><br></pre></td></tr></table></figure><h2 id="Parallel-Sorter-并行排序器"><a href="#Parallel-Sorter-并行排序器" class="headerlink" title="Parallel Sorter(并行排序器)"></a>Parallel Sorter(并行排序器)</h2><p>能够对多个数组同时进行排序，目前实现的算法有归并排序和快速排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testParallelSorter() throws Exception&#123;</span><br><span class="line">    Integer[][] value = &#123;</span><br><span class="line">            &#123;4, 3, 9, 0&#125;,</span><br><span class="line">            &#123;2, 1, 6, 0&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ParallelSorter.create(value).mergeSort(0);</span><br><span class="line">    for(Integer[] row : value)&#123;</span><br><span class="line">        int former = -1;</span><br><span class="line">        for(int val : row)&#123;</span><br><span class="line">            assertTrue(former &lt; val);</span><br><span class="line">            former = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;123456789101112131415</span><br></pre></td></tr></table></figure><h2 id="FastClass"><a href="#FastClass" class="headerlink" title="FastClass"></a>FastClass</h2><p>顾明思义，FastClass就是对Class对象进行特定的处理，比如通过数组保存method引用，因此FastClass引出了一个index下标的新概念，比如getIndex(String name, Class[] parameterTypes)就是以前的获取method的方法。通过数组存储method,constructor等class信息，从而将原先的反射调用，转化为class.index的直接调用，从而体现所谓的FastClass。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFastClass() throws Exception&#123;</span><br><span class="line">    FastClass fastClass = FastClass.create(SampleBean.class);</span><br><span class="line">    FastMethod fastMethod = fastClass.getMethod(&quot;getValue&quot;,new Class[0]);</span><br><span class="line">    SampleBean bean = new SampleBean();</span><br><span class="line">    bean.setValue(&quot;Hello world&quot;);</span><br><span class="line">    assertEquals(&quot;Hello world&quot;,fastMethod.invoke(bean, new Object[0]));</span><br><span class="line">&#125;12345678</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。</p><h1 id="CGLIB和Java动态代理的区别"><a href="#CGLIB和Java动态代理的区别" class="headerlink" title="CGLIB和Java动态代理的区别"></a>CGLIB和Java动态代理的区别</h1><ol><li>Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；</li><li>Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效</li><li>3.</li></ol><p>CGLIB相关的文章：<br>- <a href="http://jnb.ociweb.com/jnb/jnbNov2005.html">http://jnb.ociweb.com/jnb/jnbNov2005.html</a><br>- <a href="http://www.iteye.com/topic/799827">http://www.iteye.com/topic/799827</a><br>- <a href="http://mydailyjava.blogspot.kr/2013/11/cglib-missing-manual.html">http://mydailyjava.blogspot.kr/2013/11/cglib-missing-manual.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是CGLIB&quot;&gt;&lt;a href=&quot;#什么是CGLIB&quot; class=&quot;headerlink&quot; title=&quot;什么是CGLIB&quot;&gt;&lt;/a&gt;什么是CGLIB&lt;/h1&gt;&lt;p&gt;CGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dyna</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="cglib" scheme="http://youngyjmaze.github.io/tags/cglib/"/>
    
    <category term="代理" scheme="http://youngyjmaze.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA泛型</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/JAVA%20%E6%B3%9B%E5%9E%8B/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/JAVA%20%E6%B3%9B%E5%9E%8B/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:48:06.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA-泛型"><a href="#JAVA-泛型" class="headerlink" title="JAVA 泛型"></a>JAVA 泛型</h2><p>一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。</p><p>因此，与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，<code>T</code> 就是类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Automobile&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;Automobile&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Automobile()); <span class="comment">// 此处有类型校验</span></span><br><span class="line">        Automobile a = h3.get();  <span class="comment">// 无需类型转换</span></span><br><span class="line">        <span class="comment">//- h3.set(&quot;Not an Automobile&quot;); // 报错</span></span><br><span class="line">        <span class="comment">//- h3.set(1);  // 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>GenericHolder</code> 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 <code>main()</code> 中那样使用。然后，你就只能在 <code>GenericHolder</code> 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 <code>get()</code> 取值时，直接就是正确的类型。</p><p>这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p><p>你可能注意到 <code>h3</code> 的定义非常繁复。在 <code>=</code> 左边有 <code>GenericHolder&lt;Automobile&gt;</code>, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Diamond.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bob</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diamond</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Bob&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Bob());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在 <code>h3</code> 的定义处，<code>=</code> 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。</p><h2 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h2><p>有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。</p><p>这个概念称为<em>元组</em>，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 <em>数据传输对象</em> 或 <em>信使</em> ）。</p><p>通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple2.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B a2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple2</span><span class="params">(A a, B b)</span> </span>&#123; a1 = a; a2 = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a1 + <span class="string">&quot;, &quot;</span> + a2; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + rep() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。</p><p>初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。<code>a1</code> 和 <code>a2</code> 应该声明为 <strong>private</strong>，然后提供 <code>getFirst()</code> 和 <code>getSecond()</code> 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 <code>a1</code> 和 <code>a2</code> 然后对它们执行任何操作，但无法对 <code>a1</code> 和 <code>a2</code> 重新赋值。例子中的 <code>final</code> 可以实现同样的效果，并且更为简洁明了。</p><p>另一种设计思路是允许元组的用户给 <code>a1</code> 和 <code>a2</code> 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 <code>Tuple2</code> 对象。</p><p>我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple3.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C a3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple3</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">        a3 = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple4.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> D a4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple4</span><span class="params">(A a, B b, C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c);</span><br><span class="line">        a4 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple5.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple5</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> E a5;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple5</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c, d);</span><br><span class="line">        a5 = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示需要，再定义两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Amphibian.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/Vehicle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 47 自动装箱为 Integer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        <span class="comment">// ttsi.a1 = &quot;there&quot;; // 编译错误，因为 final 不能重新赋值</span></span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> (hi, 47)</span></span><br><span class="line"><span class="comment"> (Amphibian@1540e19d, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。</p><p>通过 <code>ttsi.a1 = &quot;there&quot;</code> 语句的报错，我们可以看出，<strong>final</strong> 声明确实可以确保 <strong>public</strong> 字段在对象被构造出来之后就不能重新赋值了。</p><p>在上面的程序中，<code>new</code> 表达式有些啰嗦。本章稍后会介绍，如何利用 <em>泛型方法</em> 简化它们。</p><p>接下来我们看一个稍微复杂一点的例子：堆栈。在 <a href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book/book/12-Collections.md">集合</a> 一章中，我们用 <code>LinkedList</code> 实现了 <code>onjava.Stack</code> 类。在那个例子中，<code>LinkedList</code> 本身已经具备了创建堆栈所需的方法。<code>Stack</code> 是通过两个泛型类 <code>Stack&lt;T&gt;</code> 和 <code>LinkedList&lt;T&gt;</code> 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p><p>这次我们不用 <code>LinkedList</code> 来实现自己的内部链式存储机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LinkedStack.java</span></span><br><span class="line"><span class="comment">// 用链式结构实现的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node() &#123; item = <span class="keyword">null</span>; next = <span class="keyword">null</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;&gt;();  <span class="comment">// 栈顶</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; lss = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">&quot;Phasers on stun!&quot;</span>.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            lss.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = lss.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stun!</span><br><span class="line">on</span><br><span class="line">Phasers</span><br></pre></td></tr></table></figure><p>内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数。</p><p>这个例子使用了一个 <em>末端标识</em> (end sentinel) 来判断栈何时为空。这个末端标识是在构造 <code>LinkedStack</code> 时创建的。然后，每次调用 <code>push()</code> 就会创建一个 <code>Node&lt;T&gt;</code> 对象，并将其链接到前一个 <code>Node&lt;T&gt;</code> 对象。当你调用 <code>pop()</code> 方法时，总是返回 <code>top.item</code>，然后丢弃当前 <code>top</code> 所指向的 <code>Node&lt;T&gt;</code>，并将 <code>top</code> 指向下一个 <code>Node&lt;T&gt;</code>，除非到达末端标识，这时就不能再移动 <code>top</code> 了。如果已经到达末端，程序还继续调用 <code>pop()</code> 方法，它只能得到 <code>null</code>，说明栈已经空了。</p><h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RandomList.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(rand.nextInt(size()));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs = <span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        Arrays.stream(<span class="string">&quot;The quick brown fox jumped over the lazy brown dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)).forEach(rs::add);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">11</span>).forEach(i -&gt; </span><br><span class="line">            System.out.print(rs.select() + <span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brown over fox quick quick dog brown The brown lazy brown</span><br></pre></td></tr></table></figure><p><code>RandomList</code> 继承了 <code>ArrayList</code> 的所有方法。本例中只添加了 <code>select()</code> 这个方法。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口。例如 <em>生成器</em>，这是一种专门负责创建对象的类。实际上，这是 <em>工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。</p><p>一般而言，一个生成器只定义一个方法，用于创建对象。例如 <code>java.util.function</code> 类库中的 <code>Supplier</code> 就是一个生成器，调用其 <code>get()</code> 获取对象。<code>get()</code> 是泛型方法，返回值为类型参数 <code>T</code>。</p><p>为了演示 <code>Supplier</code>，我们需要定义几个类。下面是个咖啡相关的继承体系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/Coffee.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">&quot; &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Latte.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Mocha.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Cappuccino.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Americano.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Breve.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Breve</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以编写一个类，实现 <code>Supplier&lt;Coffee&gt;</code> 接口，它能够随机生成不同类型的 <code>Coffee</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/CoffeeSupplier.java</span></span><br><span class="line"><span class="comment">// &#123;java generics.coffee.CoffeeSupplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeSupplier</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Coffee</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] types = &#123; Latte.class, Mocha.class, </span><br><span class="line">        Cappuccino.class, Americano.class, Breve.class &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// For iteration:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123; size = sz; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = size;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count &gt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeSupplier.<span class="keyword">this</span>.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> CoffeeSupplier())</span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">for</span> (Coffee c : <span class="keyword">new</span> CoffeeSupplier(<span class="number">5</span>)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Americano 0</span><br><span class="line">Latte 1</span><br><span class="line">Americano 2</span><br><span class="line">Mocha 3</span><br><span class="line">Mocha 4</span><br><span class="line">Breve 5</span><br><span class="line">Americano 6</span><br><span class="line">Latte 7</span><br><span class="line">Cappuccino 8</span><br><span class="line">Cappuccino 9</span><br></pre></td></tr></table></figure><p>参数化的 <code>Supplier</code> 接口确保 <code>get()</code> 返回值是参数的类型。<code>CoffeeSupplier</code> 同时还实现了 <code>Iterable</code> 接口，所以能用于 <em>for-in</em> 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。</p><p>下面是另一个实现 <code>Supplier&lt;T&gt;</code> 接口的例子，它负责生成 Fibonacci 数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Fibonacci.java</span></span><br><span class="line"><span class="comment">// Generate a Fibonacci sequence</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> Fibonacci())</span><br><span class="line">              .limit(<span class="number">18</span>)</span><br><span class="line">              .map(n -&gt; n + <span class="string">&quot; &quot;</span>)</span><br><span class="line">              .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584</span><br></pre></td></tr></table></figure><p>虽然我们在 <code>Fibonacci</code> 类的里里外外使用的都是 <code>int</code> 类型，但是其参数类型却是 <code>Integer</code>。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 <code>Fibonacci</code> 类对 <code>int</code> 的使用，我们已经看到了这种效果。</p><p>如果还想更进一步，编写一个实现了 <code>Iterable</code> 的 <code>Fibnoacci</code> 生成器。我们的一个选择是重写这个类，令其实现 <code>Iterable</code> 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 <em>适配器</em> (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。</p><p>有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/IterableFibonacci.java</span></span><br><span class="line"><span class="comment">// Adapt the Fibonacci class to make it Iterable</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableFibonacci</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IterableFibonacci</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; n = count; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> IterableFibonacci.<span class="keyword">this</span>.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="keyword">new</span> IterableFibonacci(<span class="number">18</span>))</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584</span><br></pre></td></tr></table></figure><p>在 <em>for-in</em> 语句中使用 <code>IterableFibonacci</code>，必须在构造函数中提供一个边界值，这样 <code>hasNext()</code> 才知道何时返回 <strong>false</strong>，结束循环。</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。</p><p>泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。</p><p>如果方法是 <strong>static</strong> 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。</p><p>要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericMethods.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethods gm = <span class="keyword">new</span> GenericMethods();</span><br><span class="line">        gm.f(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">        gm.f(<span class="number">1.0F</span>);</span><br><span class="line">        gm.f(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.String</span></span><br><span class="line"><span class="comment">java.lang.Integer</span></span><br><span class="line"><span class="comment">java.lang.Double</span></span><br><span class="line"><span class="comment">java.lang.Float</span></span><br><span class="line"><span class="comment">java.lang.Character</span></span><br><span class="line"><span class="comment">GenericMethods</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>尽管可以同时对类及其方法进行参数化，但这里未将 <strong>GenericMethods</strong> 类参数化。只有方法 <code>f()</code> 具有类型参数，该参数由方法返回类型之前的参数列表指示。</p><p>对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 <em>类型参数推断</em>。因此，对 <code>f()</code> 的调用看起来像普通的方法调用，并且 <code>f()</code> 看起来像被重载了无数次一样。它甚至会接受 <strong>GenericMethods</strong> 类型的参数。</p><p>如果使用基本类型调用 <code>f()</code> ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。</p><h3 id="变长参数和泛型方法"><a href="#变长参数和泛型方法" class="headerlink" title="变长参数和泛型方法"></a>变长参数和泛型方法</h3><p>泛型方法和变长参数列表可以很好地共存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(</span><br><span class="line">                <span class="string">&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;</span>.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A]</span></span><br><span class="line"><span class="comment">[A, B, C]</span></span><br><span class="line"><span class="comment">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,</span></span><br><span class="line"><span class="comment">S, T, U, V, W, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此处显示的 <code>makeList()</code> 方法产生的功能与标准库的 <code>java.util.Arrays.asList()</code> 方法相同。</p><p><code>@SafeVarargs</code> 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。</p><h3 id="一个泛型的-Supplier"><a href="#一个泛型的-Supplier" class="headerlink" title="一个泛型的 Supplier"></a>一个泛型的 Supplier</h3><p>这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/BasicSupplier.java</span></span><br><span class="line"><span class="comment">// Supplier from a class with a no-arg constructor</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicSupplier</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Assumes type is a public class:</span></span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Produce a default Supplier from a type token:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicSupplier&lt;&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类提供了产生以下对象的基本实现：</p><ol><li>是 <strong>public</strong> 的。 因为 <strong>BasicSupplier</strong> 在单独的包中，所以相关的类必须具有 <strong>public</strong> 权限，而不仅仅是包级访问权限。</li><li>具有无参构造方法。要创建一个这样的 <strong>BasicSupplier</strong> 对象，请调用 <code>create()</code> 方法，并将要生成类型的类型令牌传递给它。通用的 <code>create()</code> 方法提供了 <code>BasicSupplier.create(MyType.class)</code> 这种较简洁的语法来代替较笨拙的 <code>new BasicSupplier &lt;MyType&gt;(MyType.class)</code>。</li></ol><p>例如，这是一个具有无参构造方法的简单类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CountedObject.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CountedObject &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CountedObject</strong> 类可以跟踪自身创建了多少个实例，并通过 <code>toString()</code> 报告这些实例的数量。 <strong>BasicSupplier</strong> 可以轻松地为 <strong>CountedObject</strong> 创建 <strong>Supplier</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// generics/BasicSupplierDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.BasicSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(</span><br><span class="line">                BasicSupplier.create(CountedObject.class))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CountedObject 0</span></span><br><span class="line"><span class="comment">CountedObject 1</span></span><br><span class="line"><span class="comment">CountedObject 2</span></span><br><span class="line"><span class="comment">CountedObject 3</span></span><br><span class="line"><span class="comment">CountedObject 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>泛型方法减少了产生 <strong>Supplier</strong> 对象所需的代码量。 Java 泛型强制传递 <strong>Class</strong> 对象，以便在 <code>create()</code> 方法中将其用于类型推断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JAVA-泛型&quot;&gt;&lt;a href=&quot;#JAVA-泛型&quot; class=&quot;headerlink&quot; title=&quot;JAVA 泛型&quot;&gt;&lt;/a&gt;JAVA 泛型&lt;/h2&gt;&lt;p&gt;一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="接口" scheme="http://youngyjmaze.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
    <category term="泛型" scheme="http://youngyjmaze.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>单元测试</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:48:07.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0818"><a href="#0818" class="headerlink" title="0818"></a>0818</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>人们倾向于将术语 <em>JUnit 5</em> 和 <em>JUnit Jupiter</em> 当作同义词使用。在大部分情况下，这种互换使用没有什么问题。但是，一定要认识到这两个术语是不同的。<em>JUnit Jupiter</em> 是使用 JUnit 5 编写测试内容的 API。<em>JUnit 5</em> 是一个项目名称（和版本），其 3 个主要模块关注不同的方面：JUnit Jupiter、JUnit Platform 和 JUnit Vintage。</p><p>当我提及 JUnit Jupiter 时，指的是编写单元测试的 API；提及 JUnit 5 时，指的是整个项目。</p><h4 id="JUnit-5-概述"><a href="#JUnit-5-概述" class="headerlink" title="JUnit 5 概述"></a>JUnit 5 概述</h4><p>以前的 JUnit 版本都是整体式的。除了在 4.4 版中包含 Hamcrest JAR，JUnit 基本来讲就是一个很大的 JAR 文件。测试内容编写者 — 像您我这样的开发人员 — 和工具供应商都使用它的 API，但后者使用很多内部 JUnit API。</p><p>大量使用内部 API 给 JUnit 的维护者造成了一些麻烦，并且留给他们推动该技术发展的选择余地不多。来自 <a href="http://junit.org/junit5/docs/current/user-guide/#api-evolution"><em>JUnit 5 用户指南</em></a>：</p><blockquote><p>“在 JUnit 4 中，只有外部扩展编写者和工具构建者才使用最初作为内部结构而添加的许多功能。这让更改 JUnit 4 变得特别困难，有时甚至根本不可能。”</p></blockquote><p>JUnit Lambda（现在称为 JUnit 5）团队决定将 JUnit 重新设计为两个明确且不同的关注区域：</p><ul><li>一个是编写测试内容的 API。</li><li>一个是发现和运行这些测试的 API。</li></ul><p>这些关注区域现在已整合到 JUnit 5 的架构中，并且它们是明确分离的。图 1 演示了新架构（图像来自 <a href="https://blog.codefx.org/design/architecture/junit-5-architecture/">Nicolai Parlog</a>）：</p><h5 id="图-1-JUnit-5-的架构"><a href="#图-1-JUnit-5-的架构" class="headerlink" title="图 1. JUnit 5 的架构"></a>图 1. JUnit 5 的架构</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-1.png" alt="JUnit 5 架构示意图。"></p><p>如果仔细查看图 1，就会发现 JUnit 5 的架构有多么强大。好了，让我们<em>仔细</em>看看这个架构。右上角的方框表明，对 JUnit 5 而言，JUnit Jupiter API 只是<em>另一个 API</em>！因为 JUnit Jupiter 的组件遵循新的架构，所以它们可应用 JUnit 5，但您可以轻松定义不同的测试框架。只要一个框架实现了 <code>TestEngine</code> 接口，就可以将它插入任何支持 <code>junit-platform-engine</code> 和 <code>junit-platform-launcher</code> API 的工具中！</p><p>我仍然认为 JUnit Jupiter 非常特殊（毕竟我即将用一整篇教程来介绍它），但 JUnit 5 团队完成的工作确实具有开创性。我只是想指出这一点。我们继续看看图 1，直到我们完全达成一致。</p><h4 id="使用-JUnit-Jupiter-编写测试内容"><a href="#使用-JUnit-Jupiter-编写测试内容" class="headerlink" title="使用 JUnit Jupiter 编写测试内容"></a>使用 JUnit Jupiter 编写测试内容</h4><p>就测试编写者而言，任何符合 JUnit 规范的测试框架（包括 JUnit Jupiter）都包含两个组件：</p><ul><li>我们为其编写测试的 API。</li><li>理解这个特定 API 的 JUnit <code>TestEngine</code> 实现。</li></ul><p>对于本教程，前者是 JUnit Jupiter API，后者是 JUnit Jupiter Test Engine。我将介绍这二者。</p><h5 id="JUnit-Jupiter-API"><a href="#JUnit-Jupiter-API" class="headerlink" title="JUnit Jupiter API"></a>JUnit Jupiter API</h5><p>作为开发人员，您将使用 JUnit Jupiter API 创建单元测试来测试您的应用程序代码。使用该 API 的基本特性 — 注解、断言等 — 是本部分教程的主要关注点。</p><p>JUnit Jupiter API 的设计让您可通过插入各种生命周期回调来扩展它的功能。您将在第 2 部分中了解如何使用这些回调完成有趣的工作，比如运行参数化测试，将参数传递给测试方法，等等。</p><h5 id="JUnit-Jupiter-Test-Engine"><a href="#JUnit-Jupiter-Test-Engine" class="headerlink" title="JUnit Jupiter Test Engine"></a>JUnit Jupiter Test Engine</h5><p>您将使用 JUnit Jupiter Test Engine 发现和执行 JUnit Jupiter 单元测试。该测试引擎实现了 JUnit Platform 中包含的 <code>TestEngine</code> 接口。可将 <code>TestEngine</code> 看作单元测试与用于启动它们的工具（比如 IDE）之间的桥梁。</p><h4 id="使用-JUnit-Platform-运行测试"><a href="#使用-JUnit-Platform-运行测试" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h4><p>在 JUnit 术语中，运行单元测试的过程分为两部分：</p><ul><li><em>发现</em>测试和创建<em>测试计划</em>。</li><li><em>启动</em>测试计划，以 (1) 执行测试和 (2) 向用户报告结果。</li></ul><h4 id="用于发现测试的-API"><a href="#用于发现测试的-API" class="headerlink" title="用于发现测试的 API"></a>用于发现测试的 API</h4><p>用于发现测试和创建测试计划的 API 包含在 JUnit Platform 中，由一个 <code>TestEngine</code> 实现。该测试框架将测试发现功能封装到其 <code>TestEngine</code> 实现中。JUnit Platform 负责使用 IDE 和构建工具（比如 Gradle 和 Maven）发起测试发现流程。</p><p>测试发现的目的是创建测试计划，该计划中包含一个<em>测试规范</em>。测试规范包含以下组件：</p><ul><li><p>选择器</p><p>，比如：</p><ul><li>要扫描哪个包来寻找测试类</li><li>特定的类名称</li><li>特定的方法</li><li>类路径根文件夹</li></ul></li><li><p>过滤器</p><p>，比如：</p><ul><li>类名称模式（比如 “.*Test”）</li><li>标签（将在第 2 部分中讨论）</li><li>特定的测试引擎（比如 “junit-jupiter”）</li></ul></li></ul><p>测试计划是根据测试规范所发现的所有测试类、这些类中的测试方法、测试引擎等的分层视图。测试计划准备就绪后，就可以执行了。</p><h4 id="用于执行测试的-API"><a href="#用于执行测试的-API" class="headerlink" title="用于执行测试的 API"></a>用于执行测试的 API</h4><p>用于执行测试的 API 包含在 JUnit Platform 中，由一个或多个 <code>TestEngine</code> 实现。测试框架将测试执行功能封装在它们的 <code>TestEngine</code> 实现中，但 JUnit Platform 负责发起测试执行流程。通过 IDE 和构建工具（比如 Gradle 和 Maven）发起测试执行工作。</p><p>一个名为 <code>Launcher</code> 的 JUnit Platform 组件负责执行在测试发现期间创建的测试计划。某个流程 — 假设是您的 IDE — 通过 JUnit Platform（具体来讲是 <code>junit-platform-launcher</code> API）发起测试执行流程。这时，JUnit Platform 将测试计划连同 <code>TestExecutionListener</code> 一起传递给 <code>Launcher</code>。<code>TestExecutionListener</code> 将报告测试执行结果，从而在您的 IDE 中显示该结果。</p><p>测试执行流程的目的是向用户准确报告在测试运行时发生了哪些事件。这包括测试成功和失败报告，以及伴随失败而生成的消息，帮助用户理解所发生的事件。</p><h4 id="后向兼容性：JUnit-Vintage"><a href="#后向兼容性：JUnit-Vintage" class="headerlink" title="后向兼容性：JUnit Vintage"></a>后向兼容性：JUnit Vintage</h4><p>许多组织对 JUnit 3 和 4 进行了大力投资，因此无法承担向 JUnit 5 的大规模转换。了解到这一点后，JUnit 5 团队提供了 <code>junit-vintage-engine</code> 和 <code>junit-jupiter-migration-support</code> 组件来帮助企业进行迁移。</p><p>对 JUnit Platform 而言，JUnit Vintage 只是另一个测试框架，包含自己的 <code>TestEngine</code> 和 API（具体来讲是 JUnit 4 API）。</p><p>图 2 显示了各种 JUnit 5 包之间的依赖关系。</p><h5 id="图-2-JUnit-5-包关系图"><a href="#图-2-JUnit-5-包关系图" class="headerlink" title="图 2. JUnit 5 包关系图"></a>图 2. JUnit 5 包关系图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-2.png" alt="JUnit 5 包示意图。"></p><h4 id="opentest4j-的用途"><a href="#opentest4j-的用途" class="headerlink" title="opentest4j 的用途"></a>opentest4j 的用途</h4><p>支持 JUnit 的测试框架在如何处理测试执行期间抛出的异常方面有所不同。JVM 上的测试没有统一标准，这是 JUnit 团队一直要面对的问题。除了 <code>java.lang.AssertionError</code>，测试框架还必须定义自己的异常分层结构，或者将自身与 JUnit 支持的异常结合起来（或者在某些情况下同时采取两种方法）。</p><p><strong>支持 opentest4j</strong>：要加入 Open Test Alliance for the JVM，或者提供反馈来帮助该联盟推进工作，请访问 <a href="https://github.com/ota4j-team/opentest4j">opentest4j</a> Github 存储库并单击 <em>CONTRIBUTING.md</em> 链接。</p><p>为了解决一致性问题，JUnit 团队提议建立一个开源项目，该项目目前称为 Open Test Alliance for the JVM（JVM 开放测试联盟）。该联盟在此阶段仅是一个提案，它仅定义了初步的异常分层结构。但是，JUnit 5 使用 <code>opentest4j</code> 异常。（可在图 2 中看到这一点；请注意从 <code>junit-jupiter-api</code> 和 <code>junit-platform-engine</code> 包到 <code>opentest4j</code> 包的依赖线。）</p><p>现在您已基本了解各种 JUnit 5 组件如何结合在一起，是时候使用 JUnit Jupiter API 编写一些测试了！</p><h3 id="使用-JUnit-Jupiter-编写测试"><a href="#使用-JUnit-Jupiter-编写测试" class="headerlink" title="使用 JUnit Jupiter 编写测试"></a>使用 JUnit Jupiter 编写测试</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>从 JUnit 4 开始，注解 (annotation) 就成为测试框架的核心特性，这一趋势在 JUnit 5 中得以延续。我无法介绍 JUnit 5 的所有注解，本节仅简要介绍最常用的注解。</p><p>首先，我将比较 JUnit 4 中与 JUnit 5 中的注解。JUnit 5 团队更改了一些注解的名称，让它们更直观，同时保持功能不变。如果您正在使用 JUnit 4，下表将帮助您适应这些更改。</p><h5 id="表-1-JUnit-4-与-JUnit-5-中的注解比较"><a href="#表-1-JUnit-4-与-JUnit-5-中的注解比较" class="headerlink" title="表 1. JUnit 4 与 JUnit 5 中的注解比较"></a>表 1. JUnit 4 与 JUnit 5 中的注解比较</h5><table><thead><tr><th>JUnit 5</th><th>JUnit 4</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>@Test</td><td>被注解的方法是一个测试方法。与 JUnit 4 相同。</td></tr><tr><td>@BeforeAll</td><td>@BeforeClass</td><td>被注解的（静态）方法将在当前类中的所有 @Test 方法前执行一次。</td></tr><tr><td>@BeforeEach</td><td>@Before</td><td>被注解的方法将在当前类中的每个 @Test 方法前执行。</td></tr><tr><td>@AfterEach</td><td>@After</td><td>被注解的方法将在当前类中的每个 @Test 方法后执行。</td></tr><tr><td>@AfterAll</td><td>@AfterClass</td><td>被注解的（静态）方法将在当前类中的所有 @Test 方法后执行一次。</td></tr><tr><td>@Disabled</td><td>@Ignore</td><td>被注解的方法不会执行（将被跳过），但会报告为已执行。</td></tr></tbody></table><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>接下来看看一些使用这些注解的示例。尽管一些注解已在 JUnit 5 中重命名，但如果您使用过 JUnit 4，应熟悉它们的功能。清单 1 中的代码来自 <code>JUnit5AppTest.java</code>，可在 <a href="https://github.com/makotogo/HelloJUnit5">HelloJUnit5</a> 示例应用程序中找到。</p><h5 id="清单-1-基本注解"><a href="#清单-1-基本注解" class="headerlink" title="清单 1. 基本注解"></a>清单 1. 基本注解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing using JUnit 5&quot;)``public class JUnit5AppTest &#123;`` ` ` ``private static final Logger log = LoggerFactory.getLogger(JUnit5AppTest.class);`` ` ` ``private App classUnderTest;`` ` ` ``@BeforeAll`` ``public static void init() &#123;``  ``// Do something before ANY test is run in this class`` ``&#125;`` ` ` ``@AfterAll`` ``public static void done() &#123;``  ``// Do something after ALL tests in this class are run`` ``&#125;`` ` ` ``@BeforeEach`` ``public void setUp() throws Exception &#123;``  ``classUnderTest = new App();`` ``&#125;`` ` ` ``@AfterEach`` ``public void tearDown() throws Exception &#123;``  ``classUnderTest = null;`` ``&#125;`` ` ` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void aTest() &#123;``  ``log.info(&quot;As written, this test will always pass!&quot;);``  ``assertEquals(4, (2 + 2));`` ``&#125;`` ` ` ``@Test`` ``@Disabled`` ``@DisplayName(&quot;A disabled test&quot;)`` ``void testNotRun() &#123;``  ``log.info(&quot;This test will not run (it is disabled, silly).&quot;);`` ``&#125;``.``.``&#125;</span><br></pre></td></tr></table></figure><p>看看上面突出显示行中的注解：</p><ul><li>第 1 行：<code>@RunWith</code> 连同它的参数 <code>JUnitPlatform.class</code>（一个基于 JUnit 4 且理解 JUnit Platform 的 <code>Runner</code>）让您可以在 Eclipse 内运行 JUnit Jupiter 单元测试。Eclipse 尚未原生支持 JUnit 5。未来，Eclipse 将提供原生的 JUnit 5 支持，那时我们不再需要此注解。</li><li>第 2 行：<code>@DisplayName</code> 告诉 JUnit 在报告测试结果时显示 <code>String</code> “Testing using JUnit 5”，而不是测试类的名称。</li><li>第 9 行：<code>@BeforeAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之前</em>运行 <code>init()</code> 方法<strong>一次</strong>。</li><li>第 14 行：<code>@AfterAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之后</em>运行 <code>done()</code> 方法<strong>一次</strong>。</li><li>第 19 行：<code>@BeforeEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之前</em>运行 <code>setUp()</code> 方法。</li><li>第 24 行：<code>@AfterEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之后</em>运行 <code>tearDown()</code> 方法。</li><li>第 29 行：<code>@Test</code> 告诉 JUnit，<code>aTest()</code> 方法是一个 JUnit Jupiter 测试方法。</li><li>第 37 行：<code>@Disabled</code> 告诉 JUnit 不运行此 <code>@Test</code> 方法，因为它已被禁用。</li></ul><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p><em>断言 (assertion)</em> 是 <code>org.junit.jupiter.api.Assertions</code> 类上的众多静态方法之一。断言用于测试一个条件，该条件必须计算为 <code>true</code>，测试才能继续执行。</p><p>如果断言失败，测试会在断言所在的代码行上停止，并生成断言失败报告。如果断言成功，测试会继续执行下一行代码。</p><p>表 2 中列出的所有 JUnit Jupiter 断言方法都接受一个可选的 <code>message</code> 参数（作为最后一个参数），以显示断言是否失败，而不是显示标准的缺省消息。</p><h5 id="表-2-JUnit-Jupiter-中的断言"><a href="#表-2-JUnit-Jupiter-中的断言" class="headerlink" title="表 2. JUnit Jupiter 中的断言"></a>表 2. JUnit Jupiter 中的断言</h5><table><thead><tr><th>断言方法</th><th>说明</th></tr></thead><tbody><tr><td><code>assertEquals(expected, actual)</code></td><td>如果 <em>expected</em> 不等于 <em>actual</em>，则断言失败。</td></tr><tr><td><code>assertFalse(booleanExpression)</code></td><td>如果 <em>booleanExpression</em> 不是 <code>false</code>，则断言失败。</td></tr><tr><td><code>assertNull(actual)</code></td><td>如果 <em>actual</em> 不是 <code>null</code>，则断言失败。</td></tr><tr><td><code>assertNotNull(actual)</code></td><td>如果 <em>actual</em> 是 <code>null</code>，则断言失败。</td></tr><tr><td><code>assertTrue(booleanExpression)</code></td><td>如果 <em>booleanExpression</em> 不是 <code>true</code>，则断言失败。</td></tr></tbody></table><p>清单 2 给出了一个使用这些断言的示例，该示例来自 HelloJUnit5 示例应用程序。</p><h5 id="清单-2-示例应用程序中的-JUnit-Jupiter-断言"><a href="#清单-2-示例应用程序中的-JUnit-Jupiter-断言" class="headerlink" title="清单 2. 示例应用程序中的 JUnit Jupiter 断言"></a>清单 2. 示例应用程序中的 JUnit Jupiter 断言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertEquals;``import static org.junit.jupiter.api.Assertions.assertFalse;``import static org.junit.jupiter.api.Assertions.assertNotNull;``import static org.junit.jupiter.api.Assertions.assertNull;``import static org.junit.jupiter.api.Assertions.assertTrue;``.``.`` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void dummyTest() &#123;``  ``int expected = 4;``  ``int actual = 2 + 2;``  ``assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;);``  ``//``  ``Object nullValue = null;``  ``assertFalse(nullValue != null);``  ``assertNull(nullValue);``  ``assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;);``  ``assertTrue(nullValue == null);``  ``.``  ``.`` ``&#125;</span><br></pre></td></tr></table></figure><p>看看上面突出显示行中的断言：</p><ul><li>第 13 行：<code>assertEquals</code>：如果第一个参数值 (4) 不等于第二个参数值 (2+2)，则断言失败。在报告断言失败时使用用户提供的消息（该方法的第 3 个参数）。</li><li>第 16 行：<code>assertFalse</code>：表达式 <code>nullValue != null</code> 必须为 <code>false</code>，否则断言失败。</li><li>第 17 行：<code>assertNull</code>：<code>nullValue</code> 参数必须为 <code>null</code>，否则断言失败。</li><li>第 18 行：<code>assertNotNull</code>：<code>String</code> 文字值 “A String” 不得为 <code>null</code>，否则断言失败并报告消息 “INCONCEIVABLE!”（而不是缺省的 “Assertion failed” 消息）。</li><li>第 19 行：<code>assertTrue</code>：如果表达式 <code>nullValue == null</code> 不等于 <code>true</code>，则断言失败。</li></ul><p>除了支持这些标准断言，JUnit Jupiter AP 还提供了多个新断言。下面介绍其中的两个。</p><h5 id="方法-assertAll"><a href="#方法-assertAll" class="headerlink" title="方法 @assertAll()"></a>方法 @assertAll()</h5><p>清单 3 中的 <code>@assertAll()</code> 方法给出了清单 2 中看到的相同断言，但包装在一个新的断言方法中：</p><h5 id="清单-3-assertAll"><a href="#清单-3-assertAll" class="headerlink" title="清单 3. assertAll()"></a>清单 3. assertAll()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertAll;``.``.``@Test``@DisplayName(&quot;Dummy test&quot;)``void dummyTest() &#123;`` ``int expected = 4;`` ``int actual = 2 + 2;`` ``Object nullValue = null;`` ``.`` ``.`` ``assertAll(``   ``&quot;Assert All of these&quot;,``   ``() -&gt; assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;),``   ``() -&gt; assertFalse(nullValue != null),``   ``() -&gt; assertNull(nullValue),``   ``() -&gt; assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;),``   ``() -&gt; assertTrue(nullValue == null));``&#125;</span><br></pre></td></tr></table></figure><p><code>assertAll()</code> 的有趣之处在于，它包含的<em>所有</em>断言都会执行，即使一个或多个断言失败也是如此。与此相反，在清单 2 中的代码中，如果<em>任何</em>断言失败，测试就会在该位置失败，意味着不会执行任何其他断言。</p><h5 id="方法-assertThrows"><a href="#方法-assertThrows" class="headerlink" title="方法 @assertThrows()"></a>方法 @assertThrows()</h5><p>在某些条件下，接受测试的类应抛出异常。JUnit 4 通过 <code>expected =</code> 方法参数或一个 <code>@Rule</code> 提供此能力。与此相反，JUnit Jupiter 通过 <code>Assertions</code> 类提供此能力，使它与其他断言更加一致。</p><p>我们将所预期的异常视为可以进行断言的另一个条件，因此 <code>Assertions</code> 包含处理此条件的方法。清单 4 引入了新的 <code>assertThrows()</code> 断言方法。</p><h5 id="清单-4-assertThrows"><a href="#清单-4-assertThrows" class="headerlink" title="清单 4. assertThrows()"></a>清单 4. assertThrows()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertThrows;``import static org.junit.jupiter.api.Assertions.assertEquals;``.``.``@Test()``@DisplayName(&quot;Empty argument&quot;)``public void testAdd_ZeroOperands_EmptyArgument() &#123;`` ``long[] numbersToSum = &#123;&#125;;`` ``assertThrows(IllegalArgumentException.class, () -&gt; classUnderTest.add(numbersToSum));``&#125;</span><br></pre></td></tr></table></figure><p>请注意第 9 行：如果对 <code>classUnderTest.add()</code> 的调用没有抛出 <code>IllegalArgumentException</code>，则断言失败。</p><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>前置条件 (Assumption) 与断言类似，但前置条件必须为 true，否则测试将<em>中止</em>。与此相反，当断言失败时，则将测试视为已<em>失败</em>。测试方法只应在某些条件 —<em>前置条件</em>下执行时，前置条件很有用。</p><p><em>前置条件</em>是 <code>org.junit.jupiter.api.Assumptions</code> 类的静态方法。要理解前置条件的价值，只需一个简单的示例。</p><p>假如您只想在星期五运行一个特定的单元测试（我假设您有自己的理由）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test``@DisplayName(&quot;This test is only run on Fridays&quot;)``public void testAdd_OnlyOnFriday() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumeTrue(ldt.getDayOfWeek().getValue() == 5);`` ``// Remainder of test (only executed if assumption holds)...``&#125;</span><br></pre></td></tr></table></figure><p>在此情况下，如果条件不成立（第 5 行），就不会执行 lambda 表达式的内容。</p><h5 id="使用断言还是前置条件"><a href="#使用断言还是前置条件" class="headerlink" title="使用断言还是前置条件"></a>使用断言还是前置条件</h5><p>二者的区别可能很细微，所以可使用这条经验法则：使用断言<em>检查一个测试方法的结果</em>。使用前置条件<em>确定是否运行测试方法</em>。不会将已中止的测试报告为失败，意味着这种失败不会中断构建工作。</p><p>请注意第 5 行：如果该条件不成立，则跳过该测试。在此情况下，该测试不是在星期五 (5) 运行的。这不会影响项目的 “绿色” 部分，而且不会导致构建失败；会跳过 <code>assumeTrue()</code> 后的测试方法中的所有代码。</p><p>如果在前置条件成立时仅应执行测试方法的一<em>部分</em>，可以使用 <code>assumingThat()</code> 方法编写上述条件，该方法使用 lambda 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test``@DisplayName(&quot;This test is only run on Fridays (with lambda)&quot;)``public void testAdd_OnlyOnFriday_WithLambda() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumingThat(ldt.getDayOfWeek().getValue() == 5,``   ``() -&gt; &#123;``    ``// Execute this if assumption holds...``   ``&#125;);`` ``// Execute this regardless``&#125;</span><br></pre></td></tr></table></figure><p>注意，无论 <code>assumingThat()</code> 中的前置条件成立与否，都会执行 lambda 表达式后的所有代码。</p><h4 id="嵌套单元测试，实现清晰的结构"><a href="#嵌套单元测试，实现清晰的结构" class="headerlink" title="嵌套单元测试，实现清晰的结构"></a>嵌套单元测试，实现清晰的结构</h4><p>在继续介绍下节内容之前，我想介绍在 JUnit 5 中编写单元测试的最后一个特性。</p><p>JUnit Jupiter API 允许您创建嵌套的类，以保持测试代码更清晰，这有助于让测试结果更易读。通过在主类中创建嵌套的测试类，可以创建更多的名称空间，这提供了两个主要优势：</p><ul><li>每个单元测试可以拥有自己的测试前和测试后生命周期。这让您能使用特殊条件创建要测试的类，从而测试极端情况。</li><li>单元测试方法的名称变得更简单。在 JUnit 4 中，所有测试方法都以对等形式存在，不允许重复的方法名（所以您最终会得到类似 <code>testMethodButOnlyUnderThisOrThatCondition_2()</code> 的方法名）。从 JUnit Jupiter 开始，只有嵌套类中的方法必须具有唯一的名称。清单 6 展示了这一优势。</li></ul><h5 id="清单-5-传递一个空或-null-数组引用"><a href="#清单-5-传递一个空或-null-数组引用" class="headerlink" title="清单 5. 传递一个空或 null 数组引用"></a>清单 5. 传递一个空或 null 数组引用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing JUnit 5&quot;)``public class JUnit5AppTest &#123;``.``.        `` ``@Nested`` ``@DisplayName(&quot;When zero operands&quot;)`` ``class JUnit5AppZeroOperandsTest &#123;`` ` ` ``// @Test methods go here...`` ` ` ``&#125;``.``.``&#125;</span><br></pre></td></tr></table></figure><p>请注意第 6 行，其中的 <code>JUnit5AppZeroOperandsTest</code> 类可以拥有测试方法。任何测试的结果都会在父类 <code>JUnit5AppTest</code> 中以嵌套的形式显示。</p><h4 id="使用-JUnit-Platform-运行测试-1"><a href="#使用-JUnit-Platform-运行测试-1" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h4><p>能编写单元测试很不错，但如果不能运行它们，就没有什么意义了。本节展示如何在 Eclipse 中运行 JUnit 测试，首先使用 Maven，然后从命令行使用 Gradle。</p><p>下面的视频展示了如何从 GitHub 克隆示例应用程序代码，并在 Eclipse 中运行测试。在该视频中，我还展示了如何从命令行以及 Eclipse 内使用 Maven 和 Gradle 运行单元测试。Eclipse 对 Maven 和 Gradle 都提供了很好的支持。</p><p><strong>应用 3 种工具运行单元测试</strong></p><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/intro-to-java-junit.png" alt="应用 3种工具运行单元测试"></p><p>下面将提供一些简要的说明，但该视频提供了更多细节。观看该视频，了解如何：</p><ul><li>从 GitHub 克隆 HelloJUnit5 示例应用程序。</li><li>将应用程序导入 Eclipse 中。</li><li>从 Eclipse 内的 HelloJUnit5 应用程序运行一个 JUnit 测试。</li><li>使用 Maven 从命令行运行 HelloJUnit5 单元测试。</li><li>使用 Gradle 从命令行运行 HelloJUnit5 单元测试。</li></ul><h5 id="克隆-HelloJUnit5-示例应用程序"><a href="#克隆-HelloJUnit5-示例应用程序" class="headerlink" title="克隆 HelloJUnit5 示例应用程序"></a>克隆 HelloJUnit5 示例应用程序</h5><p>要理解教程的剩余部分，您需要从 GitHub 克隆示例应用程序。为此，可打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您希望放入代码的目录，然后输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/makotogo/HelloJUnit5</span><br></pre></td></tr></table></figure><p>现在您的机器上已拥有该代码，可以在 Eclipse IDE 内运行 JUnit 测试了。接下来介绍如何运行测试。</p><h5 id="在-Eclipse-IDE-中运行单元测试"><a href="#在-Eclipse-IDE-中运行单元测试" class="headerlink" title="在 Eclipse IDE 中运行单元测试"></a>在 Eclipse IDE 中运行单元测试</h5><p>如果您已跟随该视频进行操作，应该已将代码导入 Eclipse 中。现在，在 Eclipse 中打开 <strong>Project Explorer</strong> 视图，展开 HelloJUnit5 项目，直至看到 <code>src/test/java</code> 路径下的 <code>JUnit5AppTest</code> 类。</p><p>打开 <code>JUnit5AppTest.java</code> 并验证 <code>class</code> 定义前的下面这个注解（以下代码的第 3 行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.``.``@RunWith(JUnitPlatform.class)``public class JUnit5AppTest &#123;``.``.``&#125;</span><br></pre></td></tr></table></figure><p>现在右键单击 <code>JUnit5AppTest</code> 并选择 <strong>Run As &gt; JUnit Test</strong>。单元测试运行时，JUnit 视图将会出现。您现在已准备好完成本教程的练习。</p><h5 id="使用-Maven-运行单元测试"><a href="#使用-Maven-运行单元测试" class="headerlink" title="使用 Maven 运行单元测试"></a>使用 Maven 运行单元测试</h5><p>打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您将 HelloJUnit5 应用程序克隆到的目录，然后输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure><p>这会启动 Maven 构建并运行单元测试。您的输出应类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean test``[INFO] Scanning for projects...``[INFO]                                     ``[INFO] ------------------------------------------------------------------------``[INFO] Building HelloJUnit5 1.0.2``[INFO] ------------------------------------------------------------------------``[INFO] ``[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ HelloJUnit5 ---``[INFO] Deleting /Users/sperry/home/development/projects/learn/HelloJUnit5/target``[INFO] ``[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/main/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:compile (default-compile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/classes``[INFO] ``[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/test/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:testCompile (default-testCompile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/test-classes``[INFO] ``[INFO] --- maven-surefire-plugin:2.19:test (default-test) @ HelloJUnit5 ---` `-------------------------------------------------------`` ``T E S T S``-------------------------------------------------------``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Running com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Tests run: 1, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 0.038 sec - in com.makotojava.learn.hellojunit5.solution.JUnit5AppTest` `Results :` `Tests run: 1, Failures: 0, Errors: 0, Skipped: 1` `[INFO] ------------------------------------------------------------------------``[INFO] BUILD SUCCESS``[INFO] ------------------------------------------------------------------------``[INFO] Total time: 3.741 s``[INFO] Finished at: 2017-11-28T18:04:50-06:00``[INFO] Final Memory: 21M/255M``[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h5 id="Running-unit-tests-with-Gradle"><a href="#Running-unit-tests-with-Gradle" class="headerlink" title="Running unit tests with Gradle"></a>Running unit tests with Gradle</h5><p>Open a terminal window (Mac) or command prompt (Windows), navigate to the directory where you cloned the HelloJUnit5 application, and enter this command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle clean test</span><br></pre></td></tr></table></figure><p>The output should look like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gradle clean test``Starting a Gradle Daemon (subsequent builds will be faster)``:clean``:compileJava``:processResources NO-SOURCE``:classes``:compileTestJava``:processTestResources NO-SOURCE``:testClasses``:junitPlatformTest``ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.` `Test run finished after 10097 ms``[     7 containers found   ]``[     5 containers skipped  ]``[     2 containers started  ]``[     0 containers aborted  ]``[     2 containers successful ]``[     0 containers failed   ]``[    10 tests found      ]``[    10 tests skipped     ]``[     0 tests started     ]``[     0 tests aborted     ]``[     0 tests successful   ]``[     0 tests failed     ]` `:test SKIPPED` `BUILD SUCCESSFUL` `Total time: 21.014 secs</span><br></pre></td></tr></table></figure><h4 id="测试练习"><a href="#测试练习" class="headerlink" title="测试练习"></a>测试练习</h4><p>现在您已了解 JUnit Jupiter，查看了代码示例，并观看了视频（希望您已跟随视频进行操作）。非常棒，但没有什么比动手编写代码更有用了！在第 1 部分的最后一节，您将完成以下任务：</p><ul><li>编写 JUnit Jupiter API 单元测试。</li><li>运行单元测试。</li><li>实现 <code>App</code> 类，让您的单元测试通过检查。</li></ul><p>采用真正的测试驱动开发 (TDD) 方式，首先编写单元测试，运行它们，并会观察到它们全部失败了。然后编写实现，直到单元测试通过，这时您就大功告成了。</p><p>注意，<code>JUnit5AppTest</code> 类仅提供了两个现成的测试方法。首次运行该类时，二者都是 “绿色” 的。要完成这些练习，您需要添加剩余的代码，包括用于告诉 JUnit 运行哪些测试方法的注解。记住，如果没有正确配备一个类或方法，JUnit 将跳过它。</p><p>如果遇到困难，请查阅 <code>com.makotojava.learn.hellojunit5.solution</code> 包来寻找解决方案。</p><p>1</p><h5 id="编写-JUnit-Jupiter-单元测试"><a href="#编写-JUnit-Jupiter-单元测试" class="headerlink" title="编写 JUnit Jupiter 单元测试"></a>编写 JUnit Jupiter 单元测试</h5><p>首先从 <code>JUnit5AppTest.java</code> 开始。打开此文件并按照 Javadoc 注解中的指示操作。</p><p><strong>提示</strong>：使用 Eclipse 中的 Javadoc 视图读取测试指令。要打开 Javadoc 视图，可以转到 <strong>Window &gt; Show View &gt; Javadoc</strong>。您应该看到 Javadoc 视图。根据您设置工作区的方式，该窗口可能出现在任意多个位置。在我的工作区中，该窗口与图 3 中的屏幕截图类似，出现在 IDE 右侧的编辑器窗口下方：</p><h5 id="图-3-Javadoc-视图"><a href="#图-3-Javadoc-视图" class="headerlink" title="图 3. Javadoc 视图"></a>图 3. Javadoc 视图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-3.png" alt="Javadoc 视图的屏幕截图。"></p><p>编辑器窗口中显示了具有原始 HTML 标记的 Javadoc 注解，但在 Javadoc 窗口中，已将其格式化，因此更易于阅读。</p><h5 id="在-Eclipse-中运行单元测试"><a href="#在-Eclipse-中运行单元测试" class="headerlink" title="在 Eclipse 中运行单元测试"></a>在 Eclipse 中运行单元测试</h5><p>如果您像我一样，您会使用 IDE 执行以下工作：</p><ul><li>编写单元测试。</li><li>编写单元测试所测试的实现内容。</li><li>运行初始测试（使用 IDE 的原生 JUnit 支持）。</li></ul><p>JUnit 5 提供了一个名为 <code>JUnitPlatform</code> 的类，它允许您在 Eclipse 中运行 JUnit 5 测试。</p><p><strong>Eclipse 中的 JUnit 5</strong>：Eclipse 目前能理解 JUnit 4，但尚未提供对 JUnit 5 的原生支持。幸运的是，这对大部分单元测试而言都不是什么大问题！除非您需要使用 JUnit 4 一些更复杂的特性，否则要编写单元测试来全面检查您的应用程序代码，<code>JUnitPlatform</code> 类就足够了。</p><p>要在 Eclipse 中运行测试，需要确保您的计算机上拥有示例应用程序。为此，最轻松的方法是从 GitHub 克隆 HelloJUnit5 应用程序，然后将它导入 Eclipse 中。（因为本教程的视频展示了如何这么做，所以这里将跳过细节，仅提供操作步骤。）</p><p>确保您克隆了 GitHub 存储库，然后将代码导入 Eclipse 中作为新的 Maven 项目。</p><p>将该项目导入 Eclipse 中后，打开 <strong>Project Explorer</strong> 视图并展开 <code>src/main/test</code> 节点，直至看到 <code>JUnit5AppTest</code>。要以 JUnit 测试的形式运行它，可以右键单击它，选择 <strong>Run As &gt; JUnit Test</strong>。</p><h5 id="实现-App-类，直到单元测试通过检查"><a href="#实现-App-类，直到单元测试通过检查" class="headerlink" title="实现 App 类，直到单元测试通过检查"></a>实现 App 类，直到单元测试通过检查</h5><p><code>App</code> 的单一 <code>add()</code> 方法提供的功能很容易理解，而且在设计上非常简单。我不希望复杂应用程序的业务逻辑阻碍您对 JUnit Jupiter 的学习。</p><p>单元测试通过后，您就大功告成了！记住，如果遇到困难，可以在 <code>com.makotojava.learn.hellojunit5.solution</code> 包中查找解决方案。</p><h4 id="第-1-部分小结"><a href="#第-1-部分小结" class="headerlink" title="第 1 部分小结"></a>第 1 部分小结</h4><p>在 JUnit 5 教程的前半部分中，我介绍了 JUnit 5 的架构和组件，并详细介绍了 JUnit Jupiter API。我们逐个介绍了 JUnit 5 中最常用的注解、断言和前置条件，而且通过一个快速练习演示了如何在 Eclipse、Maven 和 Gradle 中运行测试。</p><p>在<a href="http://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part2-vintage-jupiter-extension-model/index.html">第 2 部分</a>中，您将了解 JUnit 5 的一些高级特性：</p><ul><li>JUnit Jupiter 扩展模型</li><li>方法参数注入</li><li>参数化测试</li></ul><p>那么您接下来会怎么做？</p><h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0818&quot;&gt;&lt;a href=&quot;#0818&quot; class=&quot;headerlink&quot; title=&quot;0818&quot;&gt;&lt;/a&gt;0818&lt;/h1&gt;&lt;h2 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;headerlink&quot; title=&quot;单元测试&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="测试" scheme="http://youngyjmaze.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="junit" scheme="http://youngyjmaze.github.io/tags/junit/"/>
    
    <category term="testng" scheme="http://youngyjmaze.github.io/tags/testng/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 容器</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/JAVA%E5%AE%B9%E5%99%A8%E7%B1%BB/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/JAVA%E5%AE%B9%E5%99%A8%E7%B1%BB/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:47:41.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA容器类"><a href="#JAVA容器类" class="headerlink" title="JAVA容器类"></a>JAVA容器类</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：</p><ol><li><strong>集合（Collection）</strong> ：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong> 必须以插入的顺序保存元素， <strong>Set</strong> 不能包含重复元素， <strong>Queue</strong> 按照<em>排队规则</em>来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li><li><strong>映射（Map）</strong> ： 一组成对的“键值对”对象，允许使用键来查找值。 <strong>ArrayList</strong> 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 <strong>map</strong> 允许我们使用一个对象来查找另一个对象，它也被称作<em>关联数组</em>（associative array），因为它将对象和其它对象关联在一起；或者称作<em>字典</em>（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 <strong>Map</strong> 是强大的编程工具。</li></ol><p>尽管并非总是可行，但在理想情况下，你编写的大部分代码都在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个 <strong>List</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>请注意， <strong>ArrayList</strong> 已经被向上转型为了 <strong>List</strong> ，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。</p><p>这种方式并非总是有效的，因为某些具体类有额外的功能。例如， <strong>LinkedList</strong> 具有 <strong>List</strong> 接口中未包含的额外方法，而 <strong>TreeMap</strong> 也具有在 <strong>Map</strong> 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。</p><p><strong>Collection</strong> 接口概括了<em>序列</em>的概念——一种存放一组对象的方式。下面是个简单的示例，用 <strong>Integer</strong> 对象填充了一个 <strong>Collection</strong> （这里用 <strong>ArrayList</strong> 表示），然后打印集合中的每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SimpleCollection.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCollection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      c.add(i); <span class="comment">// Autoboxing</span></span><br><span class="line">    <span class="keyword">for</span>(Integer i : c)</span><br><span class="line">      System.out.print(i + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个例子仅使用了 <strong>Collection</strong> 中的方法（即 <code>add()</code> ），所以使用任何继承自 <strong>Collection</strong> 的类的对象都可以正常工作。但是 <strong>ArrayList</strong> 是最基本的序列类型。</p><p><code>add()</code> 方法的名称就表明它是在 <strong>Collection</strong> 中添加一个新元素。但是，文档中非常详细地叙述到 <code>add()</code> “要确保这个 <strong>Collection</strong> 包含指定的元素。”这是因为考虑到了 <strong>Set</strong> 的含义，因为在 <strong>Set</strong>中，只有当元素不存在时才会添加元素。在使用 <strong>ArrayList</strong> ，或任何其他类型的 <strong>List</strong> 时，<code>add()</code> 总是表示“把它放进去”，因为 <strong>List</strong> 不关心是否存在重复元素。</p><p>可以使用 <em>for-in</em> 语法来遍历所有的 <strong>Collection</strong> ，就像这里所展示的那样。在本章的后续部分，还将学习到一个更灵活的概念，<em>迭代器</em>。</p><h2 id="添加元素组"><a href="#添加元素组" class="headerlink" title="添加元素组"></a>添加元素组</h2><p>在 <strong>java.util</strong> 包中的 <strong>Arrays</strong> 和 <strong>Collections</strong> 类中都有很多实用的方法，可以在一个 <strong>Collection</strong> 中添加一组元素。</p><p><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。 <code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中。下边的示例展示了这两个方法，以及更通用的 、所有 <strong>Collection</strong> 类型都包含的<code>addAll()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AddingGroups.java</span></span><br><span class="line"><span class="comment">// Adding groups of elements to Collection objects</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroups</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; collection =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    Integer[] moreInts = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    collection.addAll(Arrays.asList(moreInts));</span><br><span class="line">    <span class="comment">// Runs significantly faster, but you can&#x27;t</span></span><br><span class="line">    <span class="comment">// construct a Collection this way:</span></span><br><span class="line">    Collections.addAll(collection, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>);</span><br><span class="line">    Collections.addAll(collection, moreInts);</span><br><span class="line">    <span class="comment">// Produces a list &quot;backed by&quot; an array:</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>);</span><br><span class="line">    list.set(<span class="number">1</span>, <span class="number">99</span>); <span class="comment">// OK -- modify an element</span></span><br><span class="line">    <span class="comment">// list.add(21); // Runtime error; the underlying</span></span><br><span class="line">                     <span class="comment">// array cannot be resized.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Collection</strong> 的构造器可以接受另一个 <strong>Collection</strong>，用它来将自身初始化。因此，可以使用 <code>Arrays.asList()</code> 来为这个构造器产生输入。但是， <code>Collections.addAll()</code> 运行得更快，而且很容易构建一个不包含元素的 <strong>Collection</strong> ，然后调用 <code>Collections.addAll()</code> ，因此这是首选方式。</p><p><code>Collection.addAll()</code> 方法只能接受另一个 <strong>Collection</strong> 作为参数，因此它没有 <code>Arrays.asList()</code> 或 <code>Collections.addAll()</code> 灵活。这两个方法都使用可变参数列表。</p><p><strong>也可以直接使用 <code>Arrays.asList()</code> 的输出作为一个 List，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 List上调用 <code>add()</code> 或 <code>remove()</code>，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AsListInference.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Powder</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heavy</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crusty</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slush</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsListInference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Snow&gt; snow1 = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Crusty(), <span class="keyword">new</span> Slush(), <span class="keyword">new</span> Powder());</span><br><span class="line">    <span class="comment">//- snow1.add(new Heavy()); // Exception</span></span><br><span class="line"></span><br><span class="line">    List&lt;Snow&gt; snow2 = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy());</span><br><span class="line">    <span class="comment">//- snow2.add(new Slush()); // Exception</span></span><br><span class="line"></span><br><span class="line">    List&lt;Snow&gt; snow3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(snow3,</span><br><span class="line">      <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy(), <span class="keyword">new</span> Powder());</span><br><span class="line">    snow3.add(<span class="keyword">new</span> Crusty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint with explicit type argument specification:</span></span><br><span class="line">    List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList(</span><br><span class="line">       <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy(), <span class="keyword">new</span> Slush());</span><br><span class="line">    <span class="comment">//- snow4.add(new Powder()); // Exception</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>snow4</strong> 中，注意 <code>Arrays.asList()</code> 中间的“暗示”（即 <code>&lt;Snow&gt;</code> ），告诉编译器 <code>Arrays.asList()</code> 生成的结果 <strong>List</strong> 类型的实际目标类型是什么。这称为<em>显式类型参数说明</em>（explicit type argument specification）。</p><h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><p><strong>List</strong>承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p><p>有两种类型的 <strong>List</strong> ：</p><ul><li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li><li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集。</li></ul><p>下面的示例导入 <strong>typeinfo.pets</strong> ，超前使用了<a href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book">类型信息</a>一章中的类库。这个类库包含了 <strong>Pet</strong> 类层次结构，以及用于随机生成 <strong>Pet</strong> 对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点：</p><ol><li>有一个 <strong>Pet</strong> 类，以及 <strong>Pet</strong> 的各种子类型。</li><li>静态的 <code>Pets.arrayList()</code> 方法返回一个填充了随机选取的 <strong>Pet</strong> 对象的 <strong>ArrayList</strong>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ListFeatures.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFeatures</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;1: &quot;</span> + pets);</span><br><span class="line">    Hamster h = <span class="keyword">new</span> Hamster();</span><br><span class="line">    pets.add(h); <span class="comment">// Automatically resizes</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2: &quot;</span> + pets);</span><br><span class="line">    System.out.println(<span class="string">&quot;3: &quot;</span> + pets.contains(h));</span><br><span class="line">    pets.remove(h); <span class="comment">// Remove by object</span></span><br><span class="line">    Pet p = pets.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;4: &quot;</span> +  p + <span class="string">&quot; &quot;</span> + pets.indexOf(p));</span><br><span class="line">    Pet cymric = <span class="keyword">new</span> Cymric();</span><br><span class="line">    System.out.println(<span class="string">&quot;5: &quot;</span> + pets.indexOf(cymric));</span><br><span class="line">    System.out.println(<span class="string">&quot;6: &quot;</span> + pets.remove(cymric));</span><br><span class="line">    <span class="comment">// Must be the exact object:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;7: &quot;</span> + pets.remove(p));</span><br><span class="line">    System.out.println(<span class="string">&quot;8: &quot;</span> + pets);</span><br><span class="line">    pets.add(<span class="number">3</span>, <span class="keyword">new</span> Mouse()); <span class="comment">// Insert at an index</span></span><br><span class="line">    System.out.println(<span class="string">&quot;9: &quot;</span> + pets);</span><br><span class="line">    List&lt;Pet&gt; sub = pets.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;10: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    Collections.sort(sub); <span class="comment">// In-place sort</span></span><br><span class="line">    System.out.println(<span class="string">&quot;sorted subList: &quot;</span> + sub);</span><br><span class="line">    <span class="comment">// Order is not important in containsAll():</span></span><br><span class="line">    System.out.println(<span class="string">&quot;11: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    Collections.shuffle(sub, rand); <span class="comment">// Mix it up</span></span><br><span class="line">    System.out.println(<span class="string">&quot;shuffled subList: &quot;</span> + sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;12: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    List&lt;Pet&gt; copy = <span class="keyword">new</span> ArrayList&lt;&gt;(pets);</span><br><span class="line">    sub = Arrays.asList(pets.get(<span class="number">1</span>), pets.get(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sub: &quot;</span> + sub);</span><br><span class="line">    copy.retainAll(sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;13: &quot;</span> + copy);</span><br><span class="line">    copy = <span class="keyword">new</span> ArrayList&lt;&gt;(pets); <span class="comment">// Get a fresh copy</span></span><br><span class="line">    copy.remove(<span class="number">2</span>); <span class="comment">// Remove by index</span></span><br><span class="line">    System.out.println(<span class="string">&quot;14: &quot;</span> + copy);</span><br><span class="line">    copy.removeAll(sub); <span class="comment">// Only removes exact objects</span></span><br><span class="line">    System.out.println(<span class="string">&quot;15: &quot;</span> + copy);</span><br><span class="line">    copy.set(<span class="number">1</span>, <span class="keyword">new</span> Mouse()); <span class="comment">// Replace an element</span></span><br><span class="line">    System.out.println(<span class="string">&quot;16: &quot;</span> + copy);</span><br><span class="line">    copy.addAll(<span class="number">2</span>, sub); <span class="comment">// Insert a list in the middle</span></span><br><span class="line">    System.out.println(<span class="string">&quot;17: &quot;</span> + copy);</span><br><span class="line">    System.out.println(<span class="string">&quot;18: &quot;</span> + pets.isEmpty());</span><br><span class="line">    pets.clear(); <span class="comment">// Remove all elements</span></span><br><span class="line">    System.out.println(<span class="string">&quot;19: &quot;</span> + pets);</span><br><span class="line">    System.out.println(<span class="string">&quot;20: &quot;</span> + pets.isEmpty());</span><br><span class="line">    pets.addAll(Pets.list(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;21: &quot;</span> + pets);</span><br><span class="line">    Object[] o = pets.toArray();</span><br><span class="line">    System.out.println(<span class="string">&quot;22: &quot;</span> + o[<span class="number">3</span>]);</span><br><span class="line">    Pet[] pa = pets.toArray(<span class="keyword">new</span> Pet[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;23: &quot;</span> + pa[<span class="number">3</span>].id());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]</span></span><br><span class="line"><span class="comment">3: true</span></span><br><span class="line"><span class="comment">4: Cymric 2</span></span><br><span class="line"><span class="comment">5: -1</span></span><br><span class="line"><span class="comment">6: false</span></span><br><span class="line"><span class="comment">7: true</span></span><br><span class="line"><span class="comment">8: [Rat, Manx, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">subList: [Manx, Mutt, Mouse]</span></span><br><span class="line"><span class="comment">10: true</span></span><br><span class="line"><span class="comment">sorted subList: [Manx, Mouse, Mutt]</span></span><br><span class="line"><span class="comment">11: true</span></span><br><span class="line"><span class="comment">shuffled subList: [Mouse, Manx, Mutt]</span></span><br><span class="line"><span class="comment">12: true</span></span><br><span class="line"><span class="comment">sub: [Mouse, Pug]</span></span><br><span class="line"><span class="comment">13: [Mouse, Pug]</span></span><br><span class="line"><span class="comment">14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">15: [Rat, Mutt, Cymric, Pug]</span></span><br><span class="line"><span class="comment">16: [Rat, Mouse, Cymric, Pug]</span></span><br><span class="line"><span class="comment">17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">18: false</span></span><br><span class="line"><span class="comment">19: []</span></span><br><span class="line"><span class="comment">20: true</span></span><br><span class="line"><span class="comment">21: [Manx, Cymric, Rat, EgyptianMau]</span></span><br><span class="line"><span class="comment">22: EgyptianMau</span></span><br><span class="line"><span class="comment">23: 14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>打印行都编了号，因此可从输出追溯到源代码。 第 1 行输出展示了原始的由 <strong>Pet</strong> 组成的 <strong>List</strong> 。 与数组不同， <strong>List</strong> 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。在第 2 行输出中可以看到添加一个 <strong>Hamster</strong> 的结果，该对象将被追加到列表的末尾。</p><p>可以使用 <code>contains()</code> 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 <code>remove()</code> 方法。同样，如果有一个对象的引用，可以使用 <code>indexOf()</code> 在 <strong>List</strong> 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。</p><p>当确定元素是否是属于某个 <strong>List</strong> ，寻找某个元素的索引，以及通过引用从 <strong>List</strong> 中删除元素时，都会用到 <code>equals()</code> 方法（根类 <strong>Object</strong> 的一个方法）。每个 <strong>Pet</strong> 被定义为一个唯一的对象，所以即使列表中已经有两个 <strong>Cymrics</strong> ，如果再创建一个新的 <strong>Cymric</strong> 对象并将其传递给 <code>indexOf()</code> 方法，结果仍为 <strong>-1</strong> （表示未找到），并且尝试调用 <code>remove()</code> 方法来删除这个对象将返回 <strong>false</strong> 。对于其他类， <code>equals()</code> 的定义可能有所不同。例如，如果两个 <strong>String</strong> 的内容相同，则这两个 <strong>String</strong> 相等。因此，为了防止出现意外，请务必注意 <strong>List</strong> 行为会根据 <code>equals()</code> 行为而发生变化。</p><p>第 7、8 行输出展示了删除与 <strong>List</strong> 中的对象完全匹配的对象是成功的。</p><p>可以在 <strong>List</strong> 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 <strong>LinkedList</strong> ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 <strong>ArrayList</strong> ，这可是代价高昂的操作。这是否意味着永远不应该在 <strong>ArrayList</strong> 的中间插入元素，并最好是转换为 <strong>LinkedList</strong> ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 <strong>ArrayList</strong> 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 <strong>List</strong> 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。</p><p><code>subList()</code> 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 <code>containsAll()</code> 方法时，很自然地会得到 <strong>true</strong>。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 <strong>sub</strong> 上调用直观命名的 <code>Collections.sort()</code> 和 <code>Collections.shuffle()</code> 方法，不会影响 <code>containsAll()</code> 的结果。 <code>subList()</code> 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。</p><p><code>retainAll()</code> 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 <strong>copy</strong> 和 <strong>sub</strong> 中的所有元素。请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。</p><p>第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 <code>equals()</code> 的行为。</p><p><code>removeAll()</code> 方法也是基于 <code>equals()</code> 方法运行的。 顾名思义，它会从 <strong>List</strong> 中删除在参数 <strong>List</strong> 中的所有元素。</p><p><code>set()</code> 方法的命名显得很不合时宜，因为它与 <strong>Set</strong> 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。</p><p>第 17 行输出表明，对于 <strong>List</strong> ，有一个重载的 <code>addAll()</code> 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 <strong>Collection</strong> 的 <code>addAll()</code> 方法将其追加到列表的末尾。</p><p>第 18 - 20 行输出展示了 <code>isEmpty()</code> 和 <code>clear()</code> 方法的效果。</p><p>第 22、23 行输出展示了如何使用 <code>toArray()</code> 方法将任意的 <strong>Collection</strong> 转换为数组。这是一个重载方法，其无参版本返回一个 <strong>Object</strong> 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 <strong>List</strong> 中的所有元素（就像本例一样），则 <code>toArray()</code> 会创建一个具有合适尺寸的新数组。 <strong>Pet</strong> 对象有一个 <code>id()</code> 方法，可以在所产生的数组中的对象上调用这个方法。</p><h2 id="迭代器Iterators"><a href="#迭代器Iterators" class="headerlink" title="迭代器Iterators"></a>迭代器Iterators</h2><p>在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 <strong>List</strong> ， <code>add()</code> 是插入元素的一种方式， <code>get()</code> 是获取元素的一种方式。</p><p>如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 <strong>List</strong> 编码的，但是后来发现如果能够将相同的代码应用于 <strong>Set</strong> 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？</p><p><em>迭代器</em>（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为<em>轻量级对象</em>（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p><ol><li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li><li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li><li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li><li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li></ol><p>为了观察它的工作方式，这里再次使用<a href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book">类型信息</a>章节中的 <strong>Pet</strong> 工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SimpleIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">12</span>);</span><br><span class="line">    Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// A simpler approach, when possible:</span></span><br><span class="line">    <span class="keyword">for</span>(Pet p : pets)</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// An Iterator can also remove elements:</span></span><br><span class="line">    it = pets.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>有了 <strong>Iterator</strong> ，就不必再为集合中元素的数量操心了。这是由 <code>hasNext()</code> 和 <code>next()</code> 关心的事情。</p><p>如果只是想向前遍历 <strong>List</strong> ，并不打算修改 <strong>List</strong> 对象本身，那么使用 <em>for-in</em> 语法更加简洁。</p><p><strong>Iterator还可以删除由 <code>next()</code> 生成的最后一个元素，这意味着在调用 <code>remove()</code> 之前必须先调用 <code>next()</code> 。</strong></p><p>在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。</p><p>现在考虑创建一个 <code>display()</code> 方法，它不必知晓集合的确切类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossCollectionIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> HashSet&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> TreeSet&lt;&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>display()</code> 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 <strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。</p><p>我们可以使用 <strong>Iterable</strong> 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 <strong>Iterator</strong> 的任何东西”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration2.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossCollectionIteration2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterable&lt;Pet&gt; ip)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Pet&gt; it = ip.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> HashSet&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> TreeSet&lt;&gt;(pets);</span><br><span class="line">    display(pets);</span><br><span class="line">    display(petsLL);</span><br><span class="line">    display(petsHS);</span><br><span class="line">    display(petsTS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里所有的类都是 <strong>Iterable</strong> ，所以现在对 <code>display()</code> 的调用显然更简单。</p><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。 下面的示例演示了所有这些能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ListIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">      System.out.print(it.next() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.nextIndex() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// Backwards:</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasPrevious())</span><br><span class="line">      System.out.print(it.previous().id() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.set(Pets.get());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug,</span></span><br><span class="line"><span class="comment">5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;</span></span><br><span class="line"><span class="comment">7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster,</span></span><br><span class="line"><span class="comment">EgyptianMau]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Pets.get()</code> 方法用来从位置 3 开始替换 <strong>List</strong> 中的所有 Pet 对象。</p><h2 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h2><p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p><p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p><ul><li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>addFirst()</code> 在列表的开头插入一个元素。</li><li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li><li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li></ul><p>下面的示例展示了这些功能之间基本的相似性和差异性。它并不是重复执行 <strong>ListFeatures.java</strong> 中所示的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/LinkedListFeatures.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListFeatures</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Pet&gt; pets =</span><br><span class="line">      <span class="keyword">new</span> LinkedList&lt;&gt;(Pets.list(<span class="number">5</span>));</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    <span class="comment">// Identical:</span></span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.getFirst(): &quot;</span> + pets.getFirst());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.element(): &quot;</span> + pets.element());</span><br><span class="line">    <span class="comment">// Only differs in empty-list behavior:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pets.peek(): &quot;</span> + pets.peek());</span><br><span class="line">    <span class="comment">// Identical; remove and return the first element:</span></span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.remove(): &quot;</span> + pets.remove());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.removeFirst(): &quot;</span> + pets.removeFirst());</span><br><span class="line">    <span class="comment">// Only differs in empty-list behavior:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pets.poll(): &quot;</span> + pets.poll());</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    pets.addFirst(<span class="keyword">new</span> Rat());</span><br><span class="line">    System.out.println(<span class="string">&quot;After addFirst(): &quot;</span> + pets);</span><br><span class="line">    pets.offer(Pets.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;After offer(): &quot;</span> + pets);</span><br><span class="line">    pets.add(Pets.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;After add(): &quot;</span> + pets);</span><br><span class="line">    pets.addLast(<span class="keyword">new</span> Hamster());</span><br><span class="line">    System.out.println(<span class="string">&quot;After addLast(): &quot;</span> + pets);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.removeLast(): &quot;</span> + pets.removeLast());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug]</span></span><br><span class="line"><span class="comment">pets.getFirst(): Rat</span></span><br><span class="line"><span class="comment">pets.element(): Rat</span></span><br><span class="line"><span class="comment">pets.peek(): Rat</span></span><br><span class="line"><span class="comment">pets.remove(): Rat</span></span><br><span class="line"><span class="comment">pets.removeFirst(): Manx</span></span><br><span class="line"><span class="comment">pets.poll(): Cymric</span></span><br><span class="line"><span class="comment">[Mutt, Pug]</span></span><br><span class="line"><span class="comment">After addFirst(): [Rat, Mutt, Pug]</span></span><br><span class="line"><span class="comment">After offer(): [Rat, Mutt, Pug, Cymric]</span></span><br><span class="line"><span class="comment">After add(): [Rat, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]</span></span><br><span class="line"><span class="comment">pets.removeLast(): Hamster</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Pets.list()</code> 的结果被传递给 <strong>LinkedList</strong> 的构造器，以便使用它来填充 <strong>LinkedList</strong> 。如果查看 <strong>Queue</strong> 接口就会发现，它在 <strong>LinkedList</strong> 的基础上添加了 <code>element()</code> ， <code>offer()</code> ， <code>peek()</code> ， <code>poll()</code> 和 <code>remove()</code> 方法，以使其可以成为一个 <strong>Queue</strong> 的实现。 <strong>Queue</strong> 的完整示例将在本章稍后给出。</p><h2 id="堆栈Stack"><a href="#堆栈Stack" class="headerlink" title="堆栈Stack"></a>堆栈Stack</h2><p>堆栈是“后进先出”（LIFO）集合。它有时被称为<em>叠加栈</em>（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。经常用来类比栈的事物是带有弹簧支架的自助餐厅托盘。最后装入的托盘总是最先拿出来使用的。</p><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 <strong>ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// collections/StackTest.java</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class StackTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">    for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    while(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + &quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Output:</span><br><span class="line">fleas has dog My</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>即使它是作为一个堆栈在使用，我们仍然必须将其声明为 <strong>Deque</strong> 。有时一个名为 <strong>Stack</strong> 的类更能把事情讲清楚：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// onjava/Stack.java</span><br><span class="line">// A Stack class built with an ArrayDeque</span><br><span class="line">package onjava;</span><br><span class="line">import java.util.Deque;</span><br><span class="line">import java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line">public class Stack&lt;T&gt; &#123;</span><br><span class="line">  private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();</span><br><span class="line">  public void push(T v) &#123; storage.push(v); &#125;</span><br><span class="line">  public T peek() &#123; return storage.peek(); &#125;</span><br><span class="line">  public T pop() &#123; return storage.pop(); &#125;</span><br><span class="line">  public boolean isEmpty() &#123; return storage.isEmpty(); &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return storage.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了使用泛型的类定义的最简单的可能示例。类名称后面的 告诉编译器这是一个参数化类型，而其中的类型参数 <strong>T</strong> 会在使用类时被实际类型替换。基本上，这个类是在声明“我们在定义一个可以持有 <strong>T</strong> 类型对象的 <strong>Stack</strong> 。” <strong>Stack</strong> 是使用 <strong>ArrayDeque</strong> 实现的，而 <strong>ArrayDeque</strong> 也被告知它将持有 <strong>T</strong> 类型对象。注意， <code>push()</code> 接受类型为 <strong>T</strong> 的对象，而 <code>peek()</code> 和 <code>pop()</code> 返回类型为 <strong>T</strong> 的对象。 <code>peek()</code> 方法将返回栈顶元素，但并不将其从栈顶删除，而 <code>pop()</code> 删除并返回顶部元素。</p><p>如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类（在<a href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book">附录：集合主题</a>中将会看到， <strong>Java 1.0</strong> 设计者在创建 <strong>java.util.Stack</strong> 时，就犯了这个错误）。使用组合，可以选择要公开的方法以及如何命名它们。</p><p>下面将使用 <strong>StackTest.java</strong> 中的相同代码来演示这个新的 <strong>Stack</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackTest2.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果想在自己的代码中使用这个 <strong>Stack</strong> 类，当在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能会与 <strong>java.util</strong> 包中的 <strong>Stack</strong> 发生冲突。例如，如果我们在上面的例子中导入 **java.util.***，那么就必须使用包名来防止冲突：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackCollision.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackCollision</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    onjava.Stack&lt;String&gt; stack = <span class="keyword">new</span> onjava.Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    java.util.Stack&lt;String&gt; stack2 =</span><br><span class="line">      <span class="keyword">new</span> java.util.Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack2.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack2.empty())</span><br><span class="line">      System.out.print(stack2.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>尽管已经有了 <strong>java.util.Stack</strong> ，但是 <strong>ArrayDeque</strong> 可以产生更好的 <strong>Stack</strong> ，因此更可取。</p><p>还可以使用显式导入来控制对“首选” <strong>Stack</strong> 实现的选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import onjava.Stack;</span><br></pre></td></tr></table></figure><p>现在,任何对 <strong>Stack</strong> 的引用都将选择 <strong>onjava</strong> 版本，而在选择 <strong>java.util.Stack</strong> 时，必须使用全限定名称（full qualification）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA容器类&quot;&gt;&lt;a href=&quot;#JAVA容器类&quot; class=&quot;headerlink&quot; title=&quot;JAVA容器类&quot;&gt;&lt;/a&gt;JAVA容器类&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="容器" scheme="http://youngyjmaze.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="基础知识" scheme="http://youngyjmaze.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>内部类和嵌套类</title>
    <link href="http://youngyjmaze.github.io/2020/05/26/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E7%B1%BB/"/>
    <id>http://youngyjmaze.github.io/2020/05/26/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E7%B1%BB/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2021-10-18T11:55:38.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部类和嵌套类"><a href="#内部类和嵌套类" class="headerlink" title="内部类和嵌套类"></a>内部类和嵌套类</h1><h2 id="内部类方法和作用域"><a href="#内部类方法和作用域" class="headerlink" title="内部类方法和作用域"></a>内部类方法和作用域</h2><p>可以在一个方法里面或者在任意的作用域内定义内部类。</p><p>这么做有两个理由：</p><ol><li>如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。</li><li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</li></ol><p>在后面的例子中，先前的代码将被修改，以用来实现：</p><ol><li>一个定义在方法中的类。</li><li>一个定义在作用域内的类，此作用域在方法的内部。</li><li>一个实现了接口的匿名类。</li><li>一个匿名类，它扩展了没有默认构造器的类。</li><li>一个匿名类，它执行字段初始化。</li><li>一个匿名类，它通过实例初始化实现构造（匿名内部类不可能有构造器）。</li></ol><p>第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel5.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a method</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">          </span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 p = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PDestination</strong> 类是 <code>destination()</code> 方法的一部分，而不是 <strong>Parcel5</strong> 的一部分。所以，在 <code>destination()</code> 之外不能访问 <strong>PDestination</strong>，注意出现在 <strong>return</strong> 语句中的向上转型-返回的是 <strong>Destination</strong> 的引用，它是 <strong>PDestination</strong> 的基类。当然，在 <code>destination()</code> 中定义了内部类 <strong>PDestination</strong>，并不意味着一旦 <code>destination()</code> 方法执行完毕，<strong>PDestination</strong> 就不可用了。</p><p>第二个例子展示了如何在任意的作用域内嵌入一个内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel6.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a scope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span> </span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">&quot;slip&quot;</span>);</span><br><span class="line">            String s = ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Can&#x27;t use it here! Out of scope:</span></span><br><span class="line">        <span class="comment">//- TrackingSlip ts = new TrackingSlip(&quot;x&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span> </span>&#123; internalTracking(<span class="keyword">true</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel6 p = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TrackingSlip</strong> 类被嵌入在 <strong>if</strong> 语句的作用域内，这并不是说该类的创建是有条件的，<strong>它其实与别的类一起编译过了</strong>。然而，在定义 <strong>Trackingslip</strong> 的作用域之外，它是不可用的，除此之外，它与普通的类一样。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>下面的例子看起来有点奇怪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel7.java</span></span><br><span class="line"><span class="comment">// Returning an instance of an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123; <span class="comment">// Insert class definition</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">          </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">        &#125;; <span class="comment">// Semicolon required</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7 p = <span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>contents()</code> 方法将返回值的生成与表示这个返回值的类的定义结合在一起！另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个 <strong>Contents</strong> 对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义。”</p><p>这种奇怪的语法指的是：“创建一个继承自 <strong>Contents</strong> 的匿名类的对象。”通过 <strong>new</strong> 表达式返回的引用被自动向上转型为对 <strong>Contents</strong> 的引用。上述匿名内部类的语法是下述形式的简化形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel7b.java</span></span><br><span class="line"><span class="comment">// Expanded version of Parcel7.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyContents();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7b p = <span class="keyword">new</span> Parcel7b();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个匿名内部类中，使用了默认的构造器来生成 <strong>Contents</strong>。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel8.java</span></span><br><span class="line"><span class="comment">// Calling the base-class constructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Base constructor call:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123; <span class="comment">// [1]</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// [2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel8 p = <span class="keyword">new</span> Parcel8();</span><br><span class="line">        Wrapping w = p.wrapping(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>[1] 将合适的参数传递给基类的构造器。</p></li><li><p>[2] 在匿名内部类末尾的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的地方使用的分号是一致的。</p><p>尽管 <strong>Wrapping</strong> 只是一个具有具体实现的普通类，但它还是被导出类当作公共“接口”来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Wrapping.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; i = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/AnonymousConstructor.java</span></span><br><span class="line"><span class="comment">// Creating a constructor for an anonymous inner class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    Base(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor, i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(i) &#123;</span><br><span class="line">            &#123; System.out.println(</span><br><span class="line">                    <span class="string">&quot;Inside instance initializer&quot;</span>); &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;In anonymous f()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = getBase(<span class="number">47</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor, i = 47</span><br><span class="line">Inside instance initializer</span><br><span class="line">In anonymous f()</span><br></pre></td></tr></table></figure><p>在此例中，不要求变量一定是 <strong>final</strong> 的。因为被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。</p><p>下例是带实例初始化的”parcel”形式。注意 <code>destination()</code> 的参数必须是 <strong>final</strong> 的，因为它们是在匿名类内部使用的（译者注：即使不加 <strong>final</strong>, Java 8 的编译器也会为我们自动加上 <strong>final</strong>，以保证数据的一致性）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel10.java</span></span><br><span class="line"><span class="comment">// Using &quot;instance initialization&quot; to perform</span></span><br><span class="line"><span class="comment">// construction on an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination</span></span><br><span class="line"><span class="function">    <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            <span class="comment">// Instance initialization for each object:</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">                    System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel10 p = <span class="keyword">new</span> Parcel10();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Over budget!</span><br></pre></td></tr></table></figure><p>在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是 <strong>if</strong> 语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制-你不能重载实例初始化方法，所以你仅有一个这样的构造器。</p><p>匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 <strong>static</strong>，这通常称为嵌套类。想要理解 <strong>static</strong> 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p><ol><li>要创建嵌套类的对象，并不需要其外部类的对象。</li><li>不能从嵌套类的对象中访问非静态的外部类对象。</li></ol><p>嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 <strong>static</strong> 数据和 <strong>static</strong> 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel11.java</span></span><br><span class="line"><span class="comment">// Nested classes (static inner classes)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel11</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ParcelDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        <span class="comment">// Nested classes can contain other static elements:</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelContents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Contents c = contents();</span><br><span class="line">        Destination d = destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3><p>嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 <strong>public</strong> 和 <strong>static</strong> 的。因为类是 <strong>static</strong> 的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现其外部接口，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/ClassInInterface.java</span></span><br><span class="line"><span class="comment">// &#123;java ClassInInterface$Test&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Howdy!</span><br></pre></td></tr></table></figure><p>如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。</p><p>我曾在本书中建议过，在每个类中都写一个 <code>main()</code> 方法，用来测试这个类。这样做有一个缺点，那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/TestBed.java</span></span><br><span class="line"><span class="comment">// Putting test code in a nested class</span></span><br><span class="line"><span class="comment">// &#123;java TestBed$Tester&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;f()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            TestBed t = <span class="keyword">new</span> TestBed();</span><br><span class="line">            t.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f()</span><br></pre></td></tr></table></figure><h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外部类的所有成员，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiNestingAccess.java</span></span><br><span class="line"><span class="comment">// Nested classes can access all members of all</span></span><br><span class="line"><span class="comment">// levels of the classes they are nested within</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                g();</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiNestingAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MNA mna = <span class="keyword">new</span> MNA();</span><br><span class="line">        MNA.A mnaa = mna.n<span class="function">ew <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        MNA.A.B mnaab = mnaa.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        mnaab.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <strong>MNA.A.B</strong> 中，调用方法 <code>g()</code> 和 <code>f()</code> 不需要任何条件（即使它们被定义为 <strong>private</strong>）。这个例子同时展示了如何从不同的类里创建多层嵌套的内部类对象的基本语法。”<strong>.new</strong>“语法能产生正确的作用域，所以不必在调用构造器时限定类名。</p><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>至此，我们已经看到了许多描述内部类的语法和语义，但是这并不能同答“为什么需要内部类”这个问题。那么，Java 设计者们为什么会如此费心地增加这项基本的语言特性呢？</p><p>一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部类的对象。所以可以认为内部类提供了某种进入其外部类的窗口。</p><p>内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外部类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外部类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：</p><blockquote><p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p></blockquote><p>如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。</p><p>为了看到更多的细节，让我们考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择；使用单一类，或者使用内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/mui/MultiInterfaces.java</span></span><br><span class="line"><span class="comment">// Two ways a class can implement multiple interfaces</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.mui.MultiInterfaces&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses.mui;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">makeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Anonymous inner class:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X x = <span class="keyword">new</span> X();</span><br><span class="line">        Y y = <span class="keyword">new</span> Y();</span><br><span class="line">        takesA(x);</span><br><span class="line">        takesA(y);</span><br><span class="line">        takesB(x);</span><br><span class="line">        takesB(y.makeB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这里假设在两种方式下的代码结构都确实有逻辑意义。然而遇到问题的时候，通常问题本身就能给出某些指引，告诉你是应该使用单一类，还是使用内部类。但如果没有任何其他限制，从实现的观点来看，前面的例子并没有什么区别，它们都能正常运作。</p><p>如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiImplementation.java</span></span><br><span class="line"><span class="comment">// For concrete or abstract classes, inner classes</span></span><br><span class="line"><span class="comment">// produce &quot;multiple implementation inheritance&quot;</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.MultiImplementation&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">makeE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> E() &#123;&#125;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiImplementation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesD</span><span class="params">(D d)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesE</span><span class="params">(E e)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Z z = <span class="keyword">new</span> Z();</span><br><span class="line">        takesD(z);</span><br><span class="line">        takesE(z.makeE());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：</p><ol><li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立。</li><li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。 稍后就会展示一个这样的例子。</li><li>创建内部类对象的时刻并不依赖于外部类对象的创建</li><li>内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。</li></ol><p>举个例子，如果 <strong>Sequence.java</strong> 不使用内部类，就必须声明”<strong>Sequence</strong> 是一个 <strong>Selector</strong>“，对于某个特定的 <strong>Sequence</strong> 只能有一个 <strong>Selector</strong>，然而使用内部类很容易就能拥有另一个方法 <code>reverseSelector()</code>，用它来生成一个反方向遍历序列的 <strong>Selector</strong>，只有内部类才有这种灵活性。</p><h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3><p>闭包（<strong>closure</strong>）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 <strong>private</strong> 成员。</p><p>在 Java 8 之前，内部类是实现闭包的唯一方式。在 Java 8 中，我们可以使用 lambda 表达式来实现闭包行为，并且语法更加优雅和简洁，你将会在 <a href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book">函数式编程 </a>这一章节中学习相关细节。尽管相对于内部类，你可能更喜欢使用 lambda 表达式实现闭包，但是你会看到并需要理解那些在 Java 8 之前通过内部类方式实现闭包的代码，因此仍然有必要来理解这种方式。</p><p>Java 最引人争议的问题之一就是，人们认为 Java 应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java 更小心仔细，所以没有在语言中包括指针。</p><p>通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。见下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Callbacks.java</span></span><br><span class="line"><span class="comment">// Using inner classes for callbacks</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.Callbacks&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Very simple to just implement the interface:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span> </span>&#123; mi.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If your class must implement increment() in</span></span><br><span class="line"><span class="comment">// some other way, you must use an inner class:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise</span></span><br><span class="line">            <span class="comment">// you&#x27;ll get an infinite recursion:</span></span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; callbackReference.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee1 c1 = <span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2 = <span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2 =</span><br><span class="line">                <span class="keyword">new</span> Caller(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Other operation</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">Other operation</span><br><span class="line">2</span><br><span class="line">Other operation</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>这个例子进一步展示了外部类实现一个接口与内部类实现此接口之间的区别。就代码而言，<strong>Callee1</strong> 是更简单的解决方式。<strong>Callee2</strong> 继承自 <strong>MyIncrement</strong>，后者已经有了一个不同的 <code>increment()</code> 方法，并且与 <strong>Incrementable</strong> 接口期望的 <code>increment()</code> 方法完全不相关。所以如果 <strong>Callee2</strong> 继承了 <strong>MyIncrement</strong>，就不能为了 <strong>Incrementable</strong> 的用途而覆盖 <code>increment()</code> 方法，于是只能使用内部类独立地实现 <strong>Incrementable</strong>，还要注意，当创建了一个内部类时，并没有在外部类的接口中添加东西，也没有修改外部类的接口。</p><p>注意，在 <strong>Callee2</strong> 中除了 <code>getCallbackReference()</code> 以外，其他成员都是 <strong>private</strong> 的。要想建立与外部世界的任何连接，接口 <strong>Incrementable</strong> 都是必需的。在这里可以看到，<strong>interface</strong> 是如何允许接口与接口的实现完全独立的。 内部类 <strong>Closure</strong> 实现了 <strong>Incrementable</strong>，以提供一个返回 <strong>Callee2</strong> 的“钩子”（hook）-而且是一个安全的钩子。无论谁获得此 <strong>Incrementable</strong> 的引用，都只能调用 <code>increment()</code>，除此之外没有其他功能（不像指针那样，允许你做很多事情）。</p><p><strong>Caller</strong> 的构造器需要一个 <strong>Incrementable</strong> 的引用作为参数（虽然可以在任意时刻捕获回调引用），然后在以后的某个时刻，<strong>Caller</strong> 对象可以使用此引用回调 <strong>Callee</strong> 类。</p><p>回调的价值在于它的灵活性-可以在运行时动态地决定需要调用什么方法。例如，在图形界面实现 GUI 功能的时候，到处都用到回调。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内部类和嵌套类&quot;&gt;&lt;a href=&quot;#内部类和嵌套类&quot; class=&quot;headerlink&quot; title=&quot;内部类和嵌套类&quot;&gt;&lt;/a&gt;内部类和嵌套类&lt;/h1&gt;&lt;h2 id=&quot;内部类方法和作用域&quot;&gt;&lt;a href=&quot;#内部类方法和作用域&quot; class=&quot;header</summary>
      
    
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://youngyjmaze.github.io/tags/java/"/>
    
    <category term="内部类" scheme="http://youngyjmaze.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
    <category term="嵌套" scheme="http://youngyjmaze.github.io/tags/%E5%B5%8C%E5%A5%97/"/>
    
  </entry>
  
</feed>
