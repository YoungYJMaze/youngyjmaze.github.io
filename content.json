{"meta":{"title":"Hexo","subtitle":"","description":"","author":"youngyj","url":"http://youngyjmaze.github.io","root":"/"},"pages":[{"title":"about","date":"2021-10-18T08:16:07.000Z","updated":"2021-10-18T08:16:07.482Z","comments":true,"path":"about/index.html","permalink":"http://youngyjmaze.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-10-18T08:16:17.000Z","updated":"2021-10-18T08:16:17.047Z","comments":true,"path":"friends/index.html","permalink":"http://youngyjmaze.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-18T08:16:20.000Z","updated":"2021-10-18T08:16:20.702Z","comments":true,"path":"categories/index.html","permalink":"http://youngyjmaze.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-18T08:16:13.000Z","updated":"2021-10-18T08:16:13.738Z","comments":true,"path":"tags/index.html","permalink":"http://youngyjmaze.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"JAVA方法引用","date":"2021-10-18T07:13:48.291Z","updated":"2021-10-18T07:13:06.047Z","comments":true,"path":"2021/10/18/JAVA方法引用/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/JAVA%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"方法引用Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 ::，然后跟方法名称。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// functional/MethodReferences.javaimport java.util.*;interface Callable &#123; // [1] void call(String s);&#125;class Describe &#123; void show(String msg) &#123; // [2] System.out.println(msg); &#125;&#125;public class MethodReferences &#123; static void hello(String name) &#123; // [3] System.out.println(&quot;Hello, &quot; + name); &#125; static class Description &#123; String about; Description(String desc) &#123; about = desc; &#125; void help(String msg) &#123; // [4] System.out.println(about + &quot; &quot; + msg); &#125; &#125; static class Helper &#123; static void assist(String msg) &#123; // [5] System.out.println(msg); &#125; &#125; public static void main(String[] args) &#123; Describe d = new Describe(); Callable c = d::show; // [6] c.call(&quot;call()&quot;); // [7] c = MethodReferences::hello; // [8] c.call(&quot;Bob&quot;); c = new Description(&quot;valuable&quot;)::help; // [9] c.call(&quot;information&quot;); c = Helper::assist; // [10] c.call(&quot;Help!&quot;); &#125;&#125; 输出结果： 1234call()Hello, Bobvaluable informationHelp! [1] 我们从单一方法接口开始（同样，你很快就会了解到这一点的重要性）。 [2] show() 的签名（参数类型和返回类型）符合 Callable 的 call() 的签名。 [3] hello() 也符合 call() 的签名。 [4] help() 也符合，它是静态内部类中的非静态方法。 [5] assist() 是静态内部类中的静态方法。 [6] 我们将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 Callable 的 call() 方法的签名。 [7] 我们现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show()。 [8] 这是一个静态方法引用。 [9] 这是 [6] 的另一个版本：对已实例化对象的方法的引用，有时称为绑定方法引用。 [10] 最后，获取静态内部类中静态方法的引用与 [8] 中通过外部类引用相似。 上例只是简短的介绍，我们很快就能看到方法引用的所有不同形式。 Runnable接口Runnable 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 run() 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 Runnable： 1234567891011121314151617181920212223242526// functional/RunnableMethodReference.java// 方法引用与 Runnable 接口的结合使用class Go &#123; static void go() &#123; System.out.println(&quot;Go::go()&quot;); &#125;&#125;public class RunnableMethodReference &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;Anonymous&quot;); &#125; &#125;).start(); new Thread( () -&gt; System.out.println(&quot;lambda&quot;) ).start(); new Thread(Go::go).start(); &#125;&#125; 输出结果： 123AnonymouslambdaGo::go() Thread 对象将 Runnable 作为其构造函数参数，并具有会调用 run() 的方法 start()。 注意，只有匿名内部类才需要具有名为 run() 的方法。 未绑定的方法引用未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用时，我们必须先提供对象： 12345678910111213141516171819202122232425// functional/UnboundMethodReference.java// 没有方法引用的对象class X &#123; String f() &#123; return &quot;X::f()&quot;; &#125;&#125;interface MakeString &#123; String make();&#125;interface TransformX &#123; String transform(X x);&#125;public class UnboundMethodReference &#123; public static void main(String[] args) &#123; // MakeString ms = X::f; // [1] TransformX sp = X::f; X x = new X(); System.out.println(sp.transform(x)); // [2] System.out.println(x.f()); // 同等效果 &#125;&#125; 输出结果： 12X::f()X::f() 截止目前，我们看到了与对应接口签名相同的方法引用。 在 **[1]**，我们尝试把 X 的 f() 方法引用赋值给 MakeString。结果即使 make() 与 f() 具有相同的签名，编译也会报“invalid method reference”（无效方法引用）错误。 这是因为实际上还有另一个隐藏的参数：我们的老朋友 this。 你不能在没有 X 对象的前提下调用 f()。 因此，X :: f 表示未绑定的方法引用，因为它尚未“绑定”到对象。 要解决这个问题，我们需要一个 X 对象，所以我们的接口实际上需要一个额外的参数，如上例中的 TransformX。 如果将 X :: f 赋值给 TransformX，在 Java 中是允许的。我们必须做第二个心理调整——使用未绑定的引用时，函数式方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。 原因是：你需要一个对象来调用方法。 [2] 的结果有点像脑筋急转弯。我拿到未绑定的方法引用，并且调用它的transform()方法，将一个X类的对象传递给它，最后使得 x.f() 以某种方式被调用。Java知道它必须拿到第一个参数，该参数实际就是this，然后调用方法作用在它之上。 如果你的方法有更多个参数，就以第一个参数接受this的模式来处理。 12345678910111213141516171819202122232425262728293031323334// functional/MultiUnbound.java// 未绑定的方法与多参数的结合运用class This &#123; void two(int i, double d) &#123;&#125; void three(int i, double d, String s) &#123;&#125; void four(int i, double d, String s, char c) &#123;&#125;&#125;interface TwoArgs &#123; void call2(This athis, int i, double d);&#125;interface ThreeArgs &#123; void call3(This athis, int i, double d, String s);&#125;interface FourArgs &#123; void call4( This athis, int i, double d, String s, char c);&#125;public class MultiUnbound &#123; public static void main(String[] args) &#123; TwoArgs twoargs = This::two; ThreeArgs threeargs = This::three; FourArgs fourargs = This::four; This athis = new This(); twoargs.call2(athis, 11, 3.14); threeargs.call3(athis, 11, 3.14, &quot;Three&quot;); fourargs.call4(athis, 11, 3.14, &quot;Four&quot;, &#x27;Z&#x27;); &#125;&#125; 需要指出的是，我将类命名为 This，并将函数式方法的第一个参数命名为 athis，但你在生产级代码中应该使用其他名字，以防止混淆。 构造函数引用你还可以捕获构造函数的引用，然后通过引用调用该构造函数。 123456789101112131415161718192021222324252627282930313233// functional/CtorReference.javaclass Dog &#123; String name; int age = -1; // For &quot;unknown&quot; Dog() &#123; name = &quot;stray&quot;; &#125; Dog(String nm) &#123; name = nm; &#125; Dog(String nm, int yrs) &#123; name = nm; age = yrs; &#125;&#125;interface MakeNoArgs &#123; Dog make();&#125;interface Make1Arg &#123; Dog make(String nm);&#125;interface Make2Args &#123; Dog make(String nm, int age);&#125;public class CtorReference &#123; public static void main(String[] args) &#123; MakeNoArgs mna = Dog::new; // [1] Make1Arg m1a = Dog::new; // [2] Make2Args m2a = Dog::new; // [3] Dog dn = mna.make(); Dog d1 = m1a.make(&quot;Comet&quot;); Dog d2 = m2a.make(&quot;Ralph&quot;, 4); &#125;&#125; Dog 有三个构造函数，函数式接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。 注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这三个构造函数只有一个相同名称：:: new，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。 编译器知道调用函数式方法（本例中为 make()）就相当于调用构造函数。 函数式接口方法引用和 Lambda 表达式都必须被赋值，同时赋值需要类型信息才能使编译器保证类型的正确性。尤其是Lambda 表达式，它引入了新的要求。 代码示例： 1x -&gt; x.toString() 我们清楚这里返回类型必须是 String，但 x 是什么类型呢？ Lambda 表达式包含类型推导（编译器会自动推导出类型信息，避免了程序员显式地声明）。编译器必须能够以某种方式推导出 x 的类型。 下面是第二个代码示例： 1(x, y) -&gt; x + y 现在 x 和 y 可以是任何支持 + 运算符连接的数据类型，可以是两个不同的数值类型或者是 一个 String 加任意一种可自动转换为 String 的数据类型（这包括了大多数类型）。 但是，当 Lambda 表达式被赋值时，编译器必须确定 x 和 y 的确切类型以生成正确的代码。 该问题也适用于方法引用。 假设你要传递 System.out :: println 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？ 为了解决这个问题，Java 8 引入了 java.util.function 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。 在编写接口时，可以使用 @FunctionalInterface 注解强制执行此“函数式方法”模式： 12345678910111213141516171819202122232425262728293031323334353637// functional/FunctionalAnnotation.java@FunctionalInterfaceinterface Functional &#123; String goodbye(String arg);&#125;interface FunctionalNoAnn &#123; String goodbye(String arg);&#125;/*@FunctionalInterfaceinterface NotFunctional &#123; String goodbye(String arg); String hello(String arg);&#125;产生错误信息:NotFunctional is not a functional interfacemultiple non-overriding abstract methodsfound in interface NotFunctional*/public class FunctionalAnnotation &#123; public String goodbye(String arg) &#123; return &quot;Goodbye, &quot; + arg; &#125; public static void main(String[] args) &#123; FunctionalAnnotation fa = new FunctionalAnnotation(); Functional f = fa::goodbye; FunctionalNoAnn fna = fa::goodbye; // Functional fac = fa; // Incompatible Functional fl = a -&gt; &quot;Goodbye, &quot; + a; FunctionalNoAnn fnal = a -&gt; &quot;Goodbye, &quot; + a; &#125;&#125; @FunctionalInterface 注解是可选的; Java 在 main() 中把 Functional 和 FunctionalNoAnn 都当作函数式接口。 在 NotFunctional 的定义中可看到@FunctionalInterface 的作用：接口中如果有多个方法则会产生编译期错误。 仔细观察在定义 f 和 fna 时发生了什么。 Functional 和 FunctionalNoAnn 定义接口，然而被赋值的只是方法 goodbye()。首先，这只是一个方法而不是类；其次，它甚至都不是实现了该接口的类中的方法。这是添加到Java 8中的一点小魔法：如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会在后台把方法引用或 Lambda 表达式包装进实现目标接口的类的实例中。 尽管 FunctionalAnnotation 确实适合 Functional 模型，但 Java不允许我们像fac定义中的那样，将 FunctionalAnnotation 直接赋值给 Functional，因为 FunctionalAnnotation 并没有显式地去实现 Functional 接口。唯一的惊喜是，Java 8 允许我们将函数赋值给接口，这样的语法更加简单漂亮。 java.util.function 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。主要因为基本类型的存在，导致预定义的接口数量有少许增加。 如果你了解命名模式，顾名思义就能知道特定接口的作用。 以下是基本命名准则： 如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等。参数类型通过泛型添加。 如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但返回基本类型的 Supplier 接口例外。 如果返回值为基本类型，则用 To 表示，如 ToLongFunction &lt;T&gt; 和 IntToLongFunction。 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。 如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。 如果接收的两个参数类型不同，则名称中有一个 Bi。 下表描述了 java.util.function 中的目标类型（包括例外情况）： 特征 函数式方法名 示例 无参数； 无返回值 Runnable (java.lang) run() Runnable 无参数； 返回类型任意 Supplier get() getAs类型() Supplier&lt;T&gt; BooleanSupplier IntSupplier LongSupplier DoubleSupplier 无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable&lt;V&gt; 1 参数； 无返回值 Consumer accept() Consumer&lt;T&gt; IntConsumer LongConsumer DoubleConsumer 2 参数 Consumer BiConsumer accept() BiConsumer&lt;T,U&gt; 2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer&lt;T&gt; ObjLongConsumer&lt;T&gt; ObjDoubleConsumer&lt;T&gt; 1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() Function&lt;T,R&gt; IntFunction&lt;R&gt; LongFunction&lt;R&gt; DoubleFunction&lt;R&gt; ToIntFunction&lt;T&gt; ToLongFunction&lt;T&gt; ToDoubleFunction&lt;T&gt; IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator&lt;T&gt; IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator&lt;T&gt; IntBinaryOperator LongBinaryOperator DoubleBinaryOperator 2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator&lt;T&gt; 2 参数； 返回布尔型 Predicate test() Predicate&lt;T&gt; BiPredicate&lt;T,U&gt; IntPredicate LongPredicate DoublePredicate 参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 2 参数类型不同 Bi操作 (不同方法名) BiFunction&lt;T,U,R&gt; BiConsumer&lt;T,U&gt; BiPredicate&lt;T,U&gt; ToIntBiFunction&lt;T,U&gt; ToLongBiFunction&lt;T,U&gt; ToDoubleBiFunction&lt;T&gt; 此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出你所需要的函数式接口。 可以看出，在创建 java.util.function 时，设计者们做出了一些选择。 例如，为什么没有 IntComparator，LongComparator 和 DoubleComparator 呢？有 BooleanSupplier 却没有其他表示 Boolean 的接口；有通用的 BiConsumer 却没有用于 int，long 和 double 的 BiConsumers 变体（我理解他们为什么放弃这些接口）。这到底是疏忽还是有人认为其他组合使用得很少呢（他们是如何得出这个结论的）？ 你还可以看到基本类型给 Java 添加了多少复杂性。基于效率方面的考虑（问题之后有所缓解），该语言的第一版中就包含了基本类型。现在，在语言的生命周期中，我们仍然会受到语言设计选择不佳的影响。 下面枚举了基于 Lambda 表达式的所有不同 Function 变体的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// functional/FunctionVariants.javaimport java.util.function.*;class Foo &#123;&#125;class Bar &#123; Foo f; Bar(Foo f) &#123; this.f = f; &#125;&#125;class IBaz &#123; int i; IBaz(int i) &#123; this.i = i; &#125;&#125;class LBaz &#123; long l; LBaz(long l) &#123; this.l = l; &#125;&#125;class DBaz &#123; double d; DBaz(double d) &#123; this.d = d; &#125;&#125;public class FunctionVariants &#123; static Function&lt;Foo,Bar&gt; f1 = f -&gt; new Bar(f); static IntFunction&lt;IBaz&gt; f2 = i -&gt; new IBaz(i); static LongFunction&lt;LBaz&gt; f3 = l -&gt; new LBaz(l); static DoubleFunction&lt;DBaz&gt; f4 = d -&gt; new DBaz(d); static ToIntFunction&lt;IBaz&gt; f5 = ib -&gt; ib.i; static ToLongFunction&lt;LBaz&gt; f6 = lb -&gt; lb.l; static ToDoubleFunction&lt;DBaz&gt; f7 = db -&gt; db.d; static IntToLongFunction f8 = i -&gt; i; static IntToDoubleFunction f9 = i -&gt; i; static LongToIntFunction f10 = l -&gt; (int)l; static LongToDoubleFunction f11 = l -&gt; l; static DoubleToIntFunction f12 = d -&gt; (int)d; static DoubleToLongFunction f13 = d -&gt; (long)d; public static void main(String[] args) &#123; Bar b = f1.apply(new Foo()); IBaz ib = f2.apply(11); LBaz lb = f3.apply(11); DBaz db = f4.apply(11); int i = f5.applyAsInt(ib); long l = f6.applyAsLong(lb); double d = f7.applyAsDouble(db); l = f8.applyAsLong(12); d = f9.applyAsDouble(12); i = f10.applyAsInt(12); d = f11.applyAsDouble(12); i = f12.applyAsInt(13.0); l = f13.applyAsLong(13.0); &#125;&#125; 这些 Lambda 表达式尝试生成适合函数签名的最简代码。 在某些情况下，有必要进行强制类型转换，否则编译器会报截断错误。 主方法中的每个测试都显示了 Function 接口中不同类型的 apply() 方法。 每个都产生一个与其关联的 Lambda 表达式的调用。 方法引用有自己的小魔法： 12345678910111213141516171819202122232425/ functional/MethodConversion.javaimport java.util.function.*;class In1 &#123;&#125;class In2 &#123;&#125;public class MethodConversion &#123; static void accept(In1 i1, In2 i2) &#123; System.out.println(&quot;accept()&quot;); &#125; static void someOtherName(In1 i1, In2 i2) &#123; System.out.println(&quot;someOtherName()&quot;); &#125; public static void main(String[] args) &#123; BiConsumer&lt;In1,In2&gt; bic; bic = MethodConversion::accept; bic.accept(new In1(), new In2()); bic = MethodConversion::someOtherName; // bic.someOtherName(new In1(), new In2()); // Nope bic.accept(new In1(), new In2()); &#125;&#125; 输出结果： 12accept()someOtherName() 查看 BiConsumer 的文档，你会看到 accept() 方法。 实际上，如果我们将方法命名为 accept()，它就可以作为方法引用。 但是我们也可用不同的名称，比如 someOtherName()。只要参数类型、返回类型与 BiConsumer 的 accept() 相同即可。 因此，在使用函数接口时，名称无关紧要——只要参数类型和返回类型相同。 Java 会将你的方法映射到接口方法。 要调用方法，可以调用接口的函数式方法名（在本例中为 accept()），而不是你的方法名。 现在我们来看看，将方法引用应用于基于类的函数式接口（即那些不包含基本类型的函数式接口）。下面的例子中，我创建了适合函数式方法签名的最简单的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243// functional/ClassFunctionals.javaimport java.util.*;import java.util.function.*;class AA &#123;&#125;class BB &#123;&#125;class CC &#123;&#125;public class ClassFunctionals &#123; static AA f1() &#123; return new AA(); &#125; static int f2(AA aa1, AA aa2) &#123; return 1; &#125; static void f3(AA aa) &#123;&#125; static void f4(AA aa, BB bb) &#123;&#125; static CC f5(AA aa) &#123; return new CC(); &#125; static CC f6(AA aa, BB bb) &#123; return new CC(); &#125; static boolean f7(AA aa) &#123; return true; &#125; static boolean f8(AA aa, BB bb) &#123; return true; &#125; static AA f9(AA aa) &#123; return new AA(); &#125; static AA f10(AA aa1, AA aa2) &#123; return new AA(); &#125; public static void main(String[] args) &#123; Supplier&lt;AA&gt; s = ClassFunctionals::f1; s.get(); Comparator&lt;AA&gt; c = ClassFunctionals::f2; c.compare(new AA(), new AA()); Consumer&lt;AA&gt; cons = ClassFunctionals::f3; cons.accept(new AA()); BiConsumer&lt;AA,BB&gt; bicons = ClassFunctionals::f4; bicons.accept(new AA(), new BB()); Function&lt;AA,CC&gt; f = ClassFunctionals::f5; CC cc = f.apply(new AA()); BiFunction&lt;AA,BB,CC&gt; bif = ClassFunctionals::f6; cc = bif.apply(new AA(), new BB()); Predicate&lt;AA&gt; p = ClassFunctionals::f7; boolean result = p.test(new AA()); BiPredicate&lt;AA,BB&gt; bip = ClassFunctionals::f8; result = bip.test(new AA(), new BB()); UnaryOperator&lt;AA&gt; uo = ClassFunctionals::f9; AA aa = uo.apply(new AA()); BinaryOperator&lt;AA&gt; bo = ClassFunctionals::f10; aa = bo.apply(new AA(), new AA()); &#125;&#125; 请注意，每个方法名称都是随意的（如 f1()，f2()等）。正如你刚才看到的，一旦将方法引用赋值给函数接口，我们就可以调用与该接口关联的函数方法。 在此示例中为 get()、compare()、accept()、apply() 和 test()。 多参数函数式接口java.util.functional 中的接口是有限的。比如有 BiFunction，但也仅此而已。 如果需要三参数函数的接口怎么办？ 其实这些接口非常简单，很容易查看 Java 库源代码并自行创建。代码示例： 123456// functional/TriFunction.java@FunctionalInterfacepublic interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v);&#125; 简单测试，验证它是否有效： 12345678910// functional/TriFunctionTest.javapublic class TriFunctionTest &#123; static int f(int i, long l, double d) &#123; return 99; &#125; public static void main(String[] args) &#123; TriFunction&lt;Integer, Long, Double, Integer&gt; tf = TriFunctionTest::f; tf = (i, l, d) -&gt; 12; &#125;&#125; 这里我们同时测试了方法引用和 Lambda 表达式。 缺少基本类型的函数让我们重温一下 BiConsumer，看看我们如何创建缺少的针对 int，long 和 double 的各种排列： 1234567891011121314151617// functional/BiConsumerPermutations.javaimport java.util.function.*;public class BiConsumerPermutations &#123; static BiConsumer&lt;Integer, Double&gt; bicid = (i, d) -&gt; System.out.format(&quot;%d, %f%n&quot;, i, d); static BiConsumer&lt;Double, Integer&gt; bicdi = (d, i) -&gt; System.out.format(&quot;%d, %f%n&quot;, i, d); static BiConsumer&lt;Integer, Long&gt; bicil = (i, l) -&gt; System.out.format(&quot;%d, %d%n&quot;, i, l); public static void main(String[] args) &#123; bicid.accept(47, 11.34); bicdi.accept(22.45, 92); bicil.accept(1, 11L); &#125;&#125; 输出结果： 12347, 11.34000092, 22.4500001, 11 这里使用 System.out.format() 来显示。它类似于 System.out.println() 但提供了更多的显示选项。 这里，%f 表示我将 n 作为浮点值给出，%d 表示 n 是一个整数值。 这其中可以包含空格，输入 %n 会换行 — 当然使用传统的 \\n 也能换行，但 %n 是自动跨平台的，这是使用 format() 的另一个原因。 上例简单使用了包装类型，装箱和拆箱负责它与基本类型之间的来回转换。 又比如，我们可以将包装类型和Function一起使用，而不去用各种针对基本类型的预定义接口。代码示例： 12345678910// functional/FunctionWithWrapped.javaimport java.util.function.*;public class FunctionWithWrapped &#123; public static void main(String[] args) &#123; Function&lt;Integer, Double&gt; fid = i -&gt; (double)i; IntToDoubleFunction fid2 = i -&gt; i; &#125;&#125; 如果没有强制转换，则会收到错误消息：“Integer cannot be converted to Double”（Integer 无法转换为 Double），而使用 IntToDoubleFunction 就没有此类问题。 IntToDoubleFunction 接口的源代码是这样的： 1234@FunctionalInterface public interface IntToDoubleFunction &#123; double applyAsDouble(int value); &#125; 因为我们可以简单地写 Function &lt;Integer，Double&gt; 并产生正常的结果，所以用基本类型的唯一原因是可以避免传递参数和返回结果过程中的自动装箱和自动拆箱，进而提升性能。 似乎是考虑到使用频率，某些函数类型并没有预定义。 当然，如果因为缺少针对基本类型的函数式接口造成了性能问题，你可以轻松编写自己的接口（ 参考 Java 源代码）——尽管这里出现性能瓶颈的可能性不大。 高阶函数这个名字可能听起来令人生畏，但是：高阶函数（Higher-order Function）只是一个消费或产生函数的函数。 我们先来看看如何产生一个函数： 12345678910111213141516// functional/ProduceFunction.javaimport java.util.function.*;interfaceFuncSS extends Function&lt;String, String&gt; &#123;&#125; // [1]public class ProduceFunction &#123; static FuncSS produce() &#123; return s -&gt; s.toLowerCase(); // [2] &#125; public static void main(String[] args) &#123; FuncSS f = produce(); System.out.println(f.apply(&quot;YELLING&quot;)); &#125;&#125; 输出结果： 1yelling 这里，produce() 是高阶函数。 [1] 使用继承，可以轻松地为专用接口创建别名。 [2] 使用 Lambda 表达式，可以轻松地在方法中创建和返回一个函数。 要消费一个函数，消费函数需要在参数列表正确地描述函数类型。代码示例： 123456789101112131415// functional/ConsumeFunction.javaimport java.util.function.*;class One &#123;&#125;class Two &#123;&#125;public class ConsumeFunction &#123; static Two consume(Function&lt;One,Two&gt; onetwo) &#123; return onetwo.apply(new One()); &#125; public static void main(String[] args) &#123; Two two = consume(one -&gt; new Two()); &#125;&#125; 当基于消费函数生成新函数时，事情就变得相当有趣了。代码示例如下： 1234567891011121314151617181920212223242526272829// functional/TransformFunction.javaimport java.util.function.*;class I &#123; @Override public String toString() &#123; return &quot;I&quot;; &#125;&#125;class O &#123; @Override public String toString() &#123; return &quot;O&quot;; &#125;&#125;public class TransformFunction &#123; static Function&lt;I,O&gt; transform(Function&lt;I,O&gt; in) &#123; return in.andThen(o -&gt; &#123; System.out.println(o); return o; &#125;); &#125; public static void main(String[] args) &#123; Function&lt;I,O&gt; f2 = transform(i -&gt; &#123; System.out.println(i); return new O(); &#125;); O o = f2.apply(new I()); &#125;&#125; 输出结果： 12IO 在这里，transform() 生成一个与传入的函数具有相同签名的函数，但是你可以生成任何你想要的类型。 这里使用到了 Function 接口中名为 andThen() 的默认方法，该方法专门用于操作函数。 顾名思义，在调用 in 函数之后调用 andThen()（还有个 compose() 方法，它在 in 函数之前应用新函数）。 要附加一个 andThen() 函数，我们只需将该函数作为参数传递。 transform() 产生的是一个新函数，它将 in 的动作与 andThen() 参数的动作结合起来。 闭包在上一节的 ProduceFunction.java 中，我们从方法中返回 Lambda 函数。 虽然过程简单，但是有些问题必须再回过头来探讨一下。 闭包（Closure）一词总结了这些问题。 它非常重要，利用闭包可以轻松生成函数。 考虑一个更复杂的 Lambda，它使用函数作用域之外的变量。 返回该函数会发生什么？ 也就是说，当你调用函数时，它对那些 “外部 ”变量引用了什么? 如果语言不能自动解决，那问题将变得非常棘手。 能够解决这个问题的语言被称为支持闭包，或者叫作在词法上限定范围( 也使用术语变量捕获 )。Java 8 提供了有限但合理的闭包支持，我们将用一些简单的例子来研究它。 首先，下列方法返回一个函数，该函数访问对象字段和方法参数： 12345678910// functional/Closure1.javaimport java.util.function.*;public class Closure1 &#123; int i; IntSupplier makeFun(int x) &#123; return () -&gt; x + i++; &#125;&#125; 但是，仔细考虑一下，i 的这种用法并非是个大难题，因为对象很可能在你调用 makeFun() 之后就存在了——实际上，垃圾收集器几乎肯定会保留以这种方式被绑定到现存函数的对象。当然，如果你对同一个对象多次调用 makeFun() ，你最终会得到多个函数，它们共享 i 的存储空间： 123456789101112131415// functional/SharedStorage.javaimport java.util.function.*;public class SharedStorage &#123; public static void main(String[] args) &#123; Closure1 c1 = new Closure1(); IntSupplier f1 = c1.makeFun(0); IntSupplier f2 = c1.makeFun(0); IntSupplier f3 = c1.makeFun(0); System.out.println(f1.getAsInt()); System.out.println(f2.getAsInt()); System.out.println(f3.getAsInt()); &#125;&#125; 输出结果： 123012 每次调用 getAsInt() 都会增加 i，表明存储是共享的。 如果 i 是 makeFun() 的局部变量怎么办？ 在正常情况下，当 makeFun() 完成时 i 就消失。 但它仍可以编译： 12345678910// functional/Closure2.javaimport java.util.function.*;public class Closure2 &#123; IntSupplier makeFun(int x) &#123; int i = 0; return () -&gt; x + i; &#125;&#125; 由 makeFun() 返回的 IntSupplier “关住了” i 和 x，因此即使makeFun()已执行完毕，当你调用返回的函数时i 和 x仍然有效，而不是像正常情况下那样在 makeFun() 执行后 i 和x就消失了。 但请注意，我没有像 Closure1.java 那样递增 i，因为会产生编译时错误。代码示例： 123456789101112// functional/Closure3.java// &#123;WillNotCompile&#125;import java.util.function.*;public class Closure3 &#123; IntSupplier makeFun(int x) &#123; int i = 0; // x++ 和 i++ 都会报错： return () -&gt; x++ + i++; &#125;&#125; x 和 i 的操作都犯了同样的错误：被 Lambda 表达式引用的局部变量必须是 final 或者是等同 final 效果的。 如果使用 final 修饰 x和 i，就不能再递增它们的值了。代码示例： 12345678910// functional/Closure4.javaimport java.util.function.*;public class Closure4 &#123; IntSupplier makeFun(final int x) &#123; final int i = 0; return () -&gt; x + i; &#125;&#125; 那么为什么在 Closure2.java 中， x 和 i 非 final 却可以运行呢？ 这就叫做等同 final 效果（Effectively Final）。这个术语是在 Java 8 才开始出现的，表示虽然没有明确地声明变量是 final 的，但是因变量值没被改变过而实际有了 final 同等的效果。 如果局部变量的初始值永远不会改变，那么它实际上就是 final 的。 如果 x 和 i 的值在方法中的其他位置发生改变（但不在返回的函数内部），则编译器仍将视其为错误。每个递增操作则会分别产生错误消息。代码示例： 12345678910111213// functional/Closure5.java// &#123;无法编译成功&#125;import java.util.function.*;public class Closure5 &#123; IntSupplier makeFun(int x) &#123; int i = 0; i++; x++; return () -&gt; x + i; &#125;&#125; 等同 final 效果意味着可以在变量声明前加上 final 关键字而不用更改任何其余代码。 实际上它就是具备 final 效果的，只是没有明确说明。 通过在闭包中使用 final 关键字提前修饰变量 x 和 i ， 我们解决了 Closure5.java 中的问题。代码示例： 1234567891011121314// functional/Closure6.javaimport java.util.function.*;public class Closure6 &#123; IntSupplier makeFun(int x) &#123; int i = 0; i++; x++; final int iFinal = i; final int xFinal = x; return () -&gt; xFinal + iFinal; &#125;&#125; 上例中 iFinal 和 xFinal 的值在赋值后并没有改变过，因此在这里使用 final 是多余的。 如果函数式方法中使用的外部局部变量是引用，而不是基本类型的话，会是什么情况呢？我们可以把int类型改为Integer类型研究一下： 123456789101112// functional/Closure7.java// &#123;无法编译成功&#125;import java.util.function.*;public class Closure7 &#123; IntSupplier makeFun(int x) &#123; Integer i = 0; i = i + 1; return () -&gt; x + i; &#125;&#125; 编译器非常聪明地识别到变量 i 的值被更改过。 因为包装类型可能被特殊处理过了，所以我们尝试下 List： 123456789101112131415161718192021222324// functional/Closure8.javaimport java.util.*;import java.util.function.*;public class Closure8 &#123; Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123; final List&lt;Integer&gt; ai = new ArrayList&lt;&gt;(); ai.add(1); return () -&gt; ai; &#125; public static void main(String[] args) &#123; Closure8 c7 = new Closure8(); List&lt;Integer&gt; l1 = c7.makeFun().get(), l2 = c7.makeFun().get(); System.out.println(l1); System.out.println(l2); l1.add(42); l2.add(96); System.out.println(l1); System.out.println(l2); &#125;&#125; 输出结果： 1234[1][1][1, 42][1, 96] 可以看到，这次一切正常。我们改变了 List 的内容却没产生编译时错误。通过观察本例的输出结果，我们发现这看起来非常安全。这是因为每次调用 makeFun() 时，其实都会创建并返回一个全新而非共享的 ArrayList。也就是说，每个闭包都有自己独立的 ArrayList，它们之间互不干扰。 请注意我已经声明 ai 是 final 的了。尽管在这个例子中你可以去掉 final 并得到相同的结果（试试吧！）。 应用于对象引用的 final 关键字仅表示不会重新赋值引用。 它并不代表你不能修改对象本身。 下面我们来看看 Closure7.java 和 Closure8.java 之间的区别。我们看到：在 Closure7.java 中变量 i 有过重新赋值。 也许这就是触发等同 final 效果错误消息的原因。 12345678910111213// functional/Closure9.java// &#123;无法编译成功&#125;import java.util.*;import java.util.function.*;public class Closure9 &#123; Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123; List&lt;Integer&gt; ai = new ArrayList&lt;&gt;(); ai = new ArrayList&lt;&gt;(); // Reassignment return () -&gt; ai; &#125;&#125; 上例，重新赋值引用会触发错误消息。如果只修改指向的对象则没问题，只要没有其他人获得对该对象的引用（这意味着你有多个实体可以修改对象，此时事情会变得非常混乱），基本上就是安全的[^6]。 让我们回顾一下 Closure1.java。那么现在问题来了：为什么变量 i 被修改编译器却没有报错呢。 它既不是 final 的，也不是等同 final 效果的。因为 i 是外围类的成员，所以这样做肯定是安全的（除非你正在创建共享可变内存的多个函数）。是的，你可以辩称在这种情况下不会发生变量捕获（Variable Capture）。但可以肯定的是，Closure3.java 的错误消息是专门针对局部变量的。因此，规则并非只是“在 Lambda 之外定义的任何变量必须是 final 的或等同 final 效果那么简单。相反，你必须考虑捕获的变量是否是等同 final 效果的。 如果它是对象中的字段，那么它拥有独立的生存周期，并且不需要任何特殊的捕获，以便稍后在调用 Lambda 时存在。 作为闭包的内部类我们可以使用匿名内部类重写之前的例子: 123456789101112131415// functional/AnonymousClosure.javaimport java.util.function.*;public class AnonymousClosure &#123; IntSupplier makeFun(int x) &#123; int i = 0; // 同样规则的应用: // i++; // 非等同 final 效果 // x++; // 同上 return new IntSupplier() &#123; public int getAsInt() &#123; return x + i; &#125; &#125;; &#125;&#125; 实际上只要有内部类，就会有闭包（Java 8 只是简化了闭包操作）。在 Java 8 之前，变量 x 和 i 必须被明确声明为 final。在 Java 8 中，内部类的规则放宽，包括等同 final 效果。 函数组合函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。在前面的 TransformFunction.java 类中，有一个使用 andThen() 的函数组合示例。一些 java.util.function 接口中包含支持函数组合的方法 [^7]。 组合方法 支持接口 andThen(argument) 根据参数执行原始操作 Function BiFunction Consumer BiConsumer IntConsumer LongConsumer DoubleConsumer UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator BinaryOperator compose(argument) 根据参数执行原始操作 Function UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator and(argument) 短路逻辑与原始谓词和参数谓词 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate or(argument) 短路逻辑或原始谓词和参数谓词 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate negate() 该谓词的逻辑否谓词 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate 下例使用了 Function 里的 compose()和 andThen()。代码示例： 123456789101112131415161718// functional/FunctionComposition.javaimport java.util.function.*;public class FunctionComposition &#123; static Function&lt;String, String&gt; f1 = s -&gt; &#123; System.out.println(s); return s.replace(&#x27;A&#x27;, &#x27;_&#x27;); &#125;, f2 = s -&gt; s.substring(3), f3 = s -&gt; s.toLowerCase(), f4 = f1.compose(f2).andThen(f3); public static void main(String[] args) &#123; System.out.println( f4.apply(&quot;GO AFTER ALL AMBULANCES&quot;)); &#125;&#125; 输出结果： 12AFTER ALL AMBULANCES_fter _ll _mbul_nces 这里我们重点看正在创建的新函数 f4。它调用 apply() 的方式与常规几乎无异。 当 f1 获得字符串时，它已经被f2 剥离了前三个字符。这是因为 compose（f2） 表示 f2 的调用发生在 f1 之前。 下例是 Predicate 的逻辑运算演示.代码示例： 1234567891011121314151617// functional/PredicateComposition.javaimport java.util.function.*;import java.util.stream.*;public class PredicateComposition &#123; static Predicate&lt;String&gt; p1 = s -&gt; s.contains(&quot;bar&quot;), p2 = s -&gt; s.length() &lt; 5, p3 = s -&gt; s.contains(&quot;foo&quot;), p4 = p1.negate().and(p2).or(p3); public static void main(String[] args) &#123; Stream.of(&quot;bar&quot;, &quot;foobar&quot;, &quot;foobaz&quot;, &quot;fongopuckey&quot;) .filter(p4) .forEach(System.out::println); &#125;&#125; 输出结果： 12foobarfoobaz p4 获取到了所有谓词并组合成一个更复杂的谓词。解读：如果字符串中不包含 bar 且长度小于 5，或者它包含 foo ，则结果为 true。 正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了下一章的内容。首先，我创建了一个字符串对象的流，然后将每个对象传递给 filter() 操作。 filter() 使用 p4 的谓词来确定对象的去留。最后我们使用 forEach() 将 println 方法引用应用在每个留存的对象上。 从输出结果我们可以看到 p4 的工作流程：任何带有 &quot;foo&quot; 的字符串都得以保留，即使它的长度大于 5。 &quot;fongopuckey&quot; 因长度超出且不包含 foo 而被丢弃。 柯里化和部分求值柯里化（Currying）的名称来自于其发明者之一 Haskell Curry。他可能是计算机领域唯一姓氏和名字都命名过重要概念的人（另外就是 Haskell 编程语言）。 柯里化意为：将一个多参数的函数，转换为一系列单参数函数。 123456789101112131415161718192021222324252627// functional/CurryingAndPartials.javaimport java.util.function.*;public class CurryingAndPartials &#123; // 未柯里化: static String uncurried(String a, String b) &#123; return a + b; &#125; public static void main(String[] args) &#123; // 柯里化的函数: Function&lt;String, Function&lt;String, String&gt;&gt; sum = a -&gt; b -&gt; a + b; // [1] System.out.println(uncurried(&quot;Hi &quot;, &quot;Ho&quot;)); Function&lt;String, String&gt; hi = sum.apply(&quot;Hi &quot;); // [2] System.out.println(hi.apply(&quot;Ho&quot;)); // 部分应用: Function&lt;String, String&gt; sumHi = sum.apply(&quot;Hup &quot;); System.out.println(sumHi.apply(&quot;Ho&quot;)); System.out.println(sumHi.apply(&quot;Hey&quot;)); &#125;&#125; 输出结果： 1234Hi HoHi HoHup HoHup Hey [1] 这一连串的箭头很巧妙。注意，在函数接口声明中，第二个参数是另一个函数。 [2] 柯里化的目的是能够通过提供一个参数来创建一个新函数，所以现在有了一个“带参函数”和剩下的 “自由函数”（free argumnet） 。实际上，你从一个双参数函数开始，最后得到一个单参数函数。 我们可以通过添加级别来柯里化一个三参数函数： 123456789101112131415161718// functional/Curry3Args.javaimport java.util.function.*;public class Curry3Args &#123; public static void main(String[] args) &#123; Function&lt;String, Function&lt;String, Function&lt;String, String&gt;&gt;&gt; sum = a -&gt; b -&gt; c -&gt; a + b + c; Function&lt;String, Function&lt;String, String&gt;&gt; hi = sum.apply(&quot;Hi &quot;); Function&lt;String, String&gt; ho = hi.apply(&quot;Ho &quot;); System.out.println(ho.apply(&quot;Hup&quot;)); &#125;&#125; 输出结果： 1Hi Ho Hup 对于每个级别的箭头级联（Arrow-cascading），你都要在类型声明中包裹另一层 Function。 处理基本类型和装箱时，请使用适当的函数式接口： 123456789101112// functional/CurriedIntAdd.javaimport java.util.function.*;public class CurriedIntAdd &#123; public static void main(String[] args) &#123; IntFunction&lt;IntUnaryOperator&gt; curriedIntAdd = a -&gt; b -&gt; a + b; IntUnaryOperator add4 = curriedIntAdd.apply(4); System.out.println(add4.applyAsInt(5)); &#125;&#125; 输出结果： 19 可以在互联网上找到更多的柯里化示例。通常它们是用 Java 之外的语言实现的，但如果理解了柯里化的基本概念，你可以很轻松地用 Java 实现它们。 纯函数式编程即使没有函数式支持，像 C 这样的基础语言，也可以按照一定的原则编写纯函数式程序。Java 8 让函数式编程更简单，不过我们要确保一切是 final 的，同时你的所有方法和函数没有副作用。因为 Java 在本质上并非是不可变语言，所以编译器对我们犯的错误将无能为力。 这种情况下，我们可以借助第三方工具，但使用 Scala 或 Clojure 这样的语言可能更简单。因为它们从一开始就是为保持不变性而设计的。你可以采用这些语言来编写你的 Java 项目的一部分。如果必须要用纯函数式编写，则可以用 Scala（需要遵循一些规则） 或 Clojure （遵循的规则更少）。虽然 Java 支持并发编程，但如果这是你项目的核心部分，你应该考虑在项目部分功能中使用 Scala 或 Clojure 之类的语言。 本章小结Lambda 表达式和方法引用并没有将 Java 转换成函数式语言，而是提供了对函数式编程的支持。这对 Java 来说是一个巨大的改进。因为这允许你编写更简洁明了，易于理解的代码。在下一章中，你会看到它们在流式编程中的应用。相信你会像我一样，喜欢上流式编程。 这些特性满足了很多羡慕Clojure、Scala 这类更函数化语言的程序员，并且阻止了Java程序员转向那些更函数化的语言（就算不能阻止，起码提供了更好的选择）。 但是，Lambdas 和方法引用远非完美，我们永远要为 Java 设计者早期的草率决定付出代价。特别是没有泛型 Lambda，所以 Lambda 在 Java 中并非一等公民。虽然我不否认 Java 8 的巨大改进，但这意味着和许多 Java 特性一样，它终究还是会让人感觉沮丧和鸡肋。 当你遇到学习困难时，请记住通过 IDE（NetBeans、IntelliJ Idea 和 Eclipse）获得帮助，因为 IDE 可以智能提示你何时使用 Lambda 表达式或方法引用，甚至有时还能为你优化代码。","categories":[],"tags":[]},{"title":"","slug":"JAVA单元测试","date":"2021-10-18T07:13:48.289Z","updated":"2021-10-18T07:13:22.114Z","comments":true,"path":"2021/10/18/JAVA单元测试/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"","text":"0818单元测试Junit术语人们倾向于将术语 JUnit 5 和 JUnit Jupiter 当作同义词使用。在大部分情况下，这种互换使用没有什么问题。但是，一定要认识到这两个术语是不同的。JUnit Jupiter 是使用 JUnit 5 编写测试内容的 API。JUnit 5 是一个项目名称（和版本），其 3 个主要模块关注不同的方面：JUnit Jupiter、JUnit Platform 和 JUnit Vintage。 当我提及 JUnit Jupiter 时，指的是编写单元测试的 API；提及 JUnit 5 时，指的是整个项目。 JUnit 5 概述以前的 JUnit 版本都是整体式的。除了在 4.4 版中包含 Hamcrest JAR，JUnit 基本来讲就是一个很大的 JAR 文件。测试内容编写者 — 像您我这样的开发人员 — 和工具供应商都使用它的 API，但后者使用很多内部 JUnit API。 大量使用内部 API 给 JUnit 的维护者造成了一些麻烦，并且留给他们推动该技术发展的选择余地不多。来自 JUnit 5 用户指南： “在 JUnit 4 中，只有外部扩展编写者和工具构建者才使用最初作为内部结构而添加的许多功能。这让更改 JUnit 4 变得特别困难，有时甚至根本不可能。” JUnit Lambda（现在称为 JUnit 5）团队决定将 JUnit 重新设计为两个明确且不同的关注区域： 一个是编写测试内容的 API。 一个是发现和运行这些测试的 API。 这些关注区域现在已整合到 JUnit 5 的架构中，并且它们是明确分离的。图 1 演示了新架构（图像来自 Nicolai Parlog）： 图 1. JUnit 5 的架构 如果仔细查看图 1，就会发现 JUnit 5 的架构有多么强大。好了，让我们仔细看看这个架构。右上角的方框表明，对 JUnit 5 而言，JUnit Jupiter API 只是另一个 API！因为 JUnit Jupiter 的组件遵循新的架构，所以它们可应用 JUnit 5，但您可以轻松定义不同的测试框架。只要一个框架实现了 TestEngine 接口，就可以将它插入任何支持 junit-platform-engine 和 junit-platform-launcher API 的工具中！ 我仍然认为 JUnit Jupiter 非常特殊（毕竟我即将用一整篇教程来介绍它），但 JUnit 5 团队完成的工作确实具有开创性。我只是想指出这一点。我们继续看看图 1，直到我们完全达成一致。 使用 JUnit Jupiter 编写测试内容就测试编写者而言，任何符合 JUnit 规范的测试框架（包括 JUnit Jupiter）都包含两个组件： 我们为其编写测试的 API。 理解这个特定 API 的 JUnit TestEngine 实现。 对于本教程，前者是 JUnit Jupiter API，后者是 JUnit Jupiter Test Engine。我将介绍这二者。 JUnit Jupiter API作为开发人员，您将使用 JUnit Jupiter API 创建单元测试来测试您的应用程序代码。使用该 API 的基本特性 — 注解、断言等 — 是本部分教程的主要关注点。 JUnit Jupiter API 的设计让您可通过插入各种生命周期回调来扩展它的功能。您将在第 2 部分中了解如何使用这些回调完成有趣的工作，比如运行参数化测试，将参数传递给测试方法，等等。 JUnit Jupiter Test Engine您将使用 JUnit Jupiter Test Engine 发现和执行 JUnit Jupiter 单元测试。该测试引擎实现了 JUnit Platform 中包含的 TestEngine 接口。可将 TestEngine 看作单元测试与用于启动它们的工具（比如 IDE）之间的桥梁。 使用 JUnit Platform 运行测试在 JUnit 术语中，运行单元测试的过程分为两部分： 发现测试和创建测试计划。 启动测试计划，以 (1) 执行测试和 (2) 向用户报告结果。 用于发现测试的 API用于发现测试和创建测试计划的 API 包含在 JUnit Platform 中，由一个 TestEngine 实现。该测试框架将测试发现功能封装到其 TestEngine 实现中。JUnit Platform 负责使用 IDE 和构建工具（比如 Gradle 和 Maven）发起测试发现流程。 测试发现的目的是创建测试计划，该计划中包含一个测试规范。测试规范包含以下组件： 选择器 ，比如： 要扫描哪个包来寻找测试类 特定的类名称 特定的方法 类路径根文件夹 过滤器 ，比如： 类名称模式（比如 “.*Test”） 标签（将在第 2 部分中讨论） 特定的测试引擎（比如 “junit-jupiter”） 测试计划是根据测试规范所发现的所有测试类、这些类中的测试方法、测试引擎等的分层视图。测试计划准备就绪后，就可以执行了。 用于执行测试的 API用于执行测试的 API 包含在 JUnit Platform 中，由一个或多个 TestEngine 实现。测试框架将测试执行功能封装在它们的 TestEngine 实现中，但 JUnit Platform 负责发起测试执行流程。通过 IDE 和构建工具（比如 Gradle 和 Maven）发起测试执行工作。 一个名为 Launcher 的 JUnit Platform 组件负责执行在测试发现期间创建的测试计划。某个流程 — 假设是您的 IDE — 通过 JUnit Platform（具体来讲是 junit-platform-launcher API）发起测试执行流程。这时，JUnit Platform 将测试计划连同 TestExecutionListener 一起传递给 Launcher。TestExecutionListener 将报告测试执行结果，从而在您的 IDE 中显示该结果。 测试执行流程的目的是向用户准确报告在测试运行时发生了哪些事件。这包括测试成功和失败报告，以及伴随失败而生成的消息，帮助用户理解所发生的事件。 后向兼容性：JUnit Vintage许多组织对 JUnit 3 和 4 进行了大力投资，因此无法承担向 JUnit 5 的大规模转换。了解到这一点后，JUnit 5 团队提供了 junit-vintage-engine 和 junit-jupiter-migration-support 组件来帮助企业进行迁移。 对 JUnit Platform 而言，JUnit Vintage 只是另一个测试框架，包含自己的 TestEngine 和 API（具体来讲是 JUnit 4 API）。 图 2 显示了各种 JUnit 5 包之间的依赖关系。 图 2. JUnit 5 包关系图 opentest4j 的用途支持 JUnit 的测试框架在如何处理测试执行期间抛出的异常方面有所不同。JVM 上的测试没有统一标准，这是 JUnit 团队一直要面对的问题。除了 java.lang.AssertionError，测试框架还必须定义自己的异常分层结构，或者将自身与 JUnit 支持的异常结合起来（或者在某些情况下同时采取两种方法）。 支持 opentest4j：要加入 Open Test Alliance for the JVM，或者提供反馈来帮助该联盟推进工作，请访问 opentest4j Github 存储库并单击 CONTRIBUTING.md 链接。 为了解决一致性问题，JUnit 团队提议建立一个开源项目，该项目目前称为 Open Test Alliance for the JVM（JVM 开放测试联盟）。该联盟在此阶段仅是一个提案，它仅定义了初步的异常分层结构。但是，JUnit 5 使用 opentest4j 异常。（可在图 2 中看到这一点；请注意从 junit-jupiter-api 和 junit-platform-engine 包到 opentest4j 包的依赖线。） 现在您已基本了解各种 JUnit 5 组件如何结合在一起，是时候使用 JUnit Jupiter API 编写一些测试了！ 使用 JUnit Jupiter 编写测试注解从 JUnit 4 开始，注解 (annotation) 就成为测试框架的核心特性，这一趋势在 JUnit 5 中得以延续。我无法介绍 JUnit 5 的所有注解，本节仅简要介绍最常用的注解。 首先，我将比较 JUnit 4 中与 JUnit 5 中的注解。JUnit 5 团队更改了一些注解的名称，让它们更直观，同时保持功能不变。如果您正在使用 JUnit 4，下表将帮助您适应这些更改。 表 1. JUnit 4 与 JUnit 5 中的注解比较 JUnit 5 JUnit 4 说明 @Test @Test 被注解的方法是一个测试方法。与 JUnit 4 相同。 @BeforeAll @BeforeClass 被注解的（静态）方法将在当前类中的所有 @Test 方法前执行一次。 @BeforeEach @Before 被注解的方法将在当前类中的每个 @Test 方法前执行。 @AfterEach @After 被注解的方法将在当前类中的每个 @Test 方法后执行。 @AfterAll @AfterClass 被注解的（静态）方法将在当前类中的所有 @Test 方法后执行一次。 @Disabled @Ignore 被注解的方法不会执行（将被跳过），但会报告为已执行。 使用注解接下来看看一些使用这些注解的示例。尽管一些注解已在 JUnit 5 中重命名，但如果您使用过 JUnit 4，应熟悉它们的功能。清单 1 中的代码来自 JUnit5AppTest.java，可在 HelloJUnit5 示例应用程序中找到。 清单 1. 基本注解1@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing using JUnit 5&quot;)``public class JUnit5AppTest &#123;`` ` ` ``private static final Logger log = LoggerFactory.getLogger(JUnit5AppTest.class);`` ` ` ``private App classUnderTest;`` ` ` ``@BeforeAll`` ``public static void init() &#123;`` ``// Do something before ANY test is run in this class`` ``&#125;`` ` ` ``@AfterAll`` ``public static void done() &#123;`` ``// Do something after ALL tests in this class are run`` ``&#125;`` ` ` ``@BeforeEach`` ``public void setUp() throws Exception &#123;`` ``classUnderTest = new App();`` ``&#125;`` ` ` ``@AfterEach`` ``public void tearDown() throws Exception &#123;`` ``classUnderTest = null;`` ``&#125;`` ` ` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void aTest() &#123;`` ``log.info(&quot;As written, this test will always pass!&quot;);`` ``assertEquals(4, (2 + 2));`` ``&#125;`` ` ` ``@Test`` ``@Disabled`` ``@DisplayName(&quot;A disabled test&quot;)`` ``void testNotRun() &#123;`` ``log.info(&quot;This test will not run (it is disabled, silly).&quot;);`` ``&#125;``.``.``&#125; 看看上面突出显示行中的注解： 第 1 行：@RunWith 连同它的参数 JUnitPlatform.class（一个基于 JUnit 4 且理解 JUnit Platform 的 Runner）让您可以在 Eclipse 内运行 JUnit Jupiter 单元测试。Eclipse 尚未原生支持 JUnit 5。未来，Eclipse 将提供原生的 JUnit 5 支持，那时我们不再需要此注解。 第 2 行：@DisplayName 告诉 JUnit 在报告测试结果时显示 String “Testing using JUnit 5”，而不是测试类的名称。 第 9 行：@BeforeAll 告诉 JUnit 在运行这个类中的所有 @Test 方法之前运行 init() 方法一次。 第 14 行：@AfterAll 告诉 JUnit 在运行这个类中的所有 @Test 方法之后运行 done() 方法一次。 第 19 行：@BeforeEach 告诉 JUnit 在此类中的每个@Test 方法之前运行 setUp() 方法。 第 24 行：@AfterEach 告诉 JUnit 在此类中的每个@Test 方法之后运行 tearDown() 方法。 第 29 行：@Test 告诉 JUnit，aTest() 方法是一个 JUnit Jupiter 测试方法。 第 37 行：@Disabled 告诉 JUnit 不运行此 @Test 方法，因为它已被禁用。 断言断言 (assertion) 是 org.junit.jupiter.api.Assertions 类上的众多静态方法之一。断言用于测试一个条件，该条件必须计算为 true，测试才能继续执行。 如果断言失败，测试会在断言所在的代码行上停止，并生成断言失败报告。如果断言成功，测试会继续执行下一行代码。 表 2 中列出的所有 JUnit Jupiter 断言方法都接受一个可选的 message 参数（作为最后一个参数），以显示断言是否失败，而不是显示标准的缺省消息。 表 2. JUnit Jupiter 中的断言 断言方法 说明 assertEquals(expected, actual) 如果 expected 不等于 actual，则断言失败。 assertFalse(booleanExpression) 如果 booleanExpression 不是 false，则断言失败。 assertNull(actual) 如果 actual 不是 null，则断言失败。 assertNotNull(actual) 如果 actual 是 null，则断言失败。 assertTrue(booleanExpression) 如果 booleanExpression 不是 true，则断言失败。 清单 2 给出了一个使用这些断言的示例，该示例来自 HelloJUnit5 示例应用程序。 清单 2. 示例应用程序中的 JUnit Jupiter 断言1import static org.junit.jupiter.api.Assertions.assertEquals;``import static org.junit.jupiter.api.Assertions.assertFalse;``import static org.junit.jupiter.api.Assertions.assertNotNull;``import static org.junit.jupiter.api.Assertions.assertNull;``import static org.junit.jupiter.api.Assertions.assertTrue;``.``.`` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void dummyTest() &#123;`` ``int expected = 4;`` ``int actual = 2 + 2;`` ``assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;);`` ``//`` ``Object nullValue = null;`` ``assertFalse(nullValue != null);`` ``assertNull(nullValue);`` ``assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;);`` ``assertTrue(nullValue == null);`` ``.`` ``.`` ``&#125; 看看上面突出显示行中的断言： 第 13 行：assertEquals：如果第一个参数值 (4) 不等于第二个参数值 (2+2)，则断言失败。在报告断言失败时使用用户提供的消息（该方法的第 3 个参数）。 第 16 行：assertFalse：表达式 nullValue != null 必须为 false，否则断言失败。 第 17 行：assertNull：nullValue 参数必须为 null，否则断言失败。 第 18 行：assertNotNull：String 文字值 “A String” 不得为 null，否则断言失败并报告消息 “INCONCEIVABLE!”（而不是缺省的 “Assertion failed” 消息）。 第 19 行：assertTrue：如果表达式 nullValue == null 不等于 true，则断言失败。 除了支持这些标准断言，JUnit Jupiter AP 还提供了多个新断言。下面介绍其中的两个。 方法 @assertAll()清单 3 中的 @assertAll() 方法给出了清单 2 中看到的相同断言，但包装在一个新的断言方法中： 清单 3. assertAll()1import static org.junit.jupiter.api.Assertions.assertAll;``.``.``@Test``@DisplayName(&quot;Dummy test&quot;)``void dummyTest() &#123;`` ``int expected = 4;`` ``int actual = 2 + 2;`` ``Object nullValue = null;`` ``.`` ``.`` ``assertAll(`` ``&quot;Assert All of these&quot;,`` ``() -&gt; assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;),`` ``() -&gt; assertFalse(nullValue != null),`` ``() -&gt; assertNull(nullValue),`` ``() -&gt; assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;),`` ``() -&gt; assertTrue(nullValue == null));``&#125; assertAll() 的有趣之处在于，它包含的所有断言都会执行，即使一个或多个断言失败也是如此。与此相反，在清单 2 中的代码中，如果任何断言失败，测试就会在该位置失败，意味着不会执行任何其他断言。 方法 @assertThrows()在某些条件下，接受测试的类应抛出异常。JUnit 4 通过 expected = 方法参数或一个 @Rule 提供此能力。与此相反，JUnit Jupiter 通过 Assertions 类提供此能力，使它与其他断言更加一致。 我们将所预期的异常视为可以进行断言的另一个条件，因此 Assertions 包含处理此条件的方法。清单 4 引入了新的 assertThrows() 断言方法。 清单 4. assertThrows()1import static org.junit.jupiter.api.Assertions.assertThrows;``import static org.junit.jupiter.api.Assertions.assertEquals;``.``.``@Test()``@DisplayName(&quot;Empty argument&quot;)``public void testAdd_ZeroOperands_EmptyArgument() &#123;`` ``long[] numbersToSum = &#123;&#125;;`` ``assertThrows(IllegalArgumentException.class, () -&gt; classUnderTest.add(numbersToSum));``&#125; 请注意第 9 行：如果对 classUnderTest.add() 的调用没有抛出 IllegalArgumentException，则断言失败。 前置条件前置条件 (Assumption) 与断言类似，但前置条件必须为 true，否则测试将中止。与此相反，当断言失败时，则将测试视为已失败。测试方法只应在某些条件 —前置条件下执行时，前置条件很有用。 前置条件是 org.junit.jupiter.api.Assumptions 类的静态方法。要理解前置条件的价值，只需一个简单的示例。 假如您只想在星期五运行一个特定的单元测试（我假设您有自己的理由）： 1@Test``@DisplayName(&quot;This test is only run on Fridays&quot;)``public void testAdd_OnlyOnFriday() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumeTrue(ldt.getDayOfWeek().getValue() == 5);`` ``// Remainder of test (only executed if assumption holds)...``&#125; 在此情况下，如果条件不成立（第 5 行），就不会执行 lambda 表达式的内容。 使用断言还是前置条件二者的区别可能很细微，所以可使用这条经验法则：使用断言检查一个测试方法的结果。使用前置条件确定是否运行测试方法。不会将已中止的测试报告为失败，意味着这种失败不会中断构建工作。 请注意第 5 行：如果该条件不成立，则跳过该测试。在此情况下，该测试不是在星期五 (5) 运行的。这不会影响项目的 “绿色” 部分，而且不会导致构建失败；会跳过 assumeTrue() 后的测试方法中的所有代码。 如果在前置条件成立时仅应执行测试方法的一部分，可以使用 assumingThat() 方法编写上述条件，该方法使用 lambda 语法： 1@Test``@DisplayName(&quot;This test is only run on Fridays (with lambda)&quot;)``public void testAdd_OnlyOnFriday_WithLambda() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumingThat(ldt.getDayOfWeek().getValue() == 5,`` ``() -&gt; &#123;`` ``// Execute this if assumption holds...`` ``&#125;);`` ``// Execute this regardless``&#125; 注意，无论 assumingThat() 中的前置条件成立与否，都会执行 lambda 表达式后的所有代码。 嵌套单元测试，实现清晰的结构在继续介绍下节内容之前，我想介绍在 JUnit 5 中编写单元测试的最后一个特性。 JUnit Jupiter API 允许您创建嵌套的类，以保持测试代码更清晰，这有助于让测试结果更易读。通过在主类中创建嵌套的测试类，可以创建更多的名称空间，这提供了两个主要优势： 每个单元测试可以拥有自己的测试前和测试后生命周期。这让您能使用特殊条件创建要测试的类，从而测试极端情况。 单元测试方法的名称变得更简单。在 JUnit 4 中，所有测试方法都以对等形式存在，不允许重复的方法名（所以您最终会得到类似 testMethodButOnlyUnderThisOrThatCondition_2() 的方法名）。从 JUnit Jupiter 开始，只有嵌套类中的方法必须具有唯一的名称。清单 6 展示了这一优势。 清单 5. 传递一个空或 null 数组引用1@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing JUnit 5&quot;)``public class JUnit5AppTest &#123;``.``. `` ``@Nested`` ``@DisplayName(&quot;When zero operands&quot;)`` ``class JUnit5AppZeroOperandsTest &#123;`` ` ` ``// @Test methods go here...`` ` ` ``&#125;``.``.``&#125; 请注意第 6 行，其中的 JUnit5AppZeroOperandsTest 类可以拥有测试方法。任何测试的结果都会在父类 JUnit5AppTest 中以嵌套的形式显示。 使用 JUnit Platform 运行测试能编写单元测试很不错，但如果不能运行它们，就没有什么意义了。本节展示如何在 Eclipse 中运行 JUnit 测试，首先使用 Maven，然后从命令行使用 Gradle。 下面的视频展示了如何从 GitHub 克隆示例应用程序代码，并在 Eclipse 中运行测试。在该视频中，我还展示了如何从命令行以及 Eclipse 内使用 Maven 和 Gradle 运行单元测试。Eclipse 对 Maven 和 Gradle 都提供了很好的支持。 应用 3 种工具运行单元测试 下面将提供一些简要的说明，但该视频提供了更多细节。观看该视频，了解如何： 从 GitHub 克隆 HelloJUnit5 示例应用程序。 将应用程序导入 Eclipse 中。 从 Eclipse 内的 HelloJUnit5 应用程序运行一个 JUnit 测试。 使用 Maven 从命令行运行 HelloJUnit5 单元测试。 使用 Gradle 从命令行运行 HelloJUnit5 单元测试。 克隆 HelloJUnit5 示例应用程序要理解教程的剩余部分，您需要从 GitHub 克隆示例应用程序。为此，可打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您希望放入代码的目录，然后输入以下命令： 1git clone https://github.com/makotogo/HelloJUnit5 现在您的机器上已拥有该代码，可以在 Eclipse IDE 内运行 JUnit 测试了。接下来介绍如何运行测试。 在 Eclipse IDE 中运行单元测试如果您已跟随该视频进行操作，应该已将代码导入 Eclipse 中。现在，在 Eclipse 中打开 Project Explorer 视图，展开 HelloJUnit5 项目，直至看到 src/test/java 路径下的 JUnit5AppTest 类。 打开 JUnit5AppTest.java 并验证 class 定义前的下面这个注解（以下代码的第 3 行）： 1.``.``@RunWith(JUnitPlatform.class)``public class JUnit5AppTest &#123;``.``.``&#125; 现在右键单击 JUnit5AppTest 并选择 Run As &gt; JUnit Test。单元测试运行时，JUnit 视图将会出现。您现在已准备好完成本教程的练习。 使用 Maven 运行单元测试打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您将 HelloJUnit5 应用程序克隆到的目录，然后输入以下命令： 1mvn test 这会启动 Maven 构建并运行单元测试。您的输出应类似于： 1$ mvn clean test``[INFO] Scanning for projects...``[INFO] ``[INFO] ------------------------------------------------------------------------``[INFO] Building HelloJUnit5 1.0.2``[INFO] ------------------------------------------------------------------------``[INFO] ``[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ HelloJUnit5 ---``[INFO] Deleting /Users/sperry/home/development/projects/learn/HelloJUnit5/target``[INFO] ``[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/main/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:compile (default-compile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/classes``[INFO] ``[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/test/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:testCompile (default-testCompile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/test-classes``[INFO] ``[INFO] --- maven-surefire-plugin:2.19:test (default-test) @ HelloJUnit5 ---` `-------------------------------------------------------`` ``T E S T S``-------------------------------------------------------``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Running com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Tests run: 1, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 0.038 sec - in com.makotojava.learn.hellojunit5.solution.JUnit5AppTest` `Results :` `Tests run: 1, Failures: 0, Errors: 0, Skipped: 1` `[INFO] ------------------------------------------------------------------------``[INFO] BUILD SUCCESS``[INFO] ------------------------------------------------------------------------``[INFO] Total time: 3.741 s``[INFO] Finished at: 2017-11-28T18:04:50-06:00``[INFO] Final Memory: 21M/255M``[INFO] ------------------------------------------------------------------------ Running unit tests with GradleOpen a terminal window (Mac) or command prompt (Windows), navigate to the directory where you cloned the HelloJUnit5 application, and enter this command: 1gradle clean test The output should look like this: 1$ gradle clean test``Starting a Gradle Daemon (subsequent builds will be faster)``:clean``:compileJava``:processResources NO-SOURCE``:classes``:compileTestJava``:processTestResources NO-SOURCE``:testClasses``:junitPlatformTest``ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.` `Test run finished after 10097 ms``[ 7 containers found ]``[ 5 containers skipped ]``[ 2 containers started ]``[ 0 containers aborted ]``[ 2 containers successful ]``[ 0 containers failed ]``[ 10 tests found ]``[ 10 tests skipped ]``[ 0 tests started ]``[ 0 tests aborted ]``[ 0 tests successful ]``[ 0 tests failed ]` `:test SKIPPED` `BUILD SUCCESSFUL` `Total time: 21.014 secs 测试练习现在您已了解 JUnit Jupiter，查看了代码示例，并观看了视频（希望您已跟随视频进行操作）。非常棒，但没有什么比动手编写代码更有用了！在第 1 部分的最后一节，您将完成以下任务： 编写 JUnit Jupiter API 单元测试。 运行单元测试。 实现 App 类，让您的单元测试通过检查。 采用真正的测试驱动开发 (TDD) 方式，首先编写单元测试，运行它们，并会观察到它们全部失败了。然后编写实现，直到单元测试通过，这时您就大功告成了。 注意，JUnit5AppTest 类仅提供了两个现成的测试方法。首次运行该类时，二者都是 “绿色” 的。要完成这些练习，您需要添加剩余的代码，包括用于告诉 JUnit 运行哪些测试方法的注解。记住，如果没有正确配备一个类或方法，JUnit 将跳过它。 如果遇到困难，请查阅 com.makotojava.learn.hellojunit5.solution 包来寻找解决方案。 1 编写 JUnit Jupiter 单元测试首先从 JUnit5AppTest.java 开始。打开此文件并按照 Javadoc 注解中的指示操作。 提示：使用 Eclipse 中的 Javadoc 视图读取测试指令。要打开 Javadoc 视图，可以转到 Window &gt; Show View &gt; Javadoc。您应该看到 Javadoc 视图。根据您设置工作区的方式，该窗口可能出现在任意多个位置。在我的工作区中，该窗口与图 3 中的屏幕截图类似，出现在 IDE 右侧的编辑器窗口下方： 图 3. Javadoc 视图 编辑器窗口中显示了具有原始 HTML 标记的 Javadoc 注解，但在 Javadoc 窗口中，已将其格式化，因此更易于阅读。 在 Eclipse 中运行单元测试如果您像我一样，您会使用 IDE 执行以下工作： 编写单元测试。 编写单元测试所测试的实现内容。 运行初始测试（使用 IDE 的原生 JUnit 支持）。 JUnit 5 提供了一个名为 JUnitPlatform 的类，它允许您在 Eclipse 中运行 JUnit 5 测试。 Eclipse 中的 JUnit 5：Eclipse 目前能理解 JUnit 4，但尚未提供对 JUnit 5 的原生支持。幸运的是，这对大部分单元测试而言都不是什么大问题！除非您需要使用 JUnit 4 一些更复杂的特性，否则要编写单元测试来全面检查您的应用程序代码，JUnitPlatform 类就足够了。 要在 Eclipse 中运行测试，需要确保您的计算机上拥有示例应用程序。为此，最轻松的方法是从 GitHub 克隆 HelloJUnit5 应用程序，然后将它导入 Eclipse 中。（因为本教程的视频展示了如何这么做，所以这里将跳过细节，仅提供操作步骤。） 确保您克隆了 GitHub 存储库，然后将代码导入 Eclipse 中作为新的 Maven 项目。 将该项目导入 Eclipse 中后，打开 Project Explorer 视图并展开 src/main/test 节点，直至看到 JUnit5AppTest。要以 JUnit 测试的形式运行它，可以右键单击它，选择 Run As &gt; JUnit Test。 实现 App 类，直到单元测试通过检查App 的单一 add() 方法提供的功能很容易理解，而且在设计上非常简单。我不希望复杂应用程序的业务逻辑阻碍您对 JUnit Jupiter 的学习。 单元测试通过后，您就大功告成了！记住，如果遇到困难，可以在 com.makotojava.learn.hellojunit5.solution 包中查找解决方案。 第 1 部分小结在 JUnit 5 教程的前半部分中，我介绍了 JUnit 5 的架构和组件，并详细介绍了 JUnit Jupiter API。我们逐个介绍了 JUnit 5 中最常用的注解、断言和前置条件，而且通过一个快速练习演示了如何在 Eclipse、Maven 和 Gradle 中运行测试。 在第 2 部分中，您将了解 JUnit 5 的一些高级特性： JUnit Jupiter 扩展模型 方法参数注入 参数化测试 那么您接下来会怎么做？ mockito","categories":[],"tags":[]},{"title":"","slug":"JavaAssist","date":"2021-10-18T07:13:48.287Z","updated":"2021-10-18T07:12:28.803Z","comments":true,"path":"2021/10/18/JavaAssist/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/JavaAssist/","excerpt":"","text":"Javassist是用来处理java字节码的类库。字节码保存在二进制文件中称为类文件。每个类文件夹包括一个java类或接口。 Javasssist.CtClass这个类是一个类文件的抽象表示。一个CtClass(compile-time class编译时类)对象处理一个类文件。下面是个简单的例子： ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(&quot;test.Rectangle&quot;); cc.setSuperclass(pool.get(&quot;test.Point&quot;)); cc.writeFile();","categories":[],"tags":[]},{"title":"","slug":"JAVA 泛型","date":"2021-10-18T07:13:48.286Z","updated":"2021-10-18T07:13:09.114Z","comments":true,"path":"2021/10/18/JAVA 泛型/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/JAVA%20%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"JAVA 泛型一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。 因此，与其使用 Object ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，T 就是类型参数： 12345678910111213141516// generics/GenericHolder.javapublic class GenericHolder&lt;T&gt; &#123; private T a; public GenericHolder() &#123;&#125; public void set(T a) &#123; this.a = a; &#125; public T get() &#123; return a; &#125; public static void main(String[] args) &#123; GenericHolder&lt;Automobile&gt; h3 = new GenericHolder&lt;Automobile&gt;(); h3.set(new Automobile()); // 此处有类型校验 Automobile a = h3.get(); // 无需类型转换 //- h3.set(&quot;Not an Automobile&quot;); // 报错 //- h3.set(1); // 报错 &#125;&#125; 创建 GenericHolder 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 main() 中那样使用。然后，你就只能在 GenericHolder 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 get() 取值时，直接就是正确的类型。 这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。 你可能注意到 h3 的定义非常繁复。在 = 左边有 GenericHolder&lt;Automobile&gt;, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子： 12345678910// generics/Diamond.javaclass Bob &#123;&#125;public class Diamond&lt;T&gt; &#123; public static void main(String[] args) &#123; GenericHolder&lt;Bob&gt; h3 = new GenericHolder&lt;&gt;(); h3.set(new Bob()); &#125;&#125; 注意，在 h3 的定义处，= 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。 一个元组类库有时一个方法需要能返回多个对象。而 return 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。 这个概念称为元组，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 数据传输对象 或 信使 ）。 通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组： 1234567891011121314// onjava/Tuple2.javapackage onjava;public class Tuple2&lt;A, B&gt; &#123; public final A a1; public final B a2; public Tuple2(A a, B b) &#123; a1 = a; a2 = b; &#125; public String rep() &#123; return a1 + &quot;, &quot; + a2; &#125; @Override public String toString() &#123; return &quot;(&quot; + rep() + &quot;)&quot;; &#125;&#125; 构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。 初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。a1 和 a2 应该声明为 private，然后提供 getFirst() 和 getSecond() 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 a1 和 a2 然后对它们执行任何操作，但无法对 a1 和 a2 重新赋值。例子中的 final 可以实现同样的效果，并且更为简洁明了。 另一种设计思路是允许元组的用户给 a1 和 a2 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 Tuple2 对象。 我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// onjava/Tuple3.javapackage onjava;public class Tuple3&lt;A, B, C&gt; extends Tuple2&lt;A, B&gt; &#123; public final C a3; public Tuple3(A a, B b, C c) &#123; super(a, b); a3 = c; &#125; @Override public String rep() &#123; return super.rep() + &quot;, &quot; + a3; &#125;&#125;// onjava/Tuple4.javapackage onjava;public class Tuple4&lt;A, B, C, D&gt; extends Tuple3&lt;A, B, C&gt; &#123; public final D a4; public Tuple4(A a, B b, C c, D d) &#123; super(a, b, c); a4 = d; &#125; @Override public String rep() &#123; return super.rep() + &quot;, &quot; + a4; &#125;&#125;// onjava/Tuple5.javapackage onjava;public class Tuple5&lt;A, B, C, D, E&gt; extends Tuple4&lt;A, B, C, D&gt; &#123; public final E a5; public Tuple5(A a, B b, C c, D d, E e) &#123; super(a, b, c, d); a5 = e; &#125; @Override public String rep() &#123; return super.rep() + &quot;, &quot; + a5; &#125;&#125; 演示需要，再定义两个类： 12345// generics/Amphibian.javapublic class Amphibian &#123;&#125;// generics/Vehicle.javapublic class Vehicle &#123;&#125; 使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型： 12345678910111213141516171819202122232425262728293031323334353637// generics/TupleTest.javaimport onjava.*;public class TupleTest &#123; static Tuple2&lt;String, Integer&gt; f() &#123; // 47 自动装箱为 Integer return new Tuple2&lt;&gt;(&quot;hi&quot;, 47); &#125; static Tuple3&lt;Amphibian, String, Integer&gt; g() &#123; return new Tuple3&lt;&gt;(new Amphibian(), &quot;hi&quot;, 47); &#125; static Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; h() &#123; return new Tuple4&lt;&gt;(new Vehicle(), new Amphibian(), &quot;hi&quot;, 47); &#125; static Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; k() &#123; return new Tuple5&lt;&gt;(new Vehicle(), new Amphibian(), &quot;hi&quot;, 47, 11.1); &#125; public static void main(String[] args) &#123; Tuple2&lt;String, Integer&gt; ttsi = f(); System.out.println(ttsi); // ttsi.a1 = &quot;there&quot;; // 编译错误，因为 final 不能重新赋值 System.out.println(g()); System.out.println(h()); System.out.println(k()); &#125;&#125;/* 输出： (hi, 47) (Amphibian@1540e19d, hi, 47) (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47) (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1) */ 有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。 通过 ttsi.a1 = &quot;there&quot; 语句的报错，我们可以看出，final 声明确实可以确保 public 字段在对象被构造出来之后就不能重新赋值了。 在上面的程序中，new 表达式有些啰嗦。本章稍后会介绍，如何利用 泛型方法 简化它们。 接下来我们看一个稍微复杂一点的例子：堆栈。在 集合 一章中，我们用 LinkedList 实现了 onjava.Stack 类。在那个例子中，LinkedList 本身已经具备了创建堆栈所需的方法。Stack 是通过两个泛型类 Stack&lt;T&gt; 和 LinkedList&lt;T&gt; 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。 这次我们不用 LinkedList 来实现自己的内部链式存储机制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// generics/LinkedStack.java// 用链式结构实现的堆栈public class LinkedStack&lt;T&gt; &#123; private static class Node&lt;U&gt; &#123; U item; Node&lt;U&gt; next; Node() &#123; item = null; next = null; &#125; Node(U item, Node&lt;U&gt; next) &#123; this.item = item; this.next = next; &#125; boolean end() &#123; return item == null &amp;&amp; next == null; &#125; &#125; private Node&lt;T&gt; top = new Node&lt;&gt;(); // 栈顶 public void push(T item) &#123; top = new Node&lt;&gt;(item, top); &#125; public T pop() &#123; T result = top.item; if (!top.end()) &#123; top = top.next; &#125; return result; &#125; public static void main(String[] args) &#123; LinkedStack&lt;String&gt; lss = new LinkedStack&lt;&gt;(); for (String s : &quot;Phasers on stun!&quot;.split(&quot; &quot;)) &#123; lss.push(s); &#125; String s; while ((s = lss.pop()) != null) &#123; System.out.println(s); &#125; &#125;&#125; 输出结果： 123stun!onPhasers 内部类 Node 也是一个泛型，它拥有自己的类型参数。 这个例子使用了一个 末端标识 (end sentinel) 来判断栈何时为空。这个末端标识是在构造 LinkedStack 时创建的。然后，每次调用 push() 就会创建一个 Node&lt;T&gt; 对象，并将其链接到前一个 Node&lt;T&gt; 对象。当你调用 pop() 方法时，总是返回 top.item，然后丢弃当前 top 所指向的 Node&lt;T&gt;，并将 top 指向下一个 Node&lt;T&gt;，除非到达末端标识，这时就不能再移动 top 了。如果已经到达末端，程序还继续调用 pop() 方法，它只能得到 null，说明栈已经空了。 RandomList作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 select() 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型： 123456789101112131415161718// generics/RandomList.javaimport java.util.*;import java.util.stream.*;public class RandomList&lt;T&gt; extends ArrayList&lt;T&gt; &#123; private Random rand = new Random(47); public T select() &#123; return get(rand.nextInt(size())); &#125; public static void main(String[] args) &#123; RandomList&lt;String&gt; rs = new RandomList&lt;&gt;(); Arrays.stream(&quot;The quick brown fox jumped over the lazy brown dog&quot;.split(&quot; &quot;)).forEach(rs::add); IntStream.range(0, 11).forEach(i -&gt; System.out.print(rs.select() + &quot; &quot;)); &#125;&#125; 输出结果： 1brown over fox quick quick dog brown The brown lazy brown RandomList 继承了 ArrayList 的所有方法。本例中只添加了 select() 这个方法。 泛型接口泛型也可以应用于接口。例如 生成器，这是一种专门负责创建对象的类。实际上，这是 工厂方法 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。 一般而言，一个生成器只定义一个方法，用于创建对象。例如 java.util.function 类库中的 Supplier 就是一个生成器，调用其 get() 获取对象。get() 是泛型方法，返回值为类型参数 T。 为了演示 Supplier，我们需要定义几个类。下面是个咖啡相关的继承体系： 12345678910111213141516171819202122232425262728293031323334353637// generics/coffee/Coffee.javapackage generics.coffee;public class Coffee &#123; private static long counter = 0; private final long id = counter++; @Override public String toString() &#123; return getClass().getSimpleName() + &quot; &quot; + id; &#125;&#125;// generics/coffee/Latte.javapackage generics.coffee;public class Latte extends Coffee &#123;&#125;// generics/coffee/Mocha.javapackage generics.coffee;public class Mocha extends Coffee &#123;&#125;// generics/coffee/Cappuccino.javapackage generics.coffee;public class Cappuccino extends Coffee &#123;&#125;// generics/coffee/Americano.javapackage generics.coffee;public class Americano extends Coffee &#123;&#125;// generics/coffee/Breve.javapackage generics.coffee;public class Breve extends Coffee &#123;&#125; 现在，我们可以编写一个类，实现 Supplier&lt;Coffee&gt; 接口，它能够随机生成不同类型的 Coffee 对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// generics/coffee/CoffeeSupplier.java// &#123;java generics.coffee.CoffeeSupplier&#125;package generics.coffee;import java.util.*;import java.util.function.*;import java.util.stream.*;public class CoffeeSupplierimplements Supplier&lt;Coffee&gt;, Iterable&lt;Coffee&gt; &#123; private Class&lt;?&gt;[] types = &#123; Latte.class, Mocha.class, Cappuccino.class, Americano.class, Breve.class &#125;; private static Random rand = new Random(47); public CoffeeSupplier() &#123;&#125; // For iteration: private int size = 0; public CoffeeSupplier(int sz) &#123; size = sz; &#125; @Override public Coffee get() &#123; try &#123; return (Coffee) types[rand.nextInt(types.length)].newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; class CoffeeIterator implements Iterator&lt;Coffee&gt; &#123; int count = size; @Override public boolean hasNext() &#123; return count &gt; 0; &#125; @Override public Coffee next() &#123; count--; return CoffeeSupplier.this.get(); &#125; @Override public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; @Override public Iterator&lt;Coffee&gt; iterator() &#123; return new CoffeeIterator(); &#125; public static void main(String[] args) &#123; Stream.generate(new CoffeeSupplier()) .limit(5) .forEach(System.out::println); for (Coffee c : new CoffeeSupplier(5)) &#123; System.out.println(c); &#125; &#125;&#125; 输出结果： 12345678910Americano 0Latte 1Americano 2Mocha 3Mocha 4Breve 5Americano 6Latte 7Cappuccino 8Cappuccino 9 参数化的 Supplier 接口确保 get() 返回值是参数的类型。CoffeeSupplier 同时还实现了 Iterable 接口，所以能用于 for-in 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。 下面是另一个实现 Supplier&lt;T&gt; 接口的例子，它负责生成 Fibonacci 数列： 12345678910111213141516171819202122// generics/Fibonacci.java// Generate a Fibonacci sequenceimport java.util.function.*;import java.util.stream.*;public class Fibonacci implements Supplier&lt;Integer&gt; &#123; private int count = 0; @Override public Integer get() &#123; return fib(count++); &#125; private int fib(int n) &#123; if(n &lt; 2) return 1; return fib(n-2) + fib(n-1); &#125; public static void main(String[] args) &#123; Stream.generate(new Fibonacci()) .limit(18) .map(n -&gt; n + &quot; &quot;) .forEach(System.out::print); &#125;&#125; 输出结果： 11 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 虽然我们在 Fibonacci 类的里里外外使用的都是 int 类型，但是其参数类型却是 Integer。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 Fibonacci 类对 int 的使用，我们已经看到了这种效果。 如果还想更进一步，编写一个实现了 Iterable 的 Fibnoacci 生成器。我们的一个选择是重写这个类，令其实现 Iterable 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 适配器 (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。 有多种方法可以实现适配器。例如，可以通过继承来创建适配器类： 12345678910111213141516171819202122232425262728293031// generics/IterableFibonacci.java// Adapt the Fibonacci class to make it Iterableimport java.util.*;public class IterableFibonacciextends Fibonacci implements Iterable&lt;Integer&gt; &#123; private int n; public IterableFibonacci(int count) &#123; n = count; &#125; @Override public Iterator&lt;Integer&gt; iterator() &#123; return new Iterator&lt;Integer&gt;() &#123; @Override public boolean hasNext() &#123; return n &gt; 0; &#125; @Override public Integer next() &#123; n--; return IterableFibonacci.this.get(); &#125; @Override public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; public static void main(String[] args) &#123; for(int i : new IterableFibonacci(18)) System.out.print(i + &quot; &quot;); &#125;&#125; 输出结果： 11 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 在 for-in 语句中使用 IterableFibonacci，必须在构造函数中提供一个边界值，这样 hasNext() 才知道何时返回 false，结束循环。 泛型方法到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。 泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。 如果方法是 static 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。 要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示： 12345678910111213141516171819202122232425// generics/GenericMethods.javapublic class GenericMethods &#123; public &lt;T&gt; void f(T x) &#123; System.out.println(x.getClass().getName()); &#125; public static void main(String[] args) &#123; GenericMethods gm = new GenericMethods(); gm.f(&quot;&quot;); gm.f(1); gm.f(1.0); gm.f(1.0F); gm.f(&#x27;c&#x27;); gm.f(gm); &#125;&#125;/* Output:java.lang.Stringjava.lang.Integerjava.lang.Doublejava.lang.Floatjava.lang.CharacterGenericMethods*/ 尽管可以同时对类及其方法进行参数化，但这里未将 GenericMethods 类参数化。只有方法 f() 具有类型参数，该参数由方法返回类型之前的参数列表指示。 对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 类型参数推断。因此，对 f() 的调用看起来像普通的方法调用，并且 f() 看起来像被重载了无数次一样。它甚至会接受 GenericMethods 类型的参数。 如果使用基本类型调用 f() ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。 变长参数和泛型方法泛型方法和变长参数列表可以很好地共存： 123456789101112131415161718192021222324252627282930// generics/GenericVarargs.javaimport java.util.ArrayList;import java.util.List;public class GenericVarargs &#123; @SafeVarargs public static &lt;T&gt; List&lt;T&gt; makeList(T... args) &#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for (T item : args) result.add(item); return result; &#125; public static void main(String[] args) &#123; List&lt;String&gt; ls = makeList(&quot;A&quot;); System.out.println(ls); ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); System.out.println(ls); ls = makeList( &quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;)); System.out.println(ls); &#125;&#125;/* Output:[A][A, B, C][A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,S, T, U, V, W, X, Y, Z]*/ 此处显示的 makeList() 方法产生的功能与标准库的 java.util.Arrays.asList() 方法相同。 @SafeVarargs 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。 一个泛型的 Supplier这是一个为任意具有无参构造方法的类生成 Supplier 的类。为了减少键入，它还包括一个用于生成 BasicSupplier 的泛型方法： 1234567891011121314151617181920212223242526272829// onjava/BasicSupplier.java// Supplier from a class with a no-arg constructorpackage onjava;import java.util.function.Supplier;public class BasicSupplier&lt;T&gt; implements Supplier&lt;T&gt; &#123; private Class&lt;T&gt; type; public BasicSupplier(Class&lt;T&gt; type) &#123; this.type = type; &#125; @Override public T get() &#123; try &#123; // Assumes type is a public class: return type.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; // Produce a default Supplier from a type token: public static &lt;T&gt; Supplier&lt;T&gt; create(Class&lt;T&gt; type) &#123; return new BasicSupplier&lt;&gt;(type); &#125;&#125; 此类提供了产生以下对象的基本实现： 是 public 的。 因为 BasicSupplier 在单独的包中，所以相关的类必须具有 public 权限，而不仅仅是包级访问权限。 具有无参构造方法。要创建一个这样的 BasicSupplier 对象，请调用 create() 方法，并将要生成类型的类型令牌传递给它。通用的 create() 方法提供了 BasicSupplier.create(MyType.class) 这种较简洁的语法来代替较笨拙的 new BasicSupplier &lt;MyType&gt;(MyType.class)。 例如，这是一个具有无参构造方法的简单类： 123456789101112131415// generics/CountedObject.javapublic class CountedObject &#123; private static long counter = 0; private final long id = counter++; public long id() &#123; return id; &#125; @Override public String toString() &#123; return &quot;CountedObject &quot; + id; &#125;&#125; CountedObject 类可以跟踪自身创建了多少个实例，并通过 toString() 报告这些实例的数量。 BasicSupplier 可以轻松地为 CountedObject 创建 Supplier： 123456789101112131415161718192021 // generics/BasicSupplierDemo.javaimport onjava.BasicSupplier;import java.util.stream.Stream;public class BasicSupplierDemo &#123; public static void main(String[] args) &#123; Stream.generate( BasicSupplier.create(CountedObject.class)) .limit(5) .forEach(System.out::println); &#125;&#125;/* Output:CountedObject 0CountedObject 1CountedObject 2CountedObject 3CountedObject 4*/ 泛型方法减少了产生 Supplier 对象所需的代码量。 Java 泛型强制传递 Class 对象，以便在 create() 方法中将其用于类型推断。","categories":[],"tags":[]},{"title":"","slug":"CGLIB","date":"2021-10-18T07:13:48.282Z","updated":"2021-10-18T07:13:25.743Z","comments":true,"path":"2021/10/18/CGLIB/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/CGLIB/","excerpt":"","text":"什么是CGLIBCGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib 为什么使用CGLIBCGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。关于Java动态代理，可以参者这里Java动态代理分析 CGLIB组成结构 CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类。除了CGLIB库外，脚本语言（如Groovy何BeanShell）也使用ASM生成字节码。ASM使用类似SAX的解析器来实现高性能。我们不鼓励直接使用ASM，因为它需要对Java字节码的格式足够的了解 例子说了这么多，可能大家还是不知道CGLIB是干什么用的。下面我们将使用一个简单的例子来演示如何使用CGLIB对一个方法进行拦截。首先，我们需要在工程的POM文件中引入cglib的dependency，这里我们使用的是2.2.2版本 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;12345 依赖包下载后，我们就可以干活了，按照国际惯例，写个hello world 123456789101112131415161718192021public class SampleClass &#123; public void test()&#123; System.out.println(&quot;hello world&quot;); &#125; public static void main(String[] args) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(SampleClass.class); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;before method run...&quot;); Object result = proxy.invokeSuper(obj, args); System.out.println(&quot;after method run...&quot;); return result; &#125; &#125;); SampleClass sample = (SampleClass) enhancer.create(); sample.test(); &#125;&#125; 在mian函数中，我们通过一个Enhancer和一个MethodInterceptor来实现对方法的拦截，运行程序后输出为： 123before method run...hello worldafter method run...123 在上面的程序中，我们引入了Enhancer和MethodInterceptor，可能有些读者还不太了解。别急，我们后面将会一一进行介绍。就目前而言，一个使用CGLIB的小demo就完成了 常用的API目前网络上对CGLIB的介绍资料比较少，造成对cglib的学习困难。这里我将对cglib中的常用类进行一个介绍。为了避免解释的不清楚，我将为每个类都配有一个demo，用来做进一步的说明。首先就从Enhancer开始吧。 EnhancerEnhancer可能是CGLIB中最常用的一个类，和Java1.3动态代理中引入的Proxy类差不多(如果对Proxy不懂，可以参考这里)。和Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。基于同样的道理，Enhancer也不能对fianl类进行代理操作。这也是Hibernate为什么不能持久化final class的原因。 12345public class SampleClass &#123; public String test(String input)&#123; return &quot;hello world&quot;; &#125;&#125; 下面我们将以这个类作为主要的测试类，来测试调用各种方法 12345678910111213141516@Testpublic void testFixedValue()&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(SampleClass.class); enhancer.setCallback(new FixedValue() &#123; @Override public Object loadObject() throws Exception &#123; return &quot;Hello cglib&quot;; &#125; &#125;); SampleClass proxy = (SampleClass) enhancer.create(); System.out.println(proxy.test(null)); //拦截test，输出Hello cglib System.out.println(proxy.toString()); System.out.println(proxy.getClass()); System.out.println(proxy.hashCode());&#125; 程序的输出为： 12345678Hello cglibHello cglibclass com.zeus.cglib.SampleClass$$EnhancerByCGLIB$$e3ea9b7java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number at com.zeus.cglib.SampleClass$$EnhancerByCGLIB$$e3ea9b7.hashCode(&lt;generated&gt;) ... 上述代码中，FixedValue用来对所有拦截的方法返回相同的值，从输出我们可以看出来，Enhancer对非final方法test()、toString()、hashCode()进行了拦截，没有对getClass进行拦截。由于hashCode()方法需要返回一个Number，但是我们返回的是一个String，这解释了上面的程序中为什么会抛出异常。 Enhancer.setSuperclass用来设置父类型，从toString方法可以看出，使用CGLIB生成的类为被代理类的一个子类，形如：SampleClass$$EnhancerByCGLIB$$e3ea9b7 Enhancer.create(Object…)方法是用来创建增强对象的，其提供了很多不同参数的方法用来匹配被增强类的不同构造方法。（虽然类的构造放法只是Java字节码层面的函数，但是Enhancer却不能对其进行操作。Enhancer同样不能操作static或者final类）。我们也可以先使用Enhancer.createClass()来创建字节码(.class)，然后用字节码动态的生成增强后的对象。 可以使用一个InvocationHandler(如果对InvocationHandler不懂，可以参考这里)作为回调，使用invoke方法来替换直接访问类的方法，但是你必须注意死循环。因为invoke中调用的任何原代理类方法，均会重新代理到invoke方法中。 1234567891011121314151617public void testInvocationHandler() throws Exception&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(SampleClass.class); enhancer.setCallback(new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class)&#123; return &quot;hello cglib&quot;; &#125;else&#123; throw new RuntimeException(&quot;Do not know what to do&quot;); &#125; &#125; &#125;); SampleClass proxy = (SampleClass) enhancer.create(); Assert.assertEquals(&quot;hello cglib&quot;, proxy.test(null)); Assert.assertNotEquals(&quot;Hello cglib&quot;, proxy.toString());&#125; 为了避免这种死循环，我们可以使用MethodInterceptor，MethodInterceptor的例子在前面的hello world中已经介绍过了，这里就不浪费时间了。 有些时候我们可能只想对特定的方法进行拦截，对其他的方法直接放行，不做任何操作，使用Enhancer处理这种需求同样很简单,只需要一个CallbackFilter即可： 1234567891011121314151617181920212223242526@Testpublic void testCallbackFilter() throws Exception&#123; Enhancer enhancer = new Enhancer(); CallbackHelper callbackHelper = new CallbackHelper(SampleClass.class, new Class[0]) &#123; @Override protected Object getCallback(Method method) &#123; if(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class)&#123; return new FixedValue() &#123; @Override public Object loadObject() throws Exception &#123; return &quot;Hello cglib&quot;; &#125; &#125;; &#125;else&#123; return NoOp.INSTANCE; &#125; &#125; &#125;; enhancer.setSuperclass(SampleClass.class); enhancer.setCallbackFilter(callbackHelper); enhancer.setCallbacks(callbackHelper.getCallbacks()); SampleClass proxy = (SampleClass) enhancer.create(); Assert.assertEquals(&quot;Hello cglib&quot;, proxy.test(null)); Assert.assertNotEquals(&quot;Hello cglib&quot;,proxy.toString()); System.out.println(proxy.hashCode());&#125; ImmutableBean通过名字就可以知道，不可变的Bean。ImmutableBean允许创建一个原来对象的包装类，这个包装类是不可变的，任何改变底层对象的包装类操作都会抛出IllegalStateException。但是我们可以通过直接操作底层对象来改变包装类对象。这有点类似于Guava中的不可变视图 为了对ImmutableBean进行测试，这里需要再引入一个bean 1234567891011121314151617public class SampleBean &#123; private String value; public SampleBean() &#123; &#125; public SampleBean(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125;&#125; 然后编写测试类如下： 12345678910@Test(expected = IllegalStateException.class)public void testImmutableBean() throws Exception&#123; SampleBean bean = new SampleBean(); bean.setValue(&quot;Hello world&quot;); SampleBean immutableBean = (SampleBean) ImmutableBean.create(bean); //创建不可变类 Assert.assertEquals(&quot;Hello world&quot;,immutableBean.getValue()); bean.setValue(&quot;Hello world, again&quot;); //可以通过底层对象来进行修改 Assert.assertEquals(&quot;Hello world, again&quot;, immutableBean.getValue()); immutableBean.setValue(&quot;Hello cglib&quot;); //直接修改将throw exception&#125; Bean generatorcglib提供的一个操作bean的工具，使用它能够在运行时动态的创建一个bean。 1234567891011@Testpublic void testBeanGenerator() throws Exception&#123; BeanGenerator beanGenerator = new BeanGenerator(); beanGenerator.addProperty(&quot;value&quot;,String.class); Object myBean = beanGenerator.create(); Method setter = myBean.getClass().getMethod(&quot;setValue&quot;,String.class); setter.invoke(myBean,&quot;Hello cglib&quot;); Method getter = myBean.getClass().getMethod(&quot;getValue&quot;); Assert.assertEquals(&quot;Hello cglib&quot;,getter.invoke(myBean));&#125; 在上面的代码中，我们使用cglib动态的创建了一个和SampleBean相同的Bean对象，包含一个属性value以及getter、setter方法 Bean Copiercglib提供的能够从一个bean复制到另一个bean中，而且其还提供了一个转换器，用来在转换的时候对bean的属性进行操作。 123456789101112131415161718192021public class OtherSampleBean &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125;&#125;@Testpublic void testBeanCopier() throws Exception&#123; BeanCopier copier = BeanCopier.create(SampleBean.class, OtherSampleBean.class, false);//设置为true，则使用converter SampleBean myBean = new SampleBean(); myBean.setValue(&quot;Hello cglib&quot;); OtherSampleBean otherBean = new OtherSampleBean(); copier.copy(myBean, otherBean, null); //设置为true，则传入converter指明怎么进行转换 assertEquals(&quot;Hello cglib&quot;, otherBean.getValue());&#125; BulkBean相比于BeanCopier，BulkBean将copy的动作拆分为getPropertyValues和setPropertyValues两个方法，允许自定义处理属性 1234567891011121314@Testpublic void testBulkBean() throws Exception&#123; BulkBean bulkBean = BulkBean.create(SampleBean.class, new String[]&#123;&quot;getValue&quot;&#125;, new String[]&#123;&quot;setValue&quot;&#125;, new Class[]&#123;String.class&#125;); SampleBean bean = new SampleBean(); bean.setValue(&quot;Hello world&quot;); Object[] propertyValues = bulkBean.getPropertyValues(bean); assertEquals(1, bulkBean.getPropertyValues(bean).length); assertEquals(&quot;Hello world&quot;, bulkBean.getPropertyValues(bean)[0]); bulkBean.setPropertyValues(bean,new Object[]&#123;&quot;Hello cglib&quot;&#125;); assertEquals(&quot;Hello cglib&quot;, bean.getValue());&#125; 使用注意：\\1. 避免每次进行BulkBean.create创建对象，一般将其声明为static的\\2. 应用场景：针对特定属性的get,set操作，一般适用通过xml配置注入和注出的属性，运行时才确定处理的Source,Target类，只需要关注属性名即可。 BeanMapBeanMap类实现了Java Map，将一个bean对象中的所有属性转换为一个String-to-Obejct的Java Map 1234567891011121314@Testpublic void testBeanMap() throws Exception&#123; BeanGenerator generator = new BeanGenerator(); generator.addProperty(&quot;username&quot;,String.class); generator.addProperty(&quot;password&quot;,String.class); Object bean = generator.create(); Method setUserName = bean.getClass().getMethod(&quot;setUsername&quot;, String.class); Method setPassword = bean.getClass().getMethod(&quot;setPassword&quot;, String.class); setUserName.invoke(bean, &quot;admin&quot;); setPassword.invoke(bean,&quot;password&quot;); BeanMap map = BeanMap.create(bean); Assert.assertEquals(&quot;admin&quot;, map.get(&quot;username&quot;)); Assert.assertEquals(&quot;password&quot;, map.get(&quot;password&quot;));&#125; 我们使用BeanGenerator生成了一个含有两个属性的Java Bean，对其进行赋值操作后，生成了一个BeanMap对象，通过获取值来进行验证 keyFactorykeyFactory类用来动态生成接口的实例，接口需要只包含一个newInstance方法，返回一个Object。keyFactory为构造出来的实例动态生成了Object.equals和Object.hashCode方法，能够确保相同的参数构造出的实例为单例的。 123public interface SampleKeyFactory &#123; Object newInstance(String first, int second);&#125;123 我们首先构造一个满足条件的接口，然后进行测试 1234567@Testpublic void testKeyFactory() throws Exception&#123; SampleKeyFactory keyFactory = (SampleKeyFactory) KeyFactory.create(SampleKeyFactory.class); Object key = keyFactory.newInstance(&quot;foo&quot;, 42); Object key1 = keyFactory.newInstance(&quot;foo&quot;, 42); Assert.assertEquals(key,key1);//测试参数相同，结果是否相等&#125;1234567 Mixin(混合)Mixin能够让我们将多个对象整合到一个对象中去，前提是这些对象必须是接口的实现。可能这样说比较晦涩，以代码为例： 1234567891011121314151617181920212223242526272829303132333435public class MixinInterfaceTest &#123; interface Interface1&#123; String first(); &#125; interface Interface2&#123; String second(); &#125; class Class1 implements Interface1&#123; @Override public String first() &#123; return &quot;first&quot;; &#125; &#125; class Class2 implements Interface2&#123; @Override public String second() &#123; return &quot;second&quot;; &#125; &#125; interface MixinInterface extends Interface1, Interface2&#123; &#125; @Test public void testMixin() throws Exception&#123; Mixin mixin = Mixin.create(new Class[]&#123;Interface1.class, Interface2.class, MixinInterface.class&#125;, new Object[]&#123;new Class1(),new Class2()&#125;); MixinInterface mixinDelegate = (MixinInterface) mixin; assertEquals(&quot;first&quot;, mixinDelegate.first()); assertEquals(&quot;second&quot;, mixinDelegate.second()); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435 Mixin类比较尴尬，因为他要求Minix的类（例如MixinInterface）实现一些接口。既然被Minix的类已经实现了相应的接口，那么我就直接可以通过纯Java的方式实现，没有必要使用Minix类。 String switcher用来模拟一个String到int类型的Map类型。如果在Java7以后的版本中，类似一个switch语句。 123456789@Testpublic void testStringSwitcher() throws Exception&#123; String[] strings = new String[]&#123;&quot;one&quot;, &quot;two&quot;&#125;; int[] values = new int[]&#123;10,20&#125;; StringSwitcher stringSwitcher = StringSwitcher.create(strings,values,true); assertEquals(10, stringSwitcher.intValue(&quot;one&quot;)); assertEquals(20, stringSwitcher.intValue(&quot;two&quot;)); assertEquals(-1, stringSwitcher.intValue(&quot;three&quot;));&#125;123456789 Interface Maker正如名字所言，Interface Maker用来创建一个新的Interface 12345678910@Testpublic void testInterfaceMarker() throws Exception&#123; Signature signature = new Signature(&quot;foo&quot;, Type.DOUBLE_TYPE, new Type[]&#123;Type.INT_TYPE&#125;); InterfaceMaker interfaceMaker = new InterfaceMaker(); interfaceMaker.add(signature, new Type[0]); Class iface = interfaceMaker.create(); assertEquals(1, iface.getMethods().length); assertEquals(&quot;foo&quot;, iface.getMethods()[0].getName()); assertEquals(double.class, iface.getMethods()[0].getReturnType());&#125;12345678910 上述的Interface Maker创建的接口中只含有一个方法，签名为double foo(int)。Interface Maker与上面介绍的其他类不同，它依赖ASM中的Type类型。由于接口仅仅只用做在编译时期进行类型检查，因此在一个运行的应用中动态的创建接口没有什么作用。但是InterfaceMaker可以用来自动生成代码，为以后的开发做准备。 Method delegateMethodDelegate主要用来对方法进行代理 1234567891011interface BeanDelegate&#123; String getValueFromDelegate();&#125;@Testpublic void testMethodDelegate() throws Exception&#123; SampleBean bean = new SampleBean(); bean.setValue(&quot;Hello cglib&quot;); BeanDelegate delegate = (BeanDelegate) MethodDelegate.create(bean,&quot;getValue&quot;, BeanDelegate.class); assertEquals(&quot;Hello cglib&quot;, delegate.getValueFromDelegate());&#125;1234567891011 关于Method.create的参数说明：\\1. 第二个参数为即将被代理的方法\\2. 第一个参数必须是一个无参数构造的bean。因此MethodDelegate.create并不是你想象的那么有用\\3. 第三个参数为只含有一个方法的接口。当这个接口中的方法被调用的时候，将会调用第一个参数所指向bean的第二个参数方法 缺点：\\1. 为每一个代理类创建了一个新的类，这样可能会占用大量的永久代堆内存\\2. 你不能代理需要参数的方法\\3. 如果你定义的接口中的方法需要参数，那么代理将不会工作，并且也不会抛出异常；如果你的接口中方法需要其他的返回类型，那么将抛出IllegalArgumentException MulticastDelegate 多重代理和方法代理差不多，都是将代理类方法的调用委托给被代理类。使用前提是需要一个接口，以及一个类实现了该接口 通过这种interface的继承关系，我们能够将接口上方法的调用分散给各个实现类上面去。 多重代理的缺点是接口只能含有一个方法，如果被代理的方法拥有返回值，那么调用代理类的返回值为最后一个添加的被代理类的方法返回值 123456789101112131415161718192021222324252627282930public interface DelegatationProvider &#123; void setValue(String value);&#125;public class SimpleMulticastBean implements DelegatationProvider &#123; private String value; @Override public void setValue(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125;@Testpublic void testMulticastDelegate() throws Exception&#123; MulticastDelegate multicastDelegate = MulticastDelegate.create(DelegatationProvider.class); SimpleMulticastBean first = new SimpleMulticastBean(); SimpleMulticastBean second = new SimpleMulticastBean(); multicastDelegate = multicastDelegate.add(first); multicastDelegate = multicastDelegate.add(second); DelegatationProvider provider = (DelegatationProvider) multicastDelegate; provider.setValue(&quot;Hello world&quot;); assertEquals(&quot;Hello world&quot;, first.getValue()); assertEquals(&quot;Hello world&quot;, second.getValue());&#125;123456789101112131415161718192021222324252627282930 Constructor delegate为了对构造函数进行代理，我们需要一个接口，这个接口只含有一个Object newInstance(…)方法，用来调用相应的构造函数 12345678910111213141516interface SampleBeanConstructorDelegate&#123; Object newInstance(String value);&#125;/** * 对构造函数进行代理 * @throws Exception */@Testpublic void testConstructorDelegate() throws Exception&#123; SampleBeanConstructorDelegate constructorDelegate = (SampleBeanConstructorDelegate) ConstructorDelegate.create( SampleBean.class, SampleBeanConstructorDelegate.class); SampleBean bean = (SampleBean) constructorDelegate.newInstance(&quot;Hello world&quot;); assertTrue(SampleBean.class.isAssignableFrom(bean.getClass())); System.out.println(bean.getValue());&#125;12345678910111213141516 Parallel Sorter(并行排序器)能够对多个数组同时进行排序，目前实现的算法有归并排序和快速排序 123456789101112131415@Testpublic void testParallelSorter() throws Exception&#123; Integer[][] value = &#123; &#123;4, 3, 9, 0&#125;, &#123;2, 1, 6, 0&#125; &#125;; ParallelSorter.create(value).mergeSort(0); for(Integer[] row : value)&#123; int former = -1; for(int val : row)&#123; assertTrue(former &lt; val); former = val; &#125; &#125;&#125;123456789101112131415 FastClass顾明思义，FastClass就是对Class对象进行特定的处理，比如通过数组保存method引用，因此FastClass引出了一个index下标的新概念，比如getIndex(String name, Class[] parameterTypes)就是以前的获取method的方法。通过数组存储method,constructor等class信息，从而将原先的反射调用，转化为class.index的直接调用，从而体现所谓的FastClass。 12345678@Testpublic void testFastClass() throws Exception&#123; FastClass fastClass = FastClass.create(SampleBean.class); FastMethod fastMethod = fastClass.getMethod(&quot;getValue&quot;,new Class[0]); SampleBean bean = new SampleBean(); bean.setValue(&quot;Hello world&quot;); assertEquals(&quot;Hello world&quot;,fastMethod.invoke(bean, new Object[0]));&#125;12345678 注意由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。 CGLIB和Java动态代理的区别 Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类； Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效 3. CGLIB相关的文章：- http://jnb.ociweb.com/jnb/jnbNov2005.html- http://www.iteye.com/topic/799827- http://mydailyjava.blogspot.kr/2013/11/cglib-missing-manual.html","categories":[],"tags":[]},{"title":"","slug":"内部类和嵌套类","date":"2021-10-18T07:13:48.280Z","updated":"2021-10-18T07:13:11.428Z","comments":true,"path":"2021/10/18/内部类和嵌套类/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E7%B1%BB/","excerpt":"","text":"内部类和嵌套类内部类方法和作用域可以在一个方法里面或者在任意的作用域内定义内部类。 这么做有两个理由： 如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。 在后面的例子中，先前的代码将被修改，以用来实现： 一个定义在方法中的类。 一个定义在作用域内的类，此作用域在方法的内部。 一个实现了接口的匿名类。 一个匿名类，它扩展了没有默认构造器的类。 一个匿名类，它执行字段初始化。 一个匿名类，它通过实例初始化实现构造（匿名内部类不可能有构造器）。 第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类： 12345678910111213141516171819202122// innerclasses/Parcel5.java// Nesting a class within a methodpublic class Parcel5 &#123; public Destination destination(String s) &#123; final class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; @Override public String readLabel() &#123; return label; &#125; &#125; return new PDestination(s); &#125; public static void main(String[] args) &#123; Parcel5 p = new Parcel5(); Destination d = p.destination(&quot;Tasmania&quot;); &#125;&#125; PDestination 类是 destination() 方法的一部分，而不是 Parcel5 的一部分。所以，在 destination() 之外不能访问 PDestination，注意出现在 return 语句中的向上转型-返回的是 Destination 的引用，它是 PDestination 的基类。当然，在 destination() 中定义了内部类 PDestination，并不意味着一旦 destination() 方法执行完毕，PDestination 就不可用了。 第二个例子展示了如何在任意的作用域内嵌入一个内部类： 123456789101112131415161718192021222324// innerclasses/Parcel6.java// Nesting a class within a scopepublic class Parcel6 &#123; private void internalTracking(boolean b) &#123; if(b) &#123; class TrackingSlip &#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip() &#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip(&quot;slip&quot;); String s = ts.getSlip(); &#125; // Can&#x27;t use it here! Out of scope: //- TrackingSlip ts = new TrackingSlip(&quot;x&quot;); &#125; public void track() &#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel6 p = new Parcel6(); p.track(); &#125;&#125; TrackingSlip 类被嵌入在 if 语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义 Trackingslip 的作用域之外，它是不可用的，除此之外，它与普通的类一样。 匿名内部类下面的例子看起来有点奇怪： 1234567891011121314151617// innerclasses/Parcel7.java// Returning an instance of an anonymous inner classpublic class Parcel7 &#123; public Contents contents() &#123; return new Contents() &#123; // Insert class definition private int i = 11; @Override public int value() &#123; return i; &#125; &#125;; // Semicolon required &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); Contents c = p.contents(); &#125;&#125; contents() 方法将返回值的生成与表示这个返回值的类的定义结合在一起！另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个 Contents 对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义。” 这种奇怪的语法指的是：“创建一个继承自 Contents 的匿名类的对象。”通过 new 表达式返回的引用被自动向上转型为对 Contents 的引用。上述匿名内部类的语法是下述形式的简化形式： 123456789101112131415161718// innerclasses/Parcel7b.java// Expanded version of Parcel7.javapublic class Parcel7b &#123; class MyContents implements Contents &#123; private int i = 11; @Override public int value() &#123; return i; &#125; &#125; public Contents contents() &#123; return new MyContents(); &#125; public static void main(String[] args) &#123; Parcel7b p = new Parcel7b(); Contents c = p.contents(); &#125;&#125; 在这个匿名内部类中，使用了默认的构造器来生成 Contents。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办： 1234567891011121314151617// innerclasses/Parcel8.java// Calling the base-class constructorpublic class Parcel8 &#123; public Wrapping wrapping(int x) &#123; // Base constructor call: return new Wrapping(x) &#123; // [1] @Override public int value() &#123; return super.value() * 47; &#125; &#125;; // [2] &#125; public static void main(String[] args) &#123; Parcel8 p = new Parcel8(); Wrapping w = p.wrapping(10); &#125;&#125; [1] 将合适的参数传递给基类的构造器。 [2] 在匿名内部类末尾的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的地方使用的分号是一致的。 尽管 Wrapping 只是一个具有具体实现的普通类，但它还是被导出类当作公共“接口”来使用。 123456// innerclasses/Wrapping.javapublic class Wrapping &#123; private int i; public Wrapping(int x) &#123; i = x; &#125; public int value() &#123; return i; &#125;&#125; 如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样： 123456789101112131415161718192021222324// innerclasses/AnonymousConstructor.java// Creating a constructor for an anonymous inner classabstract class Base &#123; Base(int i) &#123; System.out.println(&quot;Base constructor, i = &quot; + i); &#125; public abstract void f();&#125;public class AnonymousConstructor &#123; public static Base getBase(int i) &#123; return new Base(i) &#123; &#123; System.out.println( &quot;Inside instance initializer&quot;); &#125; @Override public void f() &#123; System.out.println(&quot;In anonymous f()&quot;); &#125; &#125;; &#125; public static void main(String[] args) &#123; Base base = getBase(47); base.f(); &#125;&#125; 输出为： 123Base constructor, i = 47Inside instance initializerIn anonymous f() 在此例中，不要求变量一定是 final 的。因为被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。 下例是带实例初始化的”parcel”形式。注意 destination() 的参数必须是 final 的，因为它们是在匿名类内部使用的（译者注：即使不加 final, Java 8 的编译器也会为我们自动加上 final，以保证数据的一致性）。 123456789101112131415161718192021222324// innerclasses/Parcel10.java// Using &quot;instance initialization&quot; to perform// construction on an anonymous inner classpublic class Parcel10 &#123; public Destination destination(final String dest, final float price) &#123; return new Destination() &#123; private int cost; // Instance initialization for each object: &#123; cost = Math.round(price); if(cost &gt; 100) System.out.println(&quot;Over budget!&quot;); &#125; private String label = dest; @Override public String readLabel() &#123; return label; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel10 p = new Parcel10(); Destination d = p.destination(&quot;Tasmania&quot;, 101.395F); &#125;&#125; 输出为： 1Over budget! 在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是 if 语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制-你不能重载实例初始化方法，所以你仅有一个这样的构造器。 匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。 嵌套类如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 static，这通常称为嵌套类。想要理解 static 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。然而，当内部类是 static 的时，就不是这样了。嵌套类意味着： 要创建嵌套类的对象，并不需要其外部类的对象。 不能从嵌套类的对象中访问非静态的外部类对象。 嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 static 数据和 static 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西： 1234567891011121314151617181920212223242526272829303132333435// innerclasses/Parcel11.java// Nested classes (static inner classes)public class Parcel11 &#123; private static class ParcelContents implements Contents &#123; private int i = 11; @Override public int value() &#123; return i; &#125; &#125; protected static final class ParcelDestination implements Destination &#123; private String label; private ParcelDestination(String whereTo) &#123; label = whereTo; &#125; @Override public String readLabel() &#123; return label; &#125; // Nested classes can contain other static elements: public static void f() &#123;&#125; static int x = 10; static class AnotherLevel &#123; public static void f() &#123;&#125; static int x = 10; &#125; &#125; public static Destination destination(String s) &#123; return new ParcelDestination(s); &#125; public static Contents contents() &#123; return new ParcelContents(); &#125; public static void main(String[] args) &#123; Contents c = contents(); Destination d = destination(&quot;Tasmania&quot;); &#125;&#125; 接口内部的类嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 public 和 static 的。因为类是 static 的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现其外部接口，就像下面这样： 1234567891011121314// innerclasses/ClassInInterface.java// &#123;java ClassInInterface$Test&#125;public interface ClassInInterface &#123; void howdy(); class Test implements ClassInInterface &#123; @Override public void howdy() &#123; System.out.println(&quot;Howdy!&quot;); &#125; public static void main(String[] args) &#123; new Test().howdy(); &#125; &#125;&#125; 输出为： 1Howdy! 如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。 我曾在本书中建议过，在每个类中都写一个 main() 方法，用来测试这个类。这样做有一个缺点，那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码。 123456789101112// innerclasses/TestBed.java// Putting test code in a nested class// &#123;java TestBed$Tester&#125;public class TestBed &#123; public void f() &#123; System.out.println(&quot;f()&quot;); &#125; public static class Tester &#123; public static void main(String[] args) &#123; TestBed t = new TestBed(); t.f(); &#125; &#125;&#125; 输出为： 1f() 从多层嵌套类中访问外部类的成员一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外部类的所有成员，如下所示： 1234567891011121314151617181920212223// innerclasses/MultiNestingAccess.java// Nested classes can access all members of all// levels of the classes they are nested withinclass MNA &#123; private void f() &#123;&#125; class A &#123; private void g() &#123;&#125; public class B &#123; void h() &#123; g(); f(); &#125; &#125; &#125;&#125;public class MultiNestingAccess &#123; public static void main(String[] args) &#123; MNA mna = new MNA(); MNA.A mnaa = mna.new A(); MNA.A.B mnaab = mnaa.new B(); mnaab.h(); &#125;&#125; 可以看到在 MNA.A.B 中，调用方法 g() 和 f() 不需要任何条件（即使它们被定义为 private）。这个例子同时展示了如何从不同的类里创建多层嵌套的内部类对象的基本语法。”.new“语法能产生正确的作用域，所以不必在调用构造器时限定类名。 为什么需要内部类至此，我们已经看到了许多描述内部类的语法和语义，但是这并不能同答“为什么需要内部类”这个问题。那么，Java 设计者们为什么会如此费心地增加这项基本的语言特性呢？ 一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部类的对象。所以可以认为内部类提供了某种进入其外部类的窗口。 内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外部类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外部类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是： 每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。 为了看到更多的细节，让我们考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择；使用单一类，或者使用内部类： 12345678910111213141516171819202122232425// innerclasses/mui/MultiInterfaces.java// Two ways a class can implement multiple interfaces// &#123;java innerclasses.mui.MultiInterfaces&#125;package innerclasses.mui;interface A &#123;&#125;interface B &#123;&#125;class X implements A, B &#123;&#125;class Y implements A &#123; B makeB() &#123; // Anonymous inner class: return new B() &#123;&#125;; &#125;&#125;public class MultiInterfaces &#123; static void takesA(A a) &#123;&#125; static void takesB(B b) &#123;&#125; public static void main(String[] args) &#123; X x = new X(); Y y = new Y(); takesA(x); takesA(y); takesB(x); takesB(y.makeB()); &#125;&#125; 当然，这里假设在两种方式下的代码结构都确实有逻辑意义。然而遇到问题的时候，通常问题本身就能给出某些指引，告诉你是应该使用单一类，还是使用内部类。但如果没有任何其他限制，从实现的观点来看，前面的例子并没有什么区别，它们都能正常运作。 如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承： 1234567891011121314151617181920212223242526// innerclasses/MultiImplementation.java// For concrete or abstract classes, inner classes// produce &quot;multiple implementation inheritance&quot;// &#123;java innerclasses.MultiImplementation&#125;package innerclasses;class D &#123;&#125;abstract class E &#123;&#125;class Z extends D &#123; E makeE() &#123; return new E() &#123;&#125;; &#125;&#125;public class MultiImplementation &#123; static void takesD(D d) &#123;&#125; static void takesE(E e) &#123;&#125; public static void main(String[] args) &#123; Z z = new Z(); takesD(z); takesE(z.makeE()); &#125;&#125; 如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性： 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立。 在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。 稍后就会展示一个这样的例子。 创建内部类对象的时刻并不依赖于外部类对象的创建 内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。 举个例子，如果 Sequence.java 不使用内部类，就必须声明”Sequence 是一个 Selector“，对于某个特定的 Sequence 只能有一个 Selector，然而使用内部类很容易就能拥有另一个方法 reverseSelector()，用它来生成一个反方向遍历序列的 Selector，只有内部类才有这种灵活性。 闭包与回调闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 private 成员。 在 Java 8 之前，内部类是实现闭包的唯一方式。在 Java 8 中，我们可以使用 lambda 表达式来实现闭包行为，并且语法更加优雅和简洁，你将会在 函数式编程 这一章节中学习相关细节。尽管相对于内部类，你可能更喜欢使用 lambda 表达式实现闭包，但是你会看到并需要理解那些在 Java 8 之前通过内部类方式实现闭包的代码，因此仍然有必要来理解这种方式。 Java 最引人争议的问题之一就是，人们认为 Java 应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java 更小心仔细，所以没有在语言中包括指针。 通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。见下例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// innerclasses/Callbacks.java// Using inner classes for callbacks// &#123;java innerclasses.Callbacks&#125;package innerclasses;interface Incrementable &#123; void increment();&#125;// Very simple to just implement the interface:class Callee1 implements Incrementable &#123; private int i = 0; @Override public void increment() &#123; i++; System.out.println(i); &#125;&#125;class MyIncrement &#123; public void increment() &#123; System.out.println(&quot;Other operation&quot;); &#125; static void f(MyIncrement mi) &#123; mi.increment(); &#125;&#125;// If your class must implement increment() in// some other way, you must use an inner class:class Callee2 extends MyIncrement &#123; private int i = 0; @Override public void increment() &#123; super.increment(); i++; System.out.println(i); &#125; private class Closure implements Incrementable &#123; @Override public void increment() &#123; // Specify outer-class method, otherwise // you&#x27;ll get an infinite recursion: Callee2.this.increment(); &#125; &#125; Incrementable getCallbackReference() &#123; return new Closure(); &#125;&#125;class Caller &#123; private Incrementable callbackReference; Caller(Incrementable cbh) &#123; callbackReference = cbh; &#125; void go() &#123; callbackReference.increment(); &#125;&#125;public class Callbacks &#123; public static void main(String[] args) &#123; Callee1 c1 = new Callee1(); Callee2 c2 = new Callee2(); MyIncrement.f(c2); Caller caller1 = new Caller(c1); Caller caller2 = new Caller(c2.getCallbackReference()); caller1.go(); caller1.go(); caller2.go(); caller2.go(); &#125;&#125; 输出为： 12345678Other operation112Other operation2Other operation3 这个例子进一步展示了外部类实现一个接口与内部类实现此接口之间的区别。就代码而言，Callee1 是更简单的解决方式。Callee2 继承自 MyIncrement，后者已经有了一个不同的 increment() 方法，并且与 Incrementable 接口期望的 increment() 方法完全不相关。所以如果 Callee2 继承了 MyIncrement，就不能为了 Incrementable 的用途而覆盖 increment() 方法，于是只能使用内部类独立地实现 Incrementable，还要注意，当创建了一个内部类时，并没有在外部类的接口中添加东西，也没有修改外部类的接口。 注意，在 Callee2 中除了 getCallbackReference() 以外，其他成员都是 private 的。要想建立与外部世界的任何连接，接口 Incrementable 都是必需的。在这里可以看到，interface 是如何允许接口与接口的实现完全独立的。 内部类 Closure 实现了 Incrementable，以提供一个返回 Callee2 的“钩子”（hook）-而且是一个安全的钩子。无论谁获得此 Incrementable 的引用，都只能调用 increment()，除此之外没有其他功能（不像指针那样，允许你做很多事情）。 Caller 的构造器需要一个 Incrementable 的引用作为参数（虽然可以在任意时刻捕获回调引用），然后在以后的某个时刻，Caller 对象可以使用此引用回调 Callee 类。 回调的价值在于它的灵活性-可以在运行时动态地决定需要调用什么方法。例如，在图形界面实现 GUI 功能的时候，到处都用到回调。","categories":[],"tags":[]},{"title":"","slug":"内部类和迭代器删除数组元素","date":"2021-10-18T07:13:48.278Z","updated":"2021-10-18T07:13:19.192Z","comments":true,"path":"2021/10/18/内部类和迭代器删除数组元素/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"内部类和迭代器删除数组元素继承内部类因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外部类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联： 123456789101112131415// innerclasses/InheritInner.java// Inheriting an inner classclass WithInner &#123; class Inner &#123;&#125;&#125;public class InheritInner extends WithInner.Inner &#123; //- InheritInner() &#123;&#125; // Won&#x27;t compile InheritInner(WithInner wi) &#123; wi.super(); &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); &#125;&#125; 可以看到，InheritInner 只继承自内部类，而不是外部类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外部类对象的引用。此外，必须在构造器内使用如下语法： 1内部类的引用.super(); 这样才提供了必要的引用，然后程序才能编译通过。 内部类的覆盖如果创建了一个内部类，然后继承其外部类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？这看起来似乎是个很有用的思想，但是“覆盖”内部类就好像它是外部类的一个方法，其实并不起什么作用： 123456789101112131415161718192021222324// innerclasses/BigEgg.java// An inner class cannot be overridden like a methodclass Egg &#123; private Yolk y; protected class Yolk &#123; public Yolk() &#123; System.out.println(&quot;Egg.Yolk()&quot;); &#125; &#125; Egg() &#123; System.out.println(&quot;New Egg()&quot;); y = new Yolk(); &#125;&#125;public class BigEgg extends Egg &#123; public class Yolk &#123; public Yolk() &#123; System.out.println(&quot;BigEgg.Yolk()&quot;); &#125; &#125; public static void main(String[] args) &#123; new BigEgg(); &#125;&#125; 输出为： 12New Egg()Egg.Yolk() 默认的无参构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了 BigEgg 的对象，那么所使用的应该是“覆盖后”的 Yolk 版本，但从输出中可以看到实际情况并不是这样的。 这个例子说明，当继承了某个外部类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的： 1234567891011121314151617181920212223242526272829303132// innerclasses/BigEgg2.java// Proper inheritance of an inner classclass Egg2 &#123; protected class Yolk &#123; public Yolk() &#123; System.out.println(&quot;Egg2.Yolk()&quot;); &#125; public void f() &#123; System.out.println(&quot;Egg2.Yolk.f()&quot;); &#125; &#125; private Yolk y = new Yolk(); Egg2() &#123; System.out.println(&quot;New Egg2()&quot;); &#125; public void insertYolk(Yolk yy) &#123; y = yy; &#125; public void g() &#123; y.f(); &#125;&#125;public class BigEgg2 extends Egg2 &#123; public class Yolk extends Egg2.Yolk &#123; public Yolk() &#123; System.out.println(&quot;BigEgg2.Yolk()&quot;); &#125; @Override public void f() &#123; System.out.println(&quot;BigEgg2.Yolk.f()&quot;); &#125; &#125; public BigEgg2() &#123; insertYolk(new Yolk()); &#125; public static void main(String[] args) &#123; Egg2 e2 = new BigEgg2(); e2.g(); &#125;&#125; 输出为： 12345Egg2.Yolk()New Egg2()Egg2.Yolk()BigEgg2.Yolk()BigEgg2.Yolk.f() 现在 BigEgg2.Yolk 通过 extends Egg2.Yolk 明确地继承了此内部类，并且覆盖了其中的方法。insertYolk() 方法允许 BigEgg2 将它自己的 Yolk 对象向上转型为 Egg2 中的引用 y。所以当 g() 调用 y.f() 时，覆盖后的新版的 f() 被执行。第二次调用 Egg2.Yolk()，结果是 BigEgg2.Yolk 的构造器调用了其基类的构造器。可以看到在调用 g() 的时候，新版的 f() 被调用了。 局部内部类前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外部类的一部分；但是它可以访问当前代码块内的常量，以及此外部类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// innerclasses/LocalInnerClass.java// Holds a sequence of Objectsinterface Counter &#123; int next();&#125;public class LocalInnerClass &#123; private int count = 0; Counter getCounter(final String name) &#123; // A local inner class: class LocalCounter implements Counter &#123; LocalCounter() &#123; // Local inner class can have a constructor System.out.println(&quot;LocalCounter()&quot;); &#125; @Override public int next() &#123; System.out.print(name); // Access local final return count++; &#125; &#125; return new LocalCounter(); &#125; // Repeat, but with an anonymous inner class: Counter getCounter2(final String name) &#123; return new Counter() &#123; // Anonymous inner class cannot have a named // constructor, only an instance initializer: &#123; System.out.println(&quot;Counter()&quot;); &#125; @Override public int next() &#123; System.out.print(name); // Access local final return count++; &#125; &#125;; &#125; public static void main(String[] args) &#123; LocalInnerClass lic = new LocalInnerClass(); Counter c1 = lic.getCounter(&quot;Local inner &quot;), c2 = lic.getCounter2(&quot;Anonymous inner &quot;); for(int i = 0; i &lt; 5; i++) System.out.println(c1.next()); for(int i = 0; i &lt; 5; i++) System.out.println(c2.next()); &#125;&#125; 输出为： 123456789101112LocalCounter()Counter()Local inner 0Local inner 1Local inner 2Local inner 3Local inner 4Anonymous inner 5Anonymous inner 6Anonymous inner 7Anonymous inner 8Anonymous inner 9 Counter 返回的是序列中的下一个值。我们分别使用局部内部类和匿名内部类实现了这个功能，它们具有相同的行为和能力，既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。 所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。 内部类标识符由于编译后每个类都会产生一个**.class** 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个”meta-class”，叫做 Class 对象）。 你可能猜到了，内部类也必须生成一个**.class** 文件以包含它们的 Class 对象信息。这些类文件的命名有严格的规则：外部类的名字，加上“**$“，再加上内部类的名字。例如，LocalInnerClass.java** 生成的 .class 文件包括： 1234Counter.classLocalInnerClass$1.classLocalInnerClass$LocalCounter.classLocalInnerClass.class 如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外部类标识符与“**$**”的后面。 虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是 java 的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java 编译器会尽可能地转换它们。） java集合遍历删除的方法一般地，我们有两种方式进行Java集合的遍历删除: 1、实现方式就是讲遍历与移除操作分离，即在遍历的过程中，将需要移除的数据存放在另外一个集合当中，遍历结束之后，统一移除。 2、使用Iterator遍历删除。 使用Iterator遍历删除的原因： Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象， Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。 123456789101112public static void main(String args[]) &#123; List&lt;String&gt; famous = new ArrayList&lt;String&gt;(); famous.add(&quot;liudehua&quot;); famous.add(&quot;madehua&quot;); famous.add(&quot;liushishi&quot;); famous.add(&quot;tangwei&quot;); for (String s : famous) &#123; if (s.equals(&quot;madehua&quot;)) &#123; famous.remove(s); &#125; &#125;&#125; 运行出异常: Exception in thread “main” java.util.ConcurrentModificationException at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372) at java.util.AbstractList$Itr.next(AbstractList.java:343) at com.bes.Test.main(Test.java:15) Java新手最容易犯的错误，对JAVA集合进行遍历删除时务必要用迭代器。切记。 其实对于如上for循环，运行过程中还是转换成了如下代码： 123456for(Iterator&lt;String&gt; it = famous.iterator();it.hasNext();)&#123; String s = it.next(); if(s.equals(&quot;madehua&quot;))&#123; famous.remove(s); &#125;&#125; 仍然采用的是迭代器，但删除操作却用了错误的方法。如将famous.remove(s)改成it.remove() 为什么用了迭代码器就不能采用famous.remove(s)操作? 这种因为ArrayList与Iterator混合使用时会导致各自的状态出现不一样，最终出现异常。","categories":[],"tags":[]},{"title":"","slug":"类的访问权限","date":"2021-10-18T07:13:48.276Z","updated":"2021-10-18T07:12:42.282Z","comments":true,"path":"2021/10/18/类的访问权限/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/","excerpt":"","text":"类的访问权限每个编译单元只能存在一个public类，(一个.java文件)，同时这个java文件的文件名必须和类确保一致，包括大小写，如果不存在public类，则文件命名没有特殊要求，其他的访问权限相关类似于方法和变量的访问权限。 除了内部类，其他类不可以是private 和protected的。只能是包访问权限和public之中的一种， 关于继承继承的时候，父类的构造方法最先被调用，然后调用子类的构造方法，如果父类的构造方法中含有参数，就需要通过super()方法显式的调用并且传递合适的参数才能完成构造。 关于代理1234567891011121314151617181920212223242526272829303132333435public class SpaceShipDelegation &#123; private String name; private SpaceShipControls controls = new SpaceShipControls(); public SpaceShipDelegation(String name) &#123; this.name = name; &#125; // Delegated methods: public void back(int velocity) &#123; controls.back(velocity); &#125; public void down(int velocity) &#123; controls.down(velocity); &#125; public void forward(int velocity) &#123; controls.forward(velocity); &#125; public void left(int velocity) &#123; controls.left(velocity); &#125; public void right(int velocity) &#123; controls.right(velocity); &#125; public void turboBoost() &#123; controls.turboBoost(); &#125; public void up(int velocity) &#123; controls.up(velocity); &#125; public static void main(String[] args) &#123; SpaceShipDelegation protector = new SpaceShipDelegation(&quot;NSEA Protector&quot;); protector.forward(100); &#125; 如上面的代码所呈现的一样，我们在spaceshipdelegation类中创建了一个spaceshipcontrols的实例，并且通过这一实例来进行spaceshipcontrols的方法的调用，这个过程就被称为代理，代理是通过另一个类来实现其功能，而装饰器是在原类上进行功能的拓展。 final 关键字final修饰变量final 修饰变量用来指代这一变量是不可修改的，如果一个基本类型同时又用final进行修饰，代表这一变量成为编译时常量，即该变量在编译时就已经有一个确定的值了，对于对象的引用来说，final虽然也意味着引用无法指向别处，但是引用所指向的值可以进行改变，我们还可以不给静态final变量赋值，但是这也意味着我们需要在构造器中为final的对象进行赋值，否则将会产生错误；（这样的情况又被称为空白final） 像如下这个例子： 123456789101112131415161718192021222324class Poppet &#123; private int i; Poppet(int ii) &#123; i = ii; &#125;&#125;public class BlankFinal &#123; private final int i = 0; // Initialized final private final int j; // Blank final private final Poppet p; // Blank final reference // Blank finals MUST be initialized in the constructor: public BlankFinal() &#123; j = 1; // Initialize blank final p = new Poppet(1); // Initialize blank final reference &#125; public BlankFinal(int x) &#123; j = x; // Initialize blank final p = new Poppet(x); // Initialize blank final reference &#125; public static void main(String[] args) &#123; new BlankFinal(); new BlankFinal(47); &#125;&#125; ///:~ final参数Java允许在参数列表中以声明的方式将参数指明为final，这意味着你无法在方法中更改参数引用所指向的对象。 12345678910111213141516171819202122class Gizmo &#123; public void spin() &#123;&#125;&#125;public class FinalArguments &#123; void with(final Gizmo g) &#123; //! g = new Gizmo(); // Illegal -- g is final &#125; void without(Gizmo g) &#123; g = new Gizmo(); // OK -- g not final g.spin(); &#125; // void f(final int i) &#123; i++; &#125; // Can&#x27;t change // You can only read from a final primitive: int g(final int i) &#123; return i + 1; &#125; public static void main(String[] args) &#123; FinalArguments bf = new FinalArguments(); bf.without(null); bf.with(null); &#125;&#125; ///:~ 如代码中呈现的一样，final 指向的参数我们只能看，而不能对他做出任何的改变，对传入的参数仅仅能够读和返回，而不能做出改变。 final 修饰方法final修饰方法的原因有两个：第一个原因是把方法锁定，以防任何继承类修改它的含义，这是出于设计的考虑：想要确保在继承中使方法的行为保持不变，并且不会被覆盖。 过去使用final方法的第二个原因是效率，在JAVA早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用，当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值。）并且以方法体中的实际代码的副本来替代方法调用，这将消除方法调用的开销。但是当代码段过长，程序代码过于膨胀，可能看不到内嵌带来的任何性能提高。在最近的java版本中，虚拟机可以探测到这些情况，并且优化去掉这些效率反而降低的额外内嵌调用 ！！！！所以现在用final修饰方法单纯是由于第一个原因！ final 修饰类当将某个类整体定义为final时，就表明了你不打算继承该类，而且也不允许别人这样做，出于某种原因，你对该类的设计永远不需要做任何变动，或者出于安全的考虑，你不希望它有子类， 继承与初始化static初始化的顺序按照定义类时的书写顺序依次初始化。 如以下这个程序： 1234567891011121314151617181920212223242526272829303132333435363738394041//: reusing/Beetle.java// The full process of initialization.import static net.mindview.util.Print.*;class Insect &#123; private int i = 9; protected int j; Insect() &#123; print(&quot;i = &quot; + i + &quot;, j = &quot; + j); j = 39; &#125; private static int x1 = printInit(&quot;static Insect.x1 initialized&quot;); static int printInit(String s) &#123; print(s); return 47; &#125;&#125;public class Beetle extends Insect &#123; private int k = printInit(&quot;Beetle.k initialized&quot;); public Beetle() &#123; print(&quot;k = &quot; + k); print(&quot;j = &quot; + j); &#125; private static int x2 = printInit(&quot;static Beetle.x2 initialized&quot;); public static void main(String[] args) &#123; print(&quot;Beetle constructor&quot;); Beetle b = new Beetle(); &#125;&#125; /* Output:static Insect.x1 initializedstatic Beetle.x2 initializedBeetle constructori = 9, j = 0Beetle.k initializedk = 47j = 39*///:~ 在加载beetle的时候发现beetle具有一个基类insect 所以编译器继续加载了insect类，（不管是否有新建一个insect对象），加载完基类之后先加载根基类中的static，之后是下一个导出类，以此类推，这个过程结束完之后可以进行对象的创建了，即通过构造器进行对象的构建。","categories":[],"tags":[]},{"title":"","slug":"可变参数和enum","date":"2021-10-18T07:13:48.275Z","updated":"2021-10-18T07:12:49.984Z","comments":true,"path":"2021/10/18/可变参数和enum/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8Cenum/","excerpt":"","text":"可变参数和enumJAVA的可变参数列表如下面这段代码所呈现的一样 1234567891011121314151617181920class A &#123;&#125;public class VarArgs &#123; static void printArray(Object[] args) &#123; for(Object obj : args) System.out.print(obj + &quot; &quot;); System.out.println(); &#125; public static void main(String[] args) &#123; printArray(new Object[]&#123; new Integer(47), new Float(3.14), new Double(11.11) &#125;); printArray(new Object[]&#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot; &#125;); printArray(new Object[]&#123;new A(), new A(), new A()&#125;); &#125;&#125; /* Output: (Sample)47 3.14 11.11one two threeA@1a46e30 A@3e25a5 A@19821f*///:~ 第一段里我们插入了一个Object数组，但是其实可以以另外一种更加优雅的形式呈现： 类似于我们在python中经常使用到的*args,**kwargs来收集剩余的参数一样 123456789101112131415161718public class OptionalTrailingArguments &#123; static void f(int required, String... trailing) &#123; System.out.print(&quot;required: &quot; + required + &quot; &quot;); for(String s : trailing) System.out.print(s + &quot; &quot;); System.out.println(); &#125; public static void main(String[] args) &#123; f(1, &quot;one&quot;); f(2, &quot;two&quot;, &quot;three&quot;); f(0); &#125;&#125; /* Output:required: 1 onerequired: 2 two threerequired: 0*///:~ 同时，在使用可变参数时，应注意，在如下情况发生时可能会报错： 12345678910111213public class OverloadingVarargs2 &#123; static void f(float i, Character... args) &#123; System.out.println(&quot;first&quot;); &#125; static void f(Character... args) &#123; System.out.print(&quot;second&quot;); &#125; public static void main(String[] args) &#123; f(1, &#x27;a&#x27;); f(&#x27;a&#x27;, &#x27;b&#x27;); &#125;&#125; ///:~ 和 1234567891011121314151617181920212223242526272829303132public class OverloadingVarargs &#123; static void f(Character... args) &#123; System.out.print(&quot;first&quot;); for(Character c : args) System.out.print(&quot; &quot; + c); System.out.println(); &#125; static void f(Integer... args) &#123; System.out.print(&quot;second&quot;); for(Integer i : args) System.out.print(&quot; &quot; + i); System.out.println(); &#125; static void f(Long... args) &#123; System.out.println(&quot;third&quot;); &#125; public static void main(String[] args) &#123; f(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;); f(1); f(2, 1); f(0); f(0L); //! f(); // Won&#x27;t compile -- ambiguous &#125;&#125; /* Output:first a b csecond 1second 2 1second 0third*///:~ 当上例的f()被直接调用时可能会出现错误。 只有给两个方法都添加一个非可变参数，才能解决这个二义性问题， enum关键字可以定义如下的enum类型： 123456789101112131415161718192021222324252627282930313233343536enum Spiciness&#123; NOT,MILD,MEDIUM,HOT,FLAMING&#125;public class Burrito &#123; Spiciness degree; public Burrito(Spiciness degree) &#123; this.degree = degree;&#125; public void describe() &#123; System.out.print(&quot;This burrito is &quot;); switch(degree) &#123; case NOT: System.out.println(&quot;not spicy at all.&quot;); break; case MILD: case MEDIUM: System.out.println(&quot;a little hot.&quot;); break; case HOT: case FLAMING: default: System.out.println(&quot;maybe too hot.&quot;); &#125; &#125; public static void main(String[] args) &#123; Burrito plain = new Burrito(Spiciness.NOT), greenChile = new Burrito(Spiciness.MEDIUM), jalapeno = new Burrito(Spiciness.HOT); plain.describe(); greenChile.describe(); jalapeno.describe(); &#125;&#125; /* Output:This burrito is not spicy at all.This burrito is a little hot.This burrito is maybe too hot.*///:~ 在这个例子中，我们可以发现Spiciness实际上被定义成了一个对象，所以在这里的switch绝不仅仅是对enum中类型序号的输入，更多的是输入了一个限定对象中的某些成员。 如果在需要传入Spiciness对象的位置仅仅传入int数值则会报错，必须传入Spiciness.*** 以上也是enum类型经常使用的一种情况，即在switch语句中使用。","categories":[],"tags":[]},{"title":"","slug":"接口与工厂","date":"2021-10-18T07:13:48.273Z","updated":"2021-10-18T07:12:58.667Z","comments":true,"path":"2021/10/18/接口与工厂/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/","excerpt":"","text":"接口与工厂接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方法就是工厂方法设计模式，它与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象，理论上，通过这种方式，我们的代码将完全与接口的实现分离。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface Service &#123; void method1(); void method2();&#125;interface ServiceFactory &#123; Service getService();&#125;class Implementation1 implements Service &#123; Implementation1() &#123;&#125; // Package access public void method1() &#123;print(&quot;Implementation1 method1&quot;);&#125; public void method2() &#123;print(&quot;Implementation1 method2&quot;);&#125;&#125; class Implementation1Factory implements ServiceFactory &#123; public Service getService() &#123; return new Implementation1(); &#125;&#125;class Implementation2 implements Service &#123; Implementation2() &#123;&#125; // Package access public void method1() &#123;print(&quot;Implementation2 method1&quot;);&#125; public void method2() &#123;print(&quot;Implementation2 method2&quot;);&#125;&#125;class Implementation2Factory implements ServiceFactory &#123; public Service getService() &#123; return new Implementation2(); &#125;&#125; public class Factories &#123; public static void serviceConsumer(ServiceFactory fact) &#123; Service s = fact.getService(); s.method1(); s.method2(); &#125; public static void main(String[] args) &#123; serviceConsumer(new Implementation1Factory()); // Implementations are completely interchangeable: serviceConsumer(new Implementation2Factory()); &#125;&#125; /* Output:Implementation1 method1Implementation1 method2Implementation2 method1Implementation2 method2*///:~ 如果没有使用工厂方法，代码就必须在某处指定将要创建的Service的确切类型，以便调用合适的构造器。 对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂。 内部类创建内部类一种典型的创建内部类的方法： 1234567891011121314151617181920212223242526public class Parcel1 &#123; class Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; Destination(String whereTo) &#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; // Using inner classes looks just like // using any other class, within Parcel1: public void ship(String dest) &#123; Contents c = new Contents(); Destination d = new Destination(dest); System.out.println(d.readLabel()); &#125; public static void main(String[] args) &#123; Parcel1 p = new Parcel1(); p.ship(&quot;Tasmania&quot;); &#125;&#125; /* Output:Tasmania*///:~ 更加普遍的一种创建方法如下： 12345678910111213141516171819202122232425262728293031323334 public class Parcel2 &#123; class Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; Destination(String whereTo) &#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; public Destination to(String s) &#123; return new Destination(s); &#125; public Contents contents() &#123; return new Contents(); &#125; public void ship(String dest) &#123; Contents c = contents(); Destination d = to(dest); System.out.println(d.readLabel()); &#125; public static void main(String[] args) &#123; Parcel2 p = new Parcel2(); p.ship(&quot;Tasmania&quot;); Parcel2 q = new Parcel2(); // Defining references to inner classes: Parcel2.Contents c = q.contents(); Parcel2.Destination d = q.to(&quot;Borneo&quot;); &#125;&#125; /* Output:Tasmania*///:~ 内部类被用来作为一种名字隐藏和组织代码的模式。但是它的更有用的作用是： 当生成一个内部类的对象时，此对象与制造它的外围对象就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件，此外，内部类还拥有其外围类的所有元素的访问权： 123456789101112131415161718192021222324252627282930313233343536interface Selector &#123; boolean end(); Object current(); void next();&#125; public class Sequence &#123; private Object[] items; private int next = 0; public Sequence(int size) &#123; items = new Object[size]; &#125; public void add(Object x) &#123; if(next &lt; items.length) items[next++] = x; &#125; private class SequenceSelector implements Selector &#123; private int i = 0; public boolean end() &#123; return i == items.length; &#125; public Object current() &#123; return items[i]; &#125; public void next() &#123; if(i &lt; items.length) i++; &#125; &#125; public Selector selector() &#123; return new SequenceSelector(); &#125; public static void main(String[] args) &#123; Sequence sequence = new Sequence(10); for(int i = 0; i &lt; 10; i++) sequence.add(Integer.toString(i)); Selector selector = sequence.selector(); while(!selector.end()) &#123; System.out.print(selector.current() + &quot; &quot;); selector.next(); &#125; &#125;&#125; /* Output:0 1 2 3 4 5 6 7 8 9*///:~ 使用.this和.new如果你需要生成对外部类对象的引用，可以使用外部类的名字后面跟着this，这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。 123456789101112131415161718public class DotThis &#123; void f() &#123; System.out.println(&quot;DotThis.f()&quot;); &#125; public class Inner &#123; public DotThis outer() &#123; return DotThis.this; // A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot; &#125; &#125; public Inner inner() &#123; return new Inner(); &#125; public static void main(String[] args) &#123; DotThis dt = new DotThis(); DotThis.Inner dti = dt.inner(); dti.outer().f(); &#125;&#125; /* Output:DotThis.f()*///:~ 有时你需要创建某个内部类的对象，需要在new表达式中提供对其他外部类对象的引用，同时需要使用.new语法： 1234567public class DotNew &#123; public class Inner &#123;&#125; public static void main(String[] args) &#123; DotNew dn = new DotNew(); DotNew.Inner dni = dn.new Inner(); &#125;&#125; ///:~ 内部类与上转型","categories":[],"tags":[]},{"title":"","slug":"接口嵌套、线程池","date":"2021-10-18T07:13:48.271Z","updated":"2021-10-18T07:12:55.366Z","comments":true,"path":"2021/10/18/接口嵌套、线程池/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"接口嵌套、线程池接口可以嵌套在类或其他接口中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class A &#123; interface B &#123; void f(); &#125; public class BImp implements B &#123; public void f() &#123;&#125; &#125; private class BImp2 implements B &#123; public void f() &#123;&#125; &#125; public interface C &#123; void f(); &#125; class CImp implements C &#123; public void f() &#123;&#125; &#125; private class CImp2 implements C &#123; public void f() &#123;&#125; &#125; private interface D &#123; void f(); &#125; private class DImp implements D &#123; public void f() &#123;&#125; &#125; public class DImp2 implements D &#123; public void f() &#123;&#125; &#125; public D getD() &#123; return new DImp2(); &#125; private D dRef; public void receiveD(D d) &#123; dRef = d; dRef.f(); &#125;&#125; interface E &#123; interface G &#123; void f(); &#125; // Redundant &quot;public&quot;: public interface H &#123; void f(); &#125; void g(); // Cannot be private within an interface: //! private interface I &#123;&#125;&#125; public class NestingInterfaces &#123; public class BImp implements A.B &#123; public void f() &#123;&#125; &#125; class CImp implements A.C &#123; public void f() &#123;&#125; &#125; // Cannot implement a private interface except // within that interface&#x27;s defining class: //! class DImp implements A.D &#123; //! public void f() &#123;&#125; //! &#125; class EImp implements E &#123; public void g() &#123;&#125; &#125; class EGImp implements E.G &#123; public void f() &#123;&#125; &#125; class EImp2 implements E &#123; public void g() &#123;&#125; class EG implements E.G &#123; public void f() &#123;&#125; &#125; &#125; public static void main(String[] args) &#123; A a = new A(); // Can&#x27;t access A.D: //! A.D ad = a.getD(); // Doesn&#x27;t return anything but A.D: //! A.DImp2 di2 = a.getD(); // Cannot access a member of the interface: //! a.getD().f(); // Only another A can do anything with getD(): A a2 = new A(); a2.receiveD(a.getD()); &#125;&#125; ///:~ 在类中嵌套接口的语法是相当显而易见的，就像非嵌套接口一样，可以拥有public和“包访问性”两种可视性。 接口也可以被实现为private，就像在A.D中所看到的，DImp2依然将这个接口实现为了一个public类，但是A.DImpl2只能被其自身所使用。因此，实现一个接口是一个方式，可以强制该接口中的方法定义不添加任何类型信息，也就是无法进行向上转型。 getD()方法是一个对private接口的引用的public方法，在main()中，数次尝试使用返回值都无法成功，只有一种方式可以成功，就是将返回值交给有权使用它的对象，在本例中，是另一个A通过receivedD()方法来实现的。 当我们实现某个接口时，并不需要实现其内部所嵌套的接口。 private接口只能在定义它的类中被实现。 可缓存线程池newCachedThreadPool CachedThreadPool 是通过 java.util.concurrent.Executors 创建的 ThreadPoolExecutor 实例。这个实例会根据需要，在线程可用时，重用之前构造好的池中线程。这个线程池在执行 大量短生命周期的异步任务时（many short-lived asynchronous task），可以显著提高程序性能。调用 execute 时，可以重用之前已构造的可用线程，如果不存在可用线程，那么会重新创建一个新的线程并将其加入到线程池中。如果线程超过 60 秒还未被使用，就会被中止并从缓存中移除。因此，线程池在长时间空闲后不会消耗任何资源。 注意队列实例是：new SynchronousQueue() 固定数量线程池FixedThreadPoolFixedThreadPool 是通过 java.util.concurrent.Executors 创建的 ThreadPoolExecutor 实例。这个实例会复用 固定数量的线程 处理一个 共享的无边界队列 。任何时间点，最多有 nThreads 个线程会处于活动状态执行任务。如果当所有线程都是活动时，有多的任务被提交过来，那么它会一致在队列中等待直到有线程可用。如果任何线程在执行过程中因为错误而中止，新的线程会替代它的位置来执行后续的任务。所有线程都会一致存于线程池中，直到显式的执行 ExecutorService.shutdown() 关闭。 注意队列实例是：new LinkedBlockingQueue() 1 slf4j logback关系详解和相关用法","categories":[],"tags":[]},{"title":"","slug":"接口","date":"2021-10-18T07:13:48.270Z","updated":"2021-10-18T07:12:52.997Z","comments":true,"path":"2021/10/18/接口/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口代码复用复用代码的第一种方式是客户端程序员遵循该接口来编写他们自己的类，就像下面这样： 1234567891011121314151617181920212223242526272829303132333435363738public abstract class StringProcessor implements Processor&#123; public String name() &#123; return getClass().getSimpleName(); &#125; public abstract String process(Object input); public static String s = &quot;If she weighs the same as a duck, she&#x27;s made of wood&quot;; public static void main(String[] args) &#123; Apply.process(new Upcase(), s); Apply.process(new Downcase(), s); Apply.process(new Splitter(), s); &#125;&#125; class Upcase extends StringProcessor &#123; public String process(Object input) &#123; // Covariant return return ((String)input).toUpperCase(); &#125;&#125;class Downcase extends StringProcessor &#123; public String process(Object input) &#123; return ((String)input).toLowerCase(); &#125;&#125;class Splitter extends StringProcessor &#123; public String process(Object input) &#123; return Arrays.toString(((String)input).split(&quot; &quot;)); &#125; &#125; /* Output:Using Processor UpcaseIF SHE WEIGHS THE SAME AS A DUCK, SHE&#x27;S MADE OF WOODUsing Processor Downcaseif she weighs the same as a duck, she&#x27;s made of woodUsing Processor Splitter[If, she, weighs, the, same, as, a, duck,, she&#x27;s, made, of, wood]*///:~ 组合接口中的命名冲突：12345678910111213141516171819202122interface I1 &#123; void f(); &#125;interface I2 &#123; int f(int i); &#125;interface I3 &#123; int f(); &#125;class C &#123; public int f() &#123; return 1; &#125; &#125;class C2 implements I1, I2 &#123; public void f() &#123;&#125; public int f(int i) &#123; return 1; &#125; // overloaded&#125;class C3 extends C implements I2 &#123; public int f(int i) &#123; return 1; &#125; // overloaded&#125;class C4 extends C implements I3 &#123; // Identical, no problem: public int f() &#123; return 1; &#125;&#125;// Methods differ only by return type://! class C5 extends C implements I1 &#123;&#125;//! interface I4 extends I1, I3 &#123;&#125; ///:~ 正如上面所展示的一样。实际上C5继承C并实现I1，I4继承 I2,I3，但是C、I1，I2、I3都有f()方法，在进行实现时，f()方法m无法仅仅根据返回类型来进行足够的判断，所以被当做是一个编译时错误。 JAVA正则表达式利用(!=)()(!?)可以实现类似python中匹配的效果，如果不使用(!=)他在匹配过我们的结尾之后直接就从这次的结尾开始继续匹配，","categories":[],"tags":[]},{"title":"","slug":"方法引用和函数式编程","date":"2021-10-18T07:13:48.268Z","updated":"2021-10-18T07:13:01.438Z","comments":true,"path":"2021/10/18/方法引用和函数式编程/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"方法引用Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 ::，然后跟方法名称。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// functional/MethodReferences.javaimport java.util.*;interface Callable &#123; // [1] void call(String s);&#125;class Describe &#123; void show(String msg) &#123; // [2] System.out.println(msg); &#125;&#125;public class MethodReferences &#123; static void hello(String name) &#123; // [3] System.out.println(&quot;Hello, &quot; + name); &#125; static class Description &#123; String about; Description(String desc) &#123; about = desc; &#125; void help(String msg) &#123; // [4] System.out.println(about + &quot; &quot; + msg); &#125; &#125; static class Helper &#123; static void assist(String msg) &#123; // [5] System.out.println(msg); &#125; &#125; public static void main(String[] args) &#123; Describe d = new Describe(); Callable c = d::show; // [6] c.call(&quot;call()&quot;); // [7] c = MethodReferences::hello; // [8] c.call(&quot;Bob&quot;); c = new Description(&quot;valuable&quot;)::help; // [9] c.call(&quot;information&quot;); c = Helper::assist; // [10] c.call(&quot;Help!&quot;); &#125;&#125; 输出结果： 1234call()Hello, Bobvaluable informationHelp! [1] 我们从单一方法接口开始（同样，你很快就会了解到这一点的重要性）。 [2] show() 的签名（参数类型和返回类型）符合 Callable 的 call() 的签名。 [3] hello() 也符合 call() 的签名。 [4] help() 也符合，它是静态内部类中的非静态方法。 [5] assist() 是静态内部类中的静态方法。 [6] 我们将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 Callable 的 call() 方法的签名。 [7] 我们现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show()。 [8] 这是一个静态方法引用。 [9] 这是 [6] 的另一个版本：对已实例化对象的方法的引用，有时称为绑定方法引用。 [10] 最后，获取静态内部类中静态方法的引用与 [8] 中通过外部类引用相似。 上例只是简短的介绍，我们很快就能看到方法引用的所有不同形式。 Runnable接口Runnable 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 run() 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 Runnable： 1234567891011121314151617181920212223242526// functional/RunnableMethodReference.java// 方法引用与 Runnable 接口的结合使用class Go &#123; static void go() &#123; System.out.println(&quot;Go::go()&quot;); &#125;&#125;public class RunnableMethodReference &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;Anonymous&quot;); &#125; &#125;).start(); new Thread( () -&gt; System.out.println(&quot;lambda&quot;) ).start(); new Thread(Go::go).start(); &#125;&#125; 输出结果： 123AnonymouslambdaGo::go() Thread 对象将 Runnable 作为其构造函数参数，并具有会调用 run() 的方法 start()。 注意，只有匿名内部类才需要具有名为 run() 的方法。 未绑定的方法引用未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用时，我们必须先提供对象： 12345678910111213141516171819202122232425// functional/UnboundMethodReference.java// 没有方法引用的对象class X &#123; String f() &#123; return &quot;X::f()&quot;; &#125;&#125;interface MakeString &#123; String make();&#125;interface TransformX &#123; String transform(X x);&#125;public class UnboundMethodReference &#123; public static void main(String[] args) &#123; // MakeString ms = X::f; // [1] TransformX sp = X::f; X x = new X(); System.out.println(sp.transform(x)); // [2] System.out.println(x.f()); // 同等效果 &#125;&#125; 输出结果： 12X::f()X::f() 截止目前，我们看到了与对应接口签名相同的方法引用。 在 **[1]**，我们尝试把 X 的 f() 方法引用赋值给 MakeString。结果即使 make() 与 f() 具有相同的签名，编译也会报“invalid method reference”（无效方法引用）错误。 这是因为实际上还有另一个隐藏的参数：我们的老朋友 this。 你不能在没有 X 对象的前提下调用 f()。 因此，X :: f 表示未绑定的方法引用，因为它尚未“绑定”到对象。 要解决这个问题，我们需要一个 X 对象，所以我们的接口实际上需要一个额外的参数，如上例中的 TransformX。 如果将 X :: f 赋值给 TransformX，在 Java 中是允许的。我们必须做第二个心理调整——使用未绑定的引用时，函数式方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。 原因是：你需要一个对象来调用方法。 [2] 的结果有点像脑筋急转弯。我拿到未绑定的方法引用，并且调用它的transform()方法，将一个X类的对象传递给它，最后使得 x.f() 以某种方式被调用。Java知道它必须拿到第一个参数，该参数实际就是this，然后调用方法作用在它之上。 如果你的方法有更多个参数，就以第一个参数接受this的模式来处理。 12345678910111213141516171819202122232425262728293031323334// functional/MultiUnbound.java// 未绑定的方法与多参数的结合运用class This &#123; void two(int i, double d) &#123;&#125; void three(int i, double d, String s) &#123;&#125; void four(int i, double d, String s, char c) &#123;&#125;&#125;interface TwoArgs &#123; void call2(This athis, int i, double d);&#125;interface ThreeArgs &#123; void call3(This athis, int i, double d, String s);&#125;interface FourArgs &#123; void call4( This athis, int i, double d, String s, char c);&#125;public class MultiUnbound &#123; public static void main(String[] args) &#123; TwoArgs twoargs = This::two; ThreeArgs threeargs = This::three; FourArgs fourargs = This::four; This athis = new This(); twoargs.call2(athis, 11, 3.14); threeargs.call3(athis, 11, 3.14, &quot;Three&quot;); fourargs.call4(athis, 11, 3.14, &quot;Four&quot;, &#x27;Z&#x27;); &#125;&#125; 需要指出的是，我将类命名为 This，并将函数式方法的第一个参数命名为 athis，但你在生产级代码中应该使用其他名字，以防止混淆。 构造函数引用你还可以捕获构造函数的引用，然后通过引用调用该构造函数。 123456789101112131415161718192021222324252627282930313233// functional/CtorReference.javaclass Dog &#123; String name; int age = -1; // For &quot;unknown&quot; Dog() &#123; name = &quot;stray&quot;; &#125; Dog(String nm) &#123; name = nm; &#125; Dog(String nm, int yrs) &#123; name = nm; age = yrs; &#125;&#125;interface MakeNoArgs &#123; Dog make();&#125;interface Make1Arg &#123; Dog make(String nm);&#125;interface Make2Args &#123; Dog make(String nm, int age);&#125;public class CtorReference &#123; public static void main(String[] args) &#123; MakeNoArgs mna = Dog::new; // [1] Make1Arg m1a = Dog::new; // [2] Make2Args m2a = Dog::new; // [3] Dog dn = mna.make(); Dog d1 = m1a.make(&quot;Comet&quot;); Dog d2 = m2a.make(&quot;Ralph&quot;, 4); &#125;&#125; Dog 有三个构造函数，函数式接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。 注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这三个构造函数只有一个相同名称：:: new，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。 编译器知道调用函数式方法（本例中为 make()）就相当于调用构造函数。 函数式接口方法引用和 Lambda 表达式都必须被赋值，同时赋值需要类型信息才能使编译器保证类型的正确性。尤其是Lambda 表达式，它引入了新的要求。 代码示例： 1x -&gt; x.toString() 我们清楚这里返回类型必须是 String，但 x 是什么类型呢？ Lambda 表达式包含类型推导（编译器会自动推导出类型信息，避免了程序员显式地声明）。编译器必须能够以某种方式推导出 x 的类型。 下面是第二个代码示例： 1(x, y) -&gt; x + y 现在 x 和 y 可以是任何支持 + 运算符连接的数据类型，可以是两个不同的数值类型或者是 一个 String 加任意一种可自动转换为 String 的数据类型（这包括了大多数类型）。 但是，当 Lambda 表达式被赋值时，编译器必须确定 x 和 y 的确切类型以生成正确的代码。 该问题也适用于方法引用。 假设你要传递 System.out :: println 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？ 为了解决这个问题，Java 8 引入了 java.util.function 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。 在编写接口时，可以使用 @FunctionalInterface 注解强制执行此“函数式方法”模式： 12345678910111213141516171819202122232425262728293031323334353637// functional/FunctionalAnnotation.java@FunctionalInterfaceinterface Functional &#123; String goodbye(String arg);&#125;interface FunctionalNoAnn &#123; String goodbye(String arg);&#125;/*@FunctionalInterfaceinterface NotFunctional &#123; String goodbye(String arg); String hello(String arg);&#125;产生错误信息:NotFunctional is not a functional interfacemultiple non-overriding abstract methodsfound in interface NotFunctional*/public class FunctionalAnnotation &#123; public String goodbye(String arg) &#123; return &quot;Goodbye, &quot; + arg; &#125; public static void main(String[] args) &#123; FunctionalAnnotation fa = new FunctionalAnnotation(); Functional f = fa::goodbye; FunctionalNoAnn fna = fa::goodbye; // Functional fac = fa; // Incompatible Functional fl = a -&gt; &quot;Goodbye, &quot; + a; FunctionalNoAnn fnal = a -&gt; &quot;Goodbye, &quot; + a; &#125;&#125; @FunctionalInterface 注解是可选的; Java 在 main() 中把 Functional 和 FunctionalNoAnn 都当作函数式接口。 在 NotFunctional 的定义中可看到@FunctionalInterface 的作用：接口中如果有多个方法则会产生编译期错误。 仔细观察在定义 f 和 fna 时发生了什么。 Functional 和 FunctionalNoAnn 定义接口，然而被赋值的只是方法 goodbye()。首先，这只是一个方法而不是类；其次，它甚至都不是实现了该接口的类中的方法。这是添加到Java 8中的一点小魔法：如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会在后台把方法引用或 Lambda 表达式包装进实现目标接口的类的实例中。 尽管 FunctionalAnnotation 确实适合 Functional 模型，但 Java不允许我们像fac定义中的那样，将 FunctionalAnnotation 直接赋值给 Functional，因为 FunctionalAnnotation 并没有显式地去实现 Functional 接口。唯一的惊喜是，Java 8 允许我们将函数赋值给接口，这样的语法更加简单漂亮。 java.util.function 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。主要因为基本类型的存在，导致预定义的接口数量有少许增加。 如果你了解命名模式，顾名思义就能知道特定接口的作用。 以下是基本命名准则： 如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等。参数类型通过泛型添加。 如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但返回基本类型的 Supplier 接口例外。 如果返回值为基本类型，则用 To 表示，如 ToLongFunction &lt;T&gt; 和 IntToLongFunction。 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。 如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。 如果接收的两个参数类型不同，则名称中有一个 Bi。 下表描述了 java.util.function 中的目标类型（包括例外情况）： 特征 函数式方法名 示例 无参数； 无返回值 Runnable (java.lang) run() Runnable 无参数； 返回类型任意 Supplier get() getAs类型() Supplier&lt;T&gt; BooleanSupplier IntSupplier LongSupplier DoubleSupplier 无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable&lt;V&gt; 1 参数； 无返回值 Consumer accept() Consumer&lt;T&gt; IntConsumer LongConsumer DoubleConsumer 2 参数 Consumer BiConsumer accept() BiConsumer&lt;T,U&gt; 2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer&lt;T&gt; ObjLongConsumer&lt;T&gt; ObjDoubleConsumer&lt;T&gt; 1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() Function&lt;T,R&gt; IntFunction&lt;R&gt; LongFunction&lt;R&gt; DoubleFunction&lt;R&gt; ToIntFunction&lt;T&gt; ToLongFunction&lt;T&gt; ToDoubleFunction&lt;T&gt; IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator&lt;T&gt; IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator&lt;T&gt; IntBinaryOperator LongBinaryOperator DoubleBinaryOperator 2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator&lt;T&gt; 2 参数； 返回布尔型 Predicate test() Predicate&lt;T&gt; BiPredicate&lt;T,U&gt; IntPredicate LongPredicate DoublePredicate 参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 2 参数类型不同 Bi操作 (不同方法名) BiFunction&lt;T,U,R&gt; BiConsumer&lt;T,U&gt; BiPredicate&lt;T,U&gt; ToIntBiFunction&lt;T,U&gt; ToLongBiFunction&lt;T,U&gt; ToDoubleBiFunction&lt;T&gt; 此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出你所需要的函数式接口。 可以看出，在创建 java.util.function 时，设计者们做出了一些选择。 例如，为什么没有 IntComparator，LongComparator 和 DoubleComparator 呢？有 BooleanSupplier 却没有其他表示 Boolean 的接口；有通用的 BiConsumer 却没有用于 int，long 和 double 的 BiConsumers 变体（我理解他们为什么放弃这些接口）。这到底是疏忽还是有人认为其他组合使用得很少呢（他们是如何得出这个结论的）？ 你还可以看到基本类型给 Java 添加了多少复杂性。基于效率方面的考虑（问题之后有所缓解），该语言的第一版中就包含了基本类型。现在，在语言的生命周期中，我们仍然会受到语言设计选择不佳的影响。 下面枚举了基于 Lambda 表达式的所有不同 Function 变体的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// functional/FunctionVariants.javaimport java.util.function.*;class Foo &#123;&#125;class Bar &#123; Foo f; Bar(Foo f) &#123; this.f = f; &#125;&#125;class IBaz &#123; int i; IBaz(int i) &#123; this.i = i; &#125;&#125;class LBaz &#123; long l; LBaz(long l) &#123; this.l = l; &#125;&#125;class DBaz &#123; double d; DBaz(double d) &#123; this.d = d; &#125;&#125;public class FunctionVariants &#123; static Function&lt;Foo,Bar&gt; f1 = f -&gt; new Bar(f); static IntFunction&lt;IBaz&gt; f2 = i -&gt; new IBaz(i); static LongFunction&lt;LBaz&gt; f3 = l -&gt; new LBaz(l); static DoubleFunction&lt;DBaz&gt; f4 = d -&gt; new DBaz(d); static ToIntFunction&lt;IBaz&gt; f5 = ib -&gt; ib.i; static ToLongFunction&lt;LBaz&gt; f6 = lb -&gt; lb.l; static ToDoubleFunction&lt;DBaz&gt; f7 = db -&gt; db.d; static IntToLongFunction f8 = i -&gt; i; static IntToDoubleFunction f9 = i -&gt; i; static LongToIntFunction f10 = l -&gt; (int)l; static LongToDoubleFunction f11 = l -&gt; l; static DoubleToIntFunction f12 = d -&gt; (int)d; static DoubleToLongFunction f13 = d -&gt; (long)d; public static void main(String[] args) &#123; Bar b = f1.apply(new Foo()); IBaz ib = f2.apply(11); LBaz lb = f3.apply(11); DBaz db = f4.apply(11); int i = f5.applyAsInt(ib); long l = f6.applyAsLong(lb); double d = f7.applyAsDouble(db); l = f8.applyAsLong(12); d = f9.applyAsDouble(12); i = f10.applyAsInt(12); d = f11.applyAsDouble(12); i = f12.applyAsInt(13.0); l = f13.applyAsLong(13.0); &#125;&#125; 这些 Lambda 表达式尝试生成适合函数签名的最简代码。 在某些情况下，有必要进行强制类型转换，否则编译器会报截断错误。 主方法中的每个测试都显示了 Function 接口中不同类型的 apply() 方法。 每个都产生一个与其关联的 Lambda 表达式的调用。 方法引用有自己的小魔法： 12345678910111213141516171819202122232425/ functional/MethodConversion.javaimport java.util.function.*;class In1 &#123;&#125;class In2 &#123;&#125;public class MethodConversion &#123; static void accept(In1 i1, In2 i2) &#123; System.out.println(&quot;accept()&quot;); &#125; static void someOtherName(In1 i1, In2 i2) &#123; System.out.println(&quot;someOtherName()&quot;); &#125; public static void main(String[] args) &#123; BiConsumer&lt;In1,In2&gt; bic; bic = MethodConversion::accept; bic.accept(new In1(), new In2()); bic = MethodConversion::someOtherName; // bic.someOtherName(new In1(), new In2()); // Nope bic.accept(new In1(), new In2()); &#125;&#125; 输出结果： 12accept()someOtherName() 查看 BiConsumer 的文档，你会看到 accept() 方法。 实际上，如果我们将方法命名为 accept()，它就可以作为方法引用。 但是我们也可用不同的名称，比如 someOtherName()。只要参数类型、返回类型与 BiConsumer 的 accept() 相同即可。 因此，在使用函数接口时，名称无关紧要——只要参数类型和返回类型相同。 Java 会将你的方法映射到接口方法。 要调用方法，可以调用接口的函数式方法名（在本例中为 accept()），而不是你的方法名。 现在我们来看看，将方法引用应用于基于类的函数式接口（即那些不包含基本类型的函数式接口）。下面的例子中，我创建了适合函数式方法签名的最简单的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243// functional/ClassFunctionals.javaimport java.util.*;import java.util.function.*;class AA &#123;&#125;class BB &#123;&#125;class CC &#123;&#125;public class ClassFunctionals &#123; static AA f1() &#123; return new AA(); &#125; static int f2(AA aa1, AA aa2) &#123; return 1; &#125; static void f3(AA aa) &#123;&#125; static void f4(AA aa, BB bb) &#123;&#125; static CC f5(AA aa) &#123; return new CC(); &#125; static CC f6(AA aa, BB bb) &#123; return new CC(); &#125; static boolean f7(AA aa) &#123; return true; &#125; static boolean f8(AA aa, BB bb) &#123; return true; &#125; static AA f9(AA aa) &#123; return new AA(); &#125; static AA f10(AA aa1, AA aa2) &#123; return new AA(); &#125; public static void main(String[] args) &#123; Supplier&lt;AA&gt; s = ClassFunctionals::f1; s.get(); Comparator&lt;AA&gt; c = ClassFunctionals::f2; c.compare(new AA(), new AA()); Consumer&lt;AA&gt; cons = ClassFunctionals::f3; cons.accept(new AA()); BiConsumer&lt;AA,BB&gt; bicons = ClassFunctionals::f4; bicons.accept(new AA(), new BB()); Function&lt;AA,CC&gt; f = ClassFunctionals::f5; CC cc = f.apply(new AA()); BiFunction&lt;AA,BB,CC&gt; bif = ClassFunctionals::f6; cc = bif.apply(new AA(), new BB()); Predicate&lt;AA&gt; p = ClassFunctionals::f7; boolean result = p.test(new AA()); BiPredicate&lt;AA,BB&gt; bip = ClassFunctionals::f8; result = bip.test(new AA(), new BB()); UnaryOperator&lt;AA&gt; uo = ClassFunctionals::f9; AA aa = uo.apply(new AA()); BinaryOperator&lt;AA&gt; bo = ClassFunctionals::f10; aa = bo.apply(new AA(), new AA()); &#125;&#125; 请注意，每个方法名称都是随意的（如 f1()，f2()等）。正如你刚才看到的，一旦将方法引用赋值给函数接口，我们就可以调用与该接口关联的函数方法。 在此示例中为 get()、compare()、accept()、apply() 和 test()。 多参数函数式接口java.util.functional 中的接口是有限的。比如有 BiFunction，但也仅此而已。 如果需要三参数函数的接口怎么办？ 其实这些接口非常简单，很容易查看 Java 库源代码并自行创建。代码示例： 123456// functional/TriFunction.java@FunctionalInterfacepublic interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v);&#125; 简单测试，验证它是否有效： 12345678910// functional/TriFunctionTest.javapublic class TriFunctionTest &#123; static int f(int i, long l, double d) &#123; return 99; &#125; public static void main(String[] args) &#123; TriFunction&lt;Integer, Long, Double, Integer&gt; tf = TriFunctionTest::f; tf = (i, l, d) -&gt; 12; &#125;&#125; 这里我们同时测试了方法引用和 Lambda 表达式。 缺少基本类型的函数让我们重温一下 BiConsumer，看看我们如何创建缺少的针对 int，long 和 double 的各种排列： 1234567891011121314151617// functional/BiConsumerPermutations.javaimport java.util.function.*;public class BiConsumerPermutations &#123; static BiConsumer&lt;Integer, Double&gt; bicid = (i, d) -&gt; System.out.format(&quot;%d, %f%n&quot;, i, d); static BiConsumer&lt;Double, Integer&gt; bicdi = (d, i) -&gt; System.out.format(&quot;%d, %f%n&quot;, i, d); static BiConsumer&lt;Integer, Long&gt; bicil = (i, l) -&gt; System.out.format(&quot;%d, %d%n&quot;, i, l); public static void main(String[] args) &#123; bicid.accept(47, 11.34); bicdi.accept(22.45, 92); bicil.accept(1, 11L); &#125;&#125; 输出结果： 12347, 11.34000092, 22.4500001, 11 这里使用 System.out.format() 来显示。它类似于 System.out.println() 但提供了更多的显示选项。 这里，%f 表示我将 n 作为浮点值给出，%d 表示 n 是一个整数值。 这其中可以包含空格，输入 %n 会换行 — 当然使用传统的 \\n 也能换行，但 %n 是自动跨平台的，这是使用 format() 的另一个原因。 上例简单使用了包装类型，装箱和拆箱负责它与基本类型之间的来回转换。 又比如，我们可以将包装类型和Function一起使用，而不去用各种针对基本类型的预定义接口。代码示例： 12345678910// functional/FunctionWithWrapped.javaimport java.util.function.*;public class FunctionWithWrapped &#123; public static void main(String[] args) &#123; Function&lt;Integer, Double&gt; fid = i -&gt; (double)i; IntToDoubleFunction fid2 = i -&gt; i; &#125;&#125; 如果没有强制转换，则会收到错误消息：“Integer cannot be converted to Double”（Integer 无法转换为 Double），而使用 IntToDoubleFunction 就没有此类问题。 IntToDoubleFunction 接口的源代码是这样的： 1234@FunctionalInterface public interface IntToDoubleFunction &#123; double applyAsDouble(int value); &#125; 因为我们可以简单地写 Function &lt;Integer，Double&gt; 并产生正常的结果，所以用基本类型的唯一原因是可以避免传递参数和返回结果过程中的自动装箱和自动拆箱，进而提升性能。 似乎是考虑到使用频率，某些函数类型并没有预定义。 当然，如果因为缺少针对基本类型的函数式接口造成了性能问题，你可以轻松编写自己的接口（ 参考 Java 源代码）——尽管这里出现性能瓶颈的可能性不大。 高阶函数这个名字可能听起来令人生畏，但是：高阶函数（Higher-order Function）只是一个消费或产生函数的函数。 我们先来看看如何产生一个函数： 12345678910111213141516// functional/ProduceFunction.javaimport java.util.function.*;interfaceFuncSS extends Function&lt;String, String&gt; &#123;&#125; // [1]public class ProduceFunction &#123; static FuncSS produce() &#123; return s -&gt; s.toLowerCase(); // [2] &#125; public static void main(String[] args) &#123; FuncSS f = produce(); System.out.println(f.apply(&quot;YELLING&quot;)); &#125;&#125; 输出结果： 1yelling 这里，produce() 是高阶函数。 [1] 使用继承，可以轻松地为专用接口创建别名。 [2] 使用 Lambda 表达式，可以轻松地在方法中创建和返回一个函数。 要消费一个函数，消费函数需要在参数列表正确地描述函数类型。代码示例： 123456789101112131415// functional/ConsumeFunction.javaimport java.util.function.*;class One &#123;&#125;class Two &#123;&#125;public class ConsumeFunction &#123; static Two consume(Function&lt;One,Two&gt; onetwo) &#123; return onetwo.apply(new One()); &#125; public static void main(String[] args) &#123; Two two = consume(one -&gt; new Two()); &#125;&#125; 当基于消费函数生成新函数时，事情就变得相当有趣了。代码示例如下： 1234567891011121314151617181920212223242526272829// functional/TransformFunction.javaimport java.util.function.*;class I &#123; @Override public String toString() &#123; return &quot;I&quot;; &#125;&#125;class O &#123; @Override public String toString() &#123; return &quot;O&quot;; &#125;&#125;public class TransformFunction &#123; static Function&lt;I,O&gt; transform(Function&lt;I,O&gt; in) &#123; return in.andThen(o -&gt; &#123; System.out.println(o); return o; &#125;); &#125; public static void main(String[] args) &#123; Function&lt;I,O&gt; f2 = transform(i -&gt; &#123; System.out.println(i); return new O(); &#125;); O o = f2.apply(new I()); &#125;&#125; 输出结果： 12IO 在这里，transform() 生成一个与传入的函数具有相同签名的函数，但是你可以生成任何你想要的类型。 这里使用到了 Function 接口中名为 andThen() 的默认方法，该方法专门用于操作函数。 顾名思义，在调用 in 函数之后调用 andThen()（还有个 compose() 方法，它在 in 函数之前应用新函数）。 要附加一个 andThen() 函数，我们只需将该函数作为参数传递。 transform() 产生的是一个新函数，它将 in 的动作与 andThen() 参数的动作结合起来。 闭包在上一节的 ProduceFunction.java 中，我们从方法中返回 Lambda 函数。 虽然过程简单，但是有些问题必须再回过头来探讨一下。 闭包（Closure）一词总结了这些问题。 它非常重要，利用闭包可以轻松生成函数。 考虑一个更复杂的 Lambda，它使用函数作用域之外的变量。 返回该函数会发生什么？ 也就是说，当你调用函数时，它对那些 “外部 ”变量引用了什么? 如果语言不能自动解决，那问题将变得非常棘手。 能够解决这个问题的语言被称为支持闭包，或者叫作在词法上限定范围( 也使用术语变量捕获 )。Java 8 提供了有限但合理的闭包支持，我们将用一些简单的例子来研究它。 首先，下列方法返回一个函数，该函数访问对象字段和方法参数： 12345678910// functional/Closure1.javaimport java.util.function.*;public class Closure1 &#123; int i; IntSupplier makeFun(int x) &#123; return () -&gt; x + i++; &#125;&#125; 但是，仔细考虑一下，i 的这种用法并非是个大难题，因为对象很可能在你调用 makeFun() 之后就存在了——实际上，垃圾收集器几乎肯定会保留以这种方式被绑定到现存函数的对象。当然，如果你对同一个对象多次调用 makeFun() ，你最终会得到多个函数，它们共享 i 的存储空间： 123456789101112131415// functional/SharedStorage.javaimport java.util.function.*;public class SharedStorage &#123; public static void main(String[] args) &#123; Closure1 c1 = new Closure1(); IntSupplier f1 = c1.makeFun(0); IntSupplier f2 = c1.makeFun(0); IntSupplier f3 = c1.makeFun(0); System.out.println(f1.getAsInt()); System.out.println(f2.getAsInt()); System.out.println(f3.getAsInt()); &#125;&#125; 输出结果： 123012 每次调用 getAsInt() 都会增加 i，表明存储是共享的。 如果 i 是 makeFun() 的局部变量怎么办？ 在正常情况下，当 makeFun() 完成时 i 就消失。 但它仍可以编译： 12345678910// functional/Closure2.javaimport java.util.function.*;public class Closure2 &#123; IntSupplier makeFun(int x) &#123; int i = 0; return () -&gt; x + i; &#125;&#125; 由 makeFun() 返回的 IntSupplier “关住了” i 和 x，因此即使makeFun()已执行完毕，当你调用返回的函数时i 和 x仍然有效，而不是像正常情况下那样在 makeFun() 执行后 i 和x就消失了。 但请注意，我没有像 Closure1.java 那样递增 i，因为会产生编译时错误。代码示例： 123456789101112// functional/Closure3.java// &#123;WillNotCompile&#125;import java.util.function.*;public class Closure3 &#123; IntSupplier makeFun(int x) &#123; int i = 0; // x++ 和 i++ 都会报错： return () -&gt; x++ + i++; &#125;&#125; x 和 i 的操作都犯了同样的错误：被 Lambda 表达式引用的局部变量必须是 final 或者是等同 final 效果的。 如果使用 final 修饰 x和 i，就不能再递增它们的值了。代码示例： 12345678910// functional/Closure4.javaimport java.util.function.*;public class Closure4 &#123; IntSupplier makeFun(final int x) &#123; final int i = 0; return () -&gt; x + i; &#125;&#125; 那么为什么在 Closure2.java 中， x 和 i 非 final 却可以运行呢？ 这就叫做等同 final 效果（Effectively Final）。这个术语是在 Java 8 才开始出现的，表示虽然没有明确地声明变量是 final 的，但是因变量值没被改变过而实际有了 final 同等的效果。 如果局部变量的初始值永远不会改变，那么它实际上就是 final 的。 如果 x 和 i 的值在方法中的其他位置发生改变（但不在返回的函数内部），则编译器仍将视其为错误。每个递增操作则会分别产生错误消息。代码示例： 12345678910111213// functional/Closure5.java// &#123;无法编译成功&#125;import java.util.function.*;public class Closure5 &#123; IntSupplier makeFun(int x) &#123; int i = 0; i++; x++; return () -&gt; x + i; &#125;&#125; 等同 final 效果意味着可以在变量声明前加上 final 关键字而不用更改任何其余代码。 实际上它就是具备 final 效果的，只是没有明确说明。 通过在闭包中使用 final 关键字提前修饰变量 x 和 i ， 我们解决了 Closure5.java 中的问题。代码示例： 1234567891011121314// functional/Closure6.javaimport java.util.function.*;public class Closure6 &#123; IntSupplier makeFun(int x) &#123; int i = 0; i++; x++; final int iFinal = i; final int xFinal = x; return () -&gt; xFinal + iFinal; &#125;&#125; 上例中 iFinal 和 xFinal 的值在赋值后并没有改变过，因此在这里使用 final 是多余的。 如果函数式方法中使用的外部局部变量是引用，而不是基本类型的话，会是什么情况呢？我们可以把int类型改为Integer类型研究一下： 123456789101112// functional/Closure7.java// &#123;无法编译成功&#125;import java.util.function.*;public class Closure7 &#123; IntSupplier makeFun(int x) &#123; Integer i = 0; i = i + 1; return () -&gt; x + i; &#125;&#125; 编译器非常聪明地识别到变量 i 的值被更改过。 因为包装类型可能被特殊处理过了，所以我们尝试下 List： 123456789101112131415161718192021222324// functional/Closure8.javaimport java.util.*;import java.util.function.*;public class Closure8 &#123; Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123; final List&lt;Integer&gt; ai = new ArrayList&lt;&gt;(); ai.add(1); return () -&gt; ai; &#125; public static void main(String[] args) &#123; Closure8 c7 = new Closure8(); List&lt;Integer&gt; l1 = c7.makeFun().get(), l2 = c7.makeFun().get(); System.out.println(l1); System.out.println(l2); l1.add(42); l2.add(96); System.out.println(l1); System.out.println(l2); &#125;&#125; 输出结果： 1234[1][1][1, 42][1, 96] 可以看到，这次一切正常。我们改变了 List 的内容却没产生编译时错误。通过观察本例的输出结果，我们发现这看起来非常安全。这是因为每次调用 makeFun() 时，其实都会创建并返回一个全新而非共享的 ArrayList。也就是说，每个闭包都有自己独立的 ArrayList，它们之间互不干扰。 请注意我已经声明 ai 是 final 的了。尽管在这个例子中你可以去掉 final 并得到相同的结果（试试吧！）。 应用于对象引用的 final 关键字仅表示不会重新赋值引用。 它并不代表你不能修改对象本身。 下面我们来看看 Closure7.java 和 Closure8.java 之间的区别。我们看到：在 Closure7.java 中变量 i 有过重新赋值。 也许这就是触发等同 final 效果错误消息的原因。 12345678910111213// functional/Closure9.java// &#123;无法编译成功&#125;import java.util.*;import java.util.function.*;public class Closure9 &#123; Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123; List&lt;Integer&gt; ai = new ArrayList&lt;&gt;(); ai = new ArrayList&lt;&gt;(); // Reassignment return () -&gt; ai; &#125;&#125; 上例，重新赋值引用会触发错误消息。如果只修改指向的对象则没问题，只要没有其他人获得对该对象的引用（这意味着你有多个实体可以修改对象，此时事情会变得非常混乱），基本上就是安全的[^6]。 让我们回顾一下 Closure1.java。那么现在问题来了：为什么变量 i 被修改编译器却没有报错呢。 它既不是 final 的，也不是等同 final 效果的。因为 i 是外围类的成员，所以这样做肯定是安全的（除非你正在创建共享可变内存的多个函数）。是的，你可以辩称在这种情况下不会发生变量捕获（Variable Capture）。但可以肯定的是，Closure3.java 的错误消息是专门针对局部变量的。因此，规则并非只是“在 Lambda 之外定义的任何变量必须是 final 的或等同 final 效果那么简单。相反，你必须考虑捕获的变量是否是等同 final 效果的。 如果它是对象中的字段，那么它拥有独立的生存周期，并且不需要任何特殊的捕获，以便稍后在调用 Lambda 时存在。 作为闭包的内部类我们可以使用匿名内部类重写之前的例子: 123456789101112131415// functional/AnonymousClosure.javaimport java.util.function.*;public class AnonymousClosure &#123; IntSupplier makeFun(int x) &#123; int i = 0; // 同样规则的应用: // i++; // 非等同 final 效果 // x++; // 同上 return new IntSupplier() &#123; public int getAsInt() &#123; return x + i; &#125; &#125;; &#125;&#125; 实际上只要有内部类，就会有闭包（Java 8 只是简化了闭包操作）。在 Java 8 之前，变量 x 和 i 必须被明确声明为 final。在 Java 8 中，内部类的规则放宽，包括等同 final 效果。 函数组合函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。在前面的 TransformFunction.java 类中，有一个使用 andThen() 的函数组合示例。一些 java.util.function 接口中包含支持函数组合的方法 [^7]。 组合方法 支持接口 andThen(argument) 根据参数执行原始操作 Function BiFunction Consumer BiConsumer IntConsumer LongConsumer DoubleConsumer UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator BinaryOperator compose(argument) 根据参数执行原始操作 Function UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator and(argument) 短路逻辑与原始谓词和参数谓词 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate or(argument) 短路逻辑或原始谓词和参数谓词 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate negate() 该谓词的逻辑否谓词 Predicate BiPredicate IntPredicate LongPredicate DoublePredicate 下例使用了 Function 里的 compose()和 andThen()。代码示例： 123456789101112131415161718// functional/FunctionComposition.javaimport java.util.function.*;public class FunctionComposition &#123; static Function&lt;String, String&gt; f1 = s -&gt; &#123; System.out.println(s); return s.replace(&#x27;A&#x27;, &#x27;_&#x27;); &#125;, f2 = s -&gt; s.substring(3), f3 = s -&gt; s.toLowerCase(), f4 = f1.compose(f2).andThen(f3); public static void main(String[] args) &#123; System.out.println( f4.apply(&quot;GO AFTER ALL AMBULANCES&quot;)); &#125;&#125; 输出结果： 12AFTER ALL AMBULANCES_fter _ll _mbul_nces 这里我们重点看正在创建的新函数 f4。它调用 apply() 的方式与常规几乎无异。 当 f1 获得字符串时，它已经被f2 剥离了前三个字符。这是因为 compose（f2） 表示 f2 的调用发生在 f1 之前。 下例是 Predicate 的逻辑运算演示.代码示例： 1234567891011121314151617// functional/PredicateComposition.javaimport java.util.function.*;import java.util.stream.*;public class PredicateComposition &#123; static Predicate&lt;String&gt; p1 = s -&gt; s.contains(&quot;bar&quot;), p2 = s -&gt; s.length() &lt; 5, p3 = s -&gt; s.contains(&quot;foo&quot;), p4 = p1.negate().and(p2).or(p3); public static void main(String[] args) &#123; Stream.of(&quot;bar&quot;, &quot;foobar&quot;, &quot;foobaz&quot;, &quot;fongopuckey&quot;) .filter(p4) .forEach(System.out::println); &#125;&#125; 输出结果： 12foobarfoobaz p4 获取到了所有谓词并组合成一个更复杂的谓词。解读：如果字符串中不包含 bar 且长度小于 5，或者它包含 foo ，则结果为 true。 正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了下一章的内容。首先，我创建了一个字符串对象的流，然后将每个对象传递给 filter() 操作。 filter() 使用 p4 的谓词来确定对象的去留。最后我们使用 forEach() 将 println 方法引用应用在每个留存的对象上。 从输出结果我们可以看到 p4 的工作流程：任何带有 &quot;foo&quot; 的字符串都得以保留，即使它的长度大于 5。 &quot;fongopuckey&quot; 因长度超出且不包含 foo 而被丢弃。 柯里化和部分求值柯里化（Currying）的名称来自于其发明者之一 Haskell Curry。他可能是计算机领域唯一姓氏和名字都命名过重要概念的人（另外就是 Haskell 编程语言）。 柯里化意为：将一个多参数的函数，转换为一系列单参数函数。 123456789101112131415161718192021222324252627// functional/CurryingAndPartials.javaimport java.util.function.*;public class CurryingAndPartials &#123; // 未柯里化: static String uncurried(String a, String b) &#123; return a + b; &#125; public static void main(String[] args) &#123; // 柯里化的函数: Function&lt;String, Function&lt;String, String&gt;&gt; sum = a -&gt; b -&gt; a + b; // [1] System.out.println(uncurried(&quot;Hi &quot;, &quot;Ho&quot;)); Function&lt;String, String&gt; hi = sum.apply(&quot;Hi &quot;); // [2] System.out.println(hi.apply(&quot;Ho&quot;)); // 部分应用: Function&lt;String, String&gt; sumHi = sum.apply(&quot;Hup &quot;); System.out.println(sumHi.apply(&quot;Ho&quot;)); System.out.println(sumHi.apply(&quot;Hey&quot;)); &#125;&#125; 输出结果： 1234Hi HoHi HoHup HoHup Hey [1] 这一连串的箭头很巧妙。注意，在函数接口声明中，第二个参数是另一个函数。 [2] 柯里化的目的是能够通过提供一个参数来创建一个新函数，所以现在有了一个“带参函数”和剩下的 “自由函数”（free argumnet） 。实际上，你从一个双参数函数开始，最后得到一个单参数函数。 我们可以通过添加级别来柯里化一个三参数函数： 123456789101112131415161718// functional/Curry3Args.javaimport java.util.function.*;public class Curry3Args &#123; public static void main(String[] args) &#123; Function&lt;String, Function&lt;String, Function&lt;String, String&gt;&gt;&gt; sum = a -&gt; b -&gt; c -&gt; a + b + c; Function&lt;String, Function&lt;String, String&gt;&gt; hi = sum.apply(&quot;Hi &quot;); Function&lt;String, String&gt; ho = hi.apply(&quot;Ho &quot;); System.out.println(ho.apply(&quot;Hup&quot;)); &#125;&#125; 输出结果： 1Hi Ho Hup 对于每个级别的箭头级联（Arrow-cascading），你都要在类型声明中包裹另一层 Function。 处理基本类型和装箱时，请使用适当的函数式接口： 123456789101112// functional/CurriedIntAdd.javaimport java.util.function.*;public class CurriedIntAdd &#123; public static void main(String[] args) &#123; IntFunction&lt;IntUnaryOperator&gt; curriedIntAdd = a -&gt; b -&gt; a + b; IntUnaryOperator add4 = curriedIntAdd.apply(4); System.out.println(add4.applyAsInt(5)); &#125;&#125; 输出结果： 19 可以在互联网上找到更多的柯里化示例。通常它们是用 Java 之外的语言实现的，但如果理解了柯里化的基本概念，你可以很轻松地用 Java 实现它们。 纯函数式编程即使没有函数式支持，像 C 这样的基础语言，也可以按照一定的原则编写纯函数式程序。Java 8 让函数式编程更简单，不过我们要确保一切是 final 的，同时你的所有方法和函数没有副作用。因为 Java 在本质上并非是不可变语言，所以编译器对我们犯的错误将无能为力。 这种情况下，我们可以借助第三方工具，但使用 Scala 或 Clojure 这样的语言可能更简单。因为它们从一开始就是为保持不变性而设计的。你可以采用这些语言来编写你的 Java 项目的一部分。如果必须要用纯函数式编写，则可以用 Scala（需要遵循一些规则） 或 Clojure （遵循的规则更少）。虽然 Java 支持并发编程，但如果这是你项目的核心部分，你应该考虑在项目部分功能中使用 Scala 或 Clojure 之类的语言。 本章小结Lambda 表达式和方法引用并没有将 Java 转换成函数式语言，而是提供了对函数式编程的支持。这对 Java 来说是一个巨大的改进。因为这允许你编写更简洁明了，易于理解的代码。在下一章中，你会看到它们在流式编程中的应用。相信你会像我一样，喜欢上流式编程。 这些特性满足了很多羡慕Clojure、Scala 这类更函数化语言的程序员，并且阻止了Java程序员转向那些更函数化的语言（就算不能阻止，起码提供了更好的选择）。 但是，Lambdas 和方法引用远非完美，我们永远要为 Java 设计者早期的草率决定付出代价。特别是没有泛型 Lambda，所以 Lambda 在 Java 中并非一等公民。虽然我不否认 Java 8 的巨大改进，但这意味着和许多 Java 特性一样，它终究还是会让人感觉沮丧和鸡肋。 当你遇到学习困难时，请记住通过 IDE（NetBeans、IntelliJ Idea 和 Eclipse）获得帮助，因为 IDE 可以智能提示你何时使用 Lambda 表达式或方法引用，甚至有时还能为你优化代码。","categories":[],"tags":[]},{"title":"","slug":"反射、代理","date":"2021-10-18T07:13:48.267Z","updated":"2021-10-18T07:12:46.476Z","comments":true,"path":"2021/10/18/反射、代理/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E5%8F%8D%E5%B0%84%E3%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"反射、代理内聚和耦合 内聚（Cohesion）是一个模块内部各成分之间相关联程度的度量。 耦合（Coupling）是模块之间依赖程度的度量。 内聚和耦合是密切相关的，与其它模块存在强耦合的模块通常意味着弱内聚，而强内聚的模块通常意味着与其它模块之间存在弱耦合。 模块设计追求强内聚，弱耦合。 一、内聚强度内聚按强度从低到高有以下几种类型：（1） 偶然内聚。如果一个模块的各成分之间毫无关系，则称为偶然内聚。（2） 逻辑内聚。几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。如一个模块读取各种不同类型外设的输入。尽管逻辑内聚比偶然内聚合理一些，但逻辑内聚的模块各成分在功能上并无关系，即使局部功能的修改有时也会影响全局，因此这类模块的修改也比较困难。（3） 时间内聚。如果一个模块完成的功能必须在同一时间内执行（如系统初始化），但这些功能只是因为时间因素关联在一起，则称为时间内聚。（4） 过程内聚。如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。（5） 通信内聚。如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。（6） 顺序内聚。如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚。（7） 功能内聚。模块的所有成分对于完成单一的功能都是必须的，则称为功能内聚。 二、耦合强度耦合的强度依赖于以下几个因素： 一个模块对另一个模块的调用； 一个模块向另一个模块传递的数据量； 一个模块施加到另一个模块的控制的多少； 模块之间接口的复杂程度。 耦合按从强到弱的顺序可分为以下几种类型： （1）内容耦合。当一个模块直接修改或操作另一个模块的数据,或者直接转入另一个模块时，就发生了内容耦合。此时，被修改的模块完全依赖于修改它的模块。 （2）公共耦合。两个以上的模块共同引用一个全局数据项就称为公共耦合。 （3）控制耦合。一个模块在界面上传递一个信号（如开关值、标志量等）控制另一个模块，接收信号的模块的动作根据信号值进行调整，称为控制耦合。 （4）标记耦合。模块间通过参数传递复杂的内部数据结构，称为标记耦合。此数据结构的变化将使相关的模块发生变化。 （5）数据耦合。模块间通过参数传递基本类型的数据，称为数据耦合。 （6）非直接耦合。模块间没有信息传递时，属于非直接耦合。 如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，坚决避免使用内容耦合。 JAVA 反射什么是反射 Java反射机制是在运行状态中 对于任意一个类，都能知道这个类的所以属性和方法； 对于任何一个对象，都能够调用它的任何一个方法和属性； 这样动态获取新的以及动态调用对象方法的功能就叫做反射。 Class类 Class可以说是反射能够实现的基础 class关键字是在声明java类时使用的；而Class 是java JDK提供的一个类,完整路径为 java.lang.Class 对于每一种类，Java虚拟机都会初始化出一个Class类型的实例，每当我们编写并且编译一个新创建的类就会产生一个对应Class对象，并且这个Class对象会被保存在同名.class文件里。 当我们new一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。 构造器是私有的，只有JVM才可以调用这个构造函数创建Class的对象 每个class（注意class是小写，代表普通类）类，无论创建多少个实例对象，在JVM中都对应同一个Class对象。 Class是反射能够实现的基础的另一个原因是：Java反射包java.lang.reflect中的所有类都没有public构造方法，要想获得这些类实例，只能通过Class类获取。所以说如果想使用反射，必须得获得Class对象。 1. 通过对象实例获取对应Class对象Object.getClass()–对于基本类型无法使用这种方法 1234567891011121314//Returns the Class for StringClass c = &quot;foo&quot;.getClass();enum E &#123; A, B &#125;//Returns the Class corresponding to the enumeration type E.Class c = A.getClass();byte[] bytes = new byte[1024];//Returns the Class corresponding to an array with component type byte.Class c = bytes.getClass();Set&lt;String&gt; s = new HashSet&lt;String&gt;();//Returns the Class corresponding to java.util.HashSet.Class c = s.getClass(); 2.通过类的类型获取Class对象,基本类型同样可以使用这种方法 12345//The `.class` syntax returns the Class corresponding to the type `boolean`.Class c = boolean.class; //Returns the Class for StringClass c = String.class; 3. 通过类的全限定名获取Class对象， 基本类型无法使用此方法 12345Class c = Class.forName(&quot;java.lang.String&quot;);//通过Class.forName()方法加载的类，采用的是系统类加载器//对于数组比较特殊Class cDoubleArray = Class.forName(&quot;[D&quot;); //相当于double[].classClass cStringArray = Class.forName(&quot;[[Ljava.lang.String;&quot;); //相当于String[][].class 5.基本类型和void 类型的包装类可以使用TYPE字段获取 TYPE Field for Primitive Type Wrappers 123Class c = Double.TYPE; //等价于 double.class.Class c = Void.TYPE; 6. 另外还有一些反射方法可以获取Class对象，但前提是你已经获取了一个Class对象。 1Class.getSuperclass()//获得给定类的父类Class Class.getClasses() Class.getDeclaredClasses() Class.getDeclaringClass() Class.getEnclosingClass() java.lang.reflect.Field.getDeclaringClass() java.lang.reflect.Method.getDeclaringClass() java.lang.reflect.Constructor.getDeclaringClass() 一般博客都说用这三种 123Class c1 = Test.class; //这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的()Class c2 = test.getClass();// test是Test类的一个对象，这种方式是通过一个类的对象的getClass()方法获得的 (对于基本类型无法使用这种方法)Class c3 = Class.forName(&quot;com.catchu.me.reflect.Test&quot;); //这种方法是Class类调用forName方法，通过一个类的全量限定名获得（基本类型无法使用此方法） 例子：通过Class获取类修饰符和类型 11314732-2db9f6308ace3d6a.png 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TestReflection &#123; private static final String TAG = &quot;Reflection&quot;; public void testReflection() &#123; Class&lt;?&gt; c = HashMap.class; //获取类名 Log.d(TAG, &quot;Class : &quot; + c.getCanonicalName()); //获取类限定符 Log.d(TAG, &quot;Modifiers : &quot; + Modifier.toString(c.getModifiers())); //获取类泛型信息 TypeVariable[] tv = c.getTypeParameters(); if (tv.length != 0) &#123; StringBuilder parameter = new StringBuilder(&quot;Parameters : &quot;); for (TypeVariable t : tv) &#123; parameter.append(t.getName()); parameter.append(&quot; &quot;); &#125; Log.d(TAG, parameter.toString()); &#125; else &#123; Log.d(TAG, &quot; -- No Type Parameters --&quot;); &#125; //获取类实现的所有接口 Type[] intfs = c.getGenericInterfaces(); if (intfs.length != 0) &#123; StringBuilder interfaces = new StringBuilder(&quot;Implemented Interfaces : &quot;); for (Type intf : intfs)&#123; interfaces.append(intf.toString()); interfaces.append(&quot; &quot;); &#125; Log.d(TAG, interfaces.toString()); &#125; else &#123; Log.d(TAG, &quot; -- No Implemented Interfaces --&quot;); &#125; //获取类继承数上的所有父类 List&lt;Class&gt; l = new ArrayList&lt;&gt;(); printAncestor(c, l); if (l.size() != 0) &#123; StringBuilder inheritance = new StringBuilder(&quot;Inheritance Path : &quot;); for (Class&lt;?&gt; cl : l)&#123; inheritance.append(cl.getCanonicalName()); inheritance.append(&quot; &quot;); &#125; Log.d(TAG, inheritance.toString()); &#125; else &#123; Log.d(TAG, &quot; -- No Super Classes --%n%n&quot;); &#125; //获取类的注解(只能获取到 RUNTIME 类型的注解) Annotation[] ann = c.getAnnotations(); if (ann.length != 0) &#123; StringBuilder annotation = new StringBuilder(&quot;Annotations : &quot;); for (Annotation a : ann)&#123; annotation.append(a.toString()); annotation.append(&quot; &quot;); &#125; Log.d(TAG, annotation.toString()); &#125; else &#123; Log.d(TAG, &quot; -- No Annotations --%n%n&quot;); &#125; &#125; private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) &#123; Class&lt;?&gt; ancestor = c.getSuperclass(); if (ancestor != null) &#123; l.add(ancestor); printAncestor(ancestor, l); &#125; &#125;&#125; //打印结果如下 12345603-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Class : java.util.HashMap03-29 15:04:23.070 27826-27826/com.example.ming.testproject D/Reflection: Modifiers : public03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Parameters : K V 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Implemented Interfaces : java.util.Map&lt;K, V&gt; interface java.lang.Cloneable interface java.io.Serializable 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: Inheritance Path : java.util.AbstractMap java.lang.Object 03-29 15:04:23.071 27826-27826/com.example.ming.testproject D/Reflection: -- No Annotations -- MemberReflection defines an interface java.lang.reflect.Member which is implemented by java.lang.reflect.Field, java.lang.reflect.Method, and java.lang.reflect.Constructor . 类成员主要包括构造函数，变量和方法，Java中的操作基本都和这三者相关，而Member的这三个实现类就分别对应他们。 java.lang.reflect.Field ：对应类变量 java.lang.reflect.Method ：对应类方法 java.lang.reflect.Constructor ：对应类构造函数 反射就是通过这三个类才能在运行时改变对象状态。 突破java的权限检测 Java运行时会进行访问权限检查，private类型的变量无法进行直接访问 java.lang.reflect.AccessibleObject AccessibleObject为我们提供了一个方法 setAccessible(boolean flag)，该方法的作用就是可以取消 Java 语言访问权限检查。所以任何继承AccessibleObject的类的对象都可以使用该方法取消 Java 语言访问权限检查。 所以任何继承AccessibleObject的类的对象都可以使用该方法取消 Java 语言访问权限检查。（final类型变量也可以通过这种办法访问） 1public final class Field extends AccessibleObject implements Member Field、Method和Constructor都是继承AccessibleObject 2.0 例子建一个测试类 12345678910111213141516171819202122232425262728293031323334353637public class Cat &#123; public static final String TAG = Cat.class.getSimpleName(); private String name; @Deprecated public int age; public Cat(String name, int age)&#123; this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void eat(String food)&#123; Log.d(TAG, &quot;eat food &quot; + food); &#125; public void eat(String... foods)&#123; StringBuilder s = new StringBuilder(); for(String food : foods)&#123; s.append(food); s.append(&quot; &quot;); &#125; Log.d(TAG, &quot;eat food &quot; + s.toString()); &#125; public void sleep()&#123; Log.d(TAG, &quot;sleep&quot;); &#125; @Override public String toString() &#123; return &quot;name = &quot; + name + &quot; age = &quot; + age; &#125;&#125; 2.1 Field通过Field你可以访问给定对象的类变量，包括获取变量的类型、修饰符、注解、变量名、变量的值或者重新设置变量值，即使变量是private的。 获取Field Class提供了4种方法获得给定类的Field。 getDeclaredField(String name) 获取指定的变量（只要是声明的变量都能获得，包括private） getField(String name) 获取指定的变量（只能获得public的） getDeclaredFields() 获取所有声明的变量（包括private） getFields() 获取所有的public变量 获取变量类型、修饰符、注解 12345678910111213141516171819202122232425262728public void testField()&#123; Class c = Cat.class; Field[] fields = c.getDeclaredFields(); for(Field f : fields)&#123; StringBuilder builder = new StringBuilder(); //获取名称 builder.append(&quot;filed name = &quot;); builder.append(f.getName()); //获取类型 builder.append(&quot; type = &quot;); builder.append(f.getType()); //获取修饰符 builder.append(&quot; modifiers = &quot;); builder.append(Modifier.toString(f.getModifiers())); //获取注解 Annotation[] ann = f.getAnnotations(); if (ann.length != 0) &#123; builder.append(&quot; annotations = &quot;); for (Annotation a : ann)&#123; builder.append(a.toString()); builder.append(&quot; &quot;); &#125; &#125; else &#123; builder.append(&quot; -- No Annotations --&quot;); &#125; Log.d(TAG, builder.toString()); &#125; &#125; 打印结果： 123filed name = age type = int modifiers = public annotations = @java.lang.Deprecated() filed name = name type = class java.lang.String modifiers = private -- No Annotations --filed name = TAG type = class java.lang.String modifiers = public static final -- No Annotations -- 获取、设置变量值 通过反射获取并改变Cat的name和age. 12345678910111213141516171819202122public void testField()&#123; Cat cat = new Cat(&quot;Tom&quot;, 2); Class c = cat.getClass(); try &#123; //注意获取private变量时，需要用getDeclaredField Field fieldName = c.getDeclaredField(&quot;name&quot;); Field fieldAge = c.getField(&quot;age&quot;); fieldName.setAccessible(true); //反射获取名字, 年龄 String name = (String) fieldName.get(cat); int age = fieldAge.getInt(cat); Log.d(TAG, &quot;before set, Cat name = &quot; + name + &quot; age = &quot; + age); //反射重新set名字和年龄 fieldName.set(cat, &quot;Timmy&quot;); fieldAge.setInt(cat, 3); Log.d(TAG, &quot;after set, Cat &quot; + cat.toString()); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; 2.2 Method获取Method Class依然提供了4种方法获取Method: getDeclaredMethod(String name, Class... parameterTypes) 根据方法名获得指定的方法， 参数name为方法名，参数parameterTypes为方法的参数类型，如 getDeclaredMethod(“eat”, String.class) getMethod(String name, Class... parameterTypes) 根据方法名获取指定的public方法，其它同上 getDeclaredMethods() 获取所有声明的方法 getMethods() 获取所有的public方法 注意：获取带参数方法时，如果参数类型错误会报NoSuchMethodException，对于参数是泛型的情况，泛型须当成Object处理（Object.class） 获取方法返回类型 getReturnType() 获取目标方法返回类型对应的Class对象 getGenericReturnType() 获取目标方法返回类型对应的Type对象 这两个方法有啥区别呢？ getReturnType()返回类型为Class，getGenericReturnType()返回类型为Type; Class实现Type。 返回值为普通简单类型如Object, int, String等，getGenericReturnType()返回值和getReturnType()一样 例如 public String function1() 那么各自返回值为： getReturnType() : class java.lang.String getGenericReturnType() : class java.lang.String 返回值为泛型 例如public T function2() 那么各自返回值为： getReturnType() : class java.lang.Object getGenericReturnType() : T 返回值为参数化类型 例如public Class&lt;String&gt; function3() 那么各自返回值为： getReturnType() : class java.lang.Class getGenericReturnType() : java.lang.Class&lt;java.lang.String&gt; 其实反射中所有形如getGenericXXX()的方法规则都与上面所述类似。 获取方法参数类型 getParameterTypes() 获取目标方法各参数类型对应的Class对象 getGenericParameterTypes() 获取目标方法各参数类型对应的Type对象 返回值为数组，它俩区别同上 “方法返回类型的区别” 。 获取方法声明抛出的异常的类型 getExceptionTypes() 获取目标方法抛出的异常类型对应的Class对象 getGenericExceptionTypes() 获取目标方法抛出的异常类型对应的Type对象 返回值为数组，区别同上 获取方法参数名称 .class文件中默认不存储方法参数名称，如果想要获取方法参数名称，需要在编译的时候加上-parameters参数。(构造方法的参数获取方法同样) 12345678910//这里的m可以是普通方法Method，也可以是构造方法Constructor//获取方法所有参数Parameter[] params = m.getParameters();for (int i = 0; i &lt; params.length; i++) &#123; Parameter p = params[i]; p.getType(); //获取参数类型 p.getName(); //获取参数名称，如果编译时未加上`-parameters`，返回的名称形如`argX`, X为参数在方法声明中的位置，从0开始 p.getModifiers(); //获取参数修饰符 p.isNamePresent(); //.class文件中是否保存参数名称, 编译时加上`-parameters`返回true,反之flase&#125; 获取方法修饰符 方法与Filed等类似 1method.getModifiers(); 几个Method方法 method.isVarArgs() //判断方法参数是否是可变参数 12public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) //返回truepublic Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; [] parameterTypes) //返回flase method.isSynthetic() //判断是否是复合方法，个人理解复合方法是编译期间编译器生成的方法，并不是源代码中有的方法 method.isBridge() //判断是否是桥接方法，桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法。可以参考https://www.cnblogs.com/zsg88/p/7588929.html 通过反射调用方法 反射通过Method的invoke()方法来调用目标方法。第一个参数为需要调用的目标类对象，如果方法为static的，则该参数为null。后面的参数都为目标方法的参数值，顺序与目标方法声明中的参数顺序一致。 12public native Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException 注意：如果方法是private的，可以使用method.setAccessible(true)方法绕过权限检查 12345678910111213141516171819202122Class&lt;?&gt; c = Cat.class; try &#123; //构造Cat实例 Constructor constructor = c.getConstructor(String.class, int.class); Object cat = constructor.newInstance( &quot;Jack&quot;, 3); //调用无参方法 Method sleep = c.getDeclaredMethod(&quot;sleep&quot;); sleep.invoke(cat); //调用定项参数方法 Method eat = c.getDeclaredMethod(&quot;eat&quot;, String.class); eat.invoke(cat, &quot;grass&quot;); //调用不定项参数方法 //不定项参数可以当成数组来处理 Class[] argTypes = new Class[] &#123; String[].class &#125;; Method varargsEat = c.getDeclaredMethod(&quot;eat&quot;, argTypes); String[] foods = new String[]&#123; &quot;grass&quot;, &quot;meat&quot; &#125;; varargsEat.invoke(cat, (Object)foods); &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; 被调用的方法本身所抛出的异常在反射中都会以InvocationTargetException抛出。换句话说，反射调用过程中如果异常InvocationTargetException抛出，说明反射调用本身是成功的，因为这个异常是目标方法本身所抛出的异常。 2.3 Constructor这节主要介绍如何通过反射访问构造方法并通过构造方法构建新的对象。 获取构造方法 和Method一样，Class也为Constructor提供了4种方法获取 getDeclaredConstructor(Class... parameterTypes) 获取指定构造函数，参数parameterTypes为构造方法的参数类型 getConstructor(Class... parameterTypes) 获取指定public构造函数，参数parameterTypes为构造方法的参数类型 getDeclaredConstructors() 获取所有声明的构造方法 getConstructors() 获取所有的public构造方法 构造方法的名称、限定符、参数、声明的异常等获取方法都与Method类似，请参照Method 创建对象 通过反射有两种方法可以创建对象： java.lang.reflect.Constructor.newInstance() Class.newInstance() 一般来讲，我们优先使用第一种方法；那么这两种方法有何异同呢？ Class.newInstance()仅可用来调用无参的构造方法；Constructor.newInstance()可以调用任意参数的构造方法 Class.newInstance()会将构造方法中抛出的异常不作处理原样抛出;Constructor.newInstance()会将构造方法中抛出的异常都包装成InvocationTargetException抛出。 Class.newInstance()需要拥有构造方法的访问权限;Constructor.newInstance()可以通过setAccessible(true)方法绕过访问权限访问private构造方法。 例子在Method一节已经写过，这里直接截取过来 1234567Class&lt;?&gt; c = Cat.class;try &#123; Constructor constructor = c.getConstructor(String.class, int.class); Cat cat = (Cat) con structor.newInstance( &quot;Jack&quot;, 3);&#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; e.printStackTrace();&#125; 注意：反射不支持自动封箱，传入参数时要小心（自动封箱是在编译期间的，而反射在运行期间） 2.4 数组和枚举数组和枚举也是对象，但是在反射中，对数组和枚举的创建、访问和普通对象有那么一丢丢的不同，所以Java反射为数组和枚举提供了一些特定的API接口。 2.4.1 数组数组类型 数组类型：数组本质是一个对象，所以它也有自己的类型。 数组类型：数组本质是一个对象，所以它也有自己的类型。 例如对于int[] intArray，数组类型为class [I。数组类型中的[个数代表数组的维度，例如[代表一维数组，[[代表二维数组；[后面的字母代表数组元素类型，I代表int，一般为类型的首字母大写(long类型例外，为J)。 123456789class [B //byte类型一维数组class [S //short类型一维数组class [I //int类型一维数组class [C //char类型一维数组class [J //long类型一维数组，J代表long类型，因为L被引用对象类型占用了class [F //float类型一维数组class [D //double类型一维数组class [Lcom.dada.Season //引用类型一维数组class [[Ljava.lang.String //引用类型二维数组 1234567//获取一个变量的类型Class&lt;?&gt; c = field.getType();//判断该变量是否为数组if (c.isArray()) &#123; //获取数组的元素类型 c.getComponentType()&#125; 创建和初始化数组 Java反射为我们提供了java.lang.reflect.Array类用来创建和初始化数组。 12345678//创建数组， 参数componentType为数组元素的类型，后面不定项参数的个数代表数组的维度，参数值为数组长度Array.newInstance(Class&lt;?&gt; componentType, int... dimensions)//设置数组值，array为数组对象，index为数组的下标，value为需要设置的值Array.set(Object array, int index, int value)//获取数组的值，array为数组对象，index为数组的下标Array.get(Object array, int index) 例子,用反射创建int[] array = new int[]&#123;1, 2&#125; 123Object array = Array.newInstance(int.class, 2);Array.setInt(array , 0, 1);Array.setInt(array , 1, 2); 注意：反射支持对数据自动加宽，但不允许数据narrowing(变窄?真难翻译)。意思是对于上述set方法，你可以在int类型数组中 set short类型数据，但不可以set long类型数据，否则会报IllegalArgumentException。 多维数组 Java反射没有提供能够直接访问多维数组元素的API，但你可以把多维数组当成数组的数组处理。 12345678Object matrix = Array.newInstance(int.class, 2, 2);Object row0 = Array.get(matrix, 0);Object row1 = Array.get(matrix, 1);Array.setInt(row0, 0, 1);Array.setInt(row0, 1, 2);Array.setInt(row1, 0, 3);Array.setInt(row1, 1, 4); 或者 1234567891011Object matrix = Array.newInstance(int.class, 2);Object row0 = Array.newInstance(int.class, 2);Object row1 = Array.newInstance(int.class, 2);Array.setInt(row0, 0, 1);Array.setInt(row0, 1, 2);Array.setInt(row1, 0, 3);Array.setInt(row1, 1, 4);Array.set(matrix, 0, row0);Array.set(matrix, 1, row1); 2.4.2 枚举 枚举隐式继承自java.lang.Enum，Enum继承自Object，所以枚举本质也是一个类，也可以有成员变量，构造方法，方法等；对于普通类所能使用的反射方法，枚举都能使用；另外java反射额外提供了几个方法为枚举服务。 Class.isEnum() Indicates whether this class represents an enum type Class.getEnumConstants() Retrieves the list of enum constants defined by the enum in the order they’re declared java.lang.reflect.Field.isEnumConstant() Indicates whether this field represents an element of an enumerated type 2.5 其它方法注解中常用的方法： 1234Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解 Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解 Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合 获取Class对象其它信息的方法： 1234567891011121314151617boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型 boolean isArray = class1.isArray();//判断是否是集合类boolean isAnnotation = class1.isAnnotation();//判断是否是注解类 boolean isInterface = class1.isInterface();//判断是否是接口类 boolean isEnum = class1.isEnum();//判断是否是枚举类 boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类 boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰 String className = class1.getName();//获取class名字 包含包名路径 Package aPackage = class1.getPackage();//获取class的包信息 String simpleName = class1.getSimpleName();//获取class类名 int modifiers = class1.getModifiers();//获取class访问权限 Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();//内部类 Class&lt;?&gt; declaringClass = class1.getDeclaringClass();//外部类ClassLoader ClassLoader = class1.getClassLoader() //返回类加载器getSuperclass()：获取某类所有的父类 getInterfaces()：获取某类所有实现的接口 2.6 静态元素静态的类，方法，字段和实例类，方法，字段完全不一样，因为它无需初始化类就可以直接使用。 3 反射缺点 性能问题。因为反射是在运行时而不是在编译时，所有不会利用到编译优化，同时因为是动态生成，因此，反射操作的效率要比那些非反射操作低得多。 安全问题。使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了。 代码问题。由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 出处： 作者：凯玲之恋链接：https://www.jianshu.com/p/10c29883eac1来源：简书 IDEA如何添加项目启动参数前言 有时候我们需要在程序运行的时候对程序设置环境变量，恰巧我也遇到了这个问题，所以在此记录一下IDEA是如何设置环境变量的。 作用 -Dproperty=Value 该参数通常用于设置系统级全局变量值，如配置文件路径，保证该属性在程序中任何地方都可访问。当然，也可以通过在程序中使用System.setProperty进行设置。 注意： 1、如果-Dproperty=value的value中包含空格，可以将value使用引号引起来。例如：-Dmyname=&quot;hello world&quot;。 2、如果配置了-Dproperty=value参数，又在程序中使用了System.setProperty对同一个变量进行设置，那么以程序中的设置为准。 针对某个Application设置 1、Run–&gt;Edit Configurations 2、选中要添加JVM参数的Application，然后在Configuration里面的VM options中输入想要添加的系统参数 针对所有的Application设置 1、找到IDEA安装目录中的bin目录 2、找到idea.exe.vmoptions文件 3、打开该文件编辑并保存。 ​ 优先级关系 代码中的配置&gt;Application中的配置&gt;全局配置 JAVA代理关于Java中的动态代理，我们首先需要了解的是一种常用的设计模式–代理模式，而对于代理，根据创建代理类的时间点，又可以分为静态代理和动态代理。 一、代理模式 代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。在后面我会 解释这种间接性带来的好处。代理模式结构图（图片来自《大话设计模式》）： 二、静态代理 1、静态代理 静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 2、静态代理简单实现 根据上面代理模式的类图，来写一个简单的静态代理的例子。我这儿举一个比较粗糙的例子，假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费， 班长就是学生的代理。 首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。 12345678/** * 创建Person接口 * @author Gonjan */public interface Person &#123; //上交班费 void giveMoney();&#125; Student类实现Person接口。Student可以具体实施上交班费的动作。 1234567891011public class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void giveMoney() &#123; System.out.println(name + &quot;上交班费50元&quot;); &#125;&#125; StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。 123456789101112131415161718192021/** * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为 * @author Gonjan * */public class StudentsProxy implements Person&#123; //被代理的学生 Student stu; public StudentsProxy(Person stu) &#123; // 只代理学生对象 if(stu.getClass() == Student.class) &#123; this.stu = (Student)stu; &#125; &#125; //代理上交班费，调用被代理学生的上交班费行为 public void giveMoney() &#123; stu.giveMoney(); &#125;&#125; 下面测试一下，看如何使用代理模式： 123456789101112public class StaticProxyTest &#123; public static void main(String[] args) &#123; //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成 Person zhangsan = new Student(&quot;张三&quot;); //生成代理对象，并将张三传给代理对象 Person monitor = new StudentsProxy(zhangsan); //班长代理上交班费 monitor.giveMoney(); &#125;&#125; 运行结果： 这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。 代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，加入班长在帮张三上交班费之前想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到： 1234567891011121314151617public class StudentsProxy implements Person&#123; //被代理的学生 Student stu; public StudentsProxy(Person stu) &#123; // 只代理学生对象 if(stu.getClass() == Student.class) &#123; this.stu = (Student)stu; &#125; &#125; //代理上交班费，调用被代理学生的上交班费行为 public void giveMoney() &#123; System.out.println(&quot;张三最近学习有进步！&quot;); stu.giveMoney(); &#125;&#125; 运行结果： 可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。 三、动态代理 1.动态代理 代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法： 12345public void giveMoney() &#123; //调用被代理方法前加入处理方法 beforeMethod(); stu.giveMoney(); &#125; 这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。 2、动态代理简单实现 在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。 创建一个动态代理对象步骤，具体代码见后面： 创建一个InvocationHandler对象 12//创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu); 使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass 1Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;); 获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor 1Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class); 通过构造器constructor来创建一个动态实例stuProxy 1Person stuProxy = (Person) cons.newInstance(stuHandler); 就此，一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化： 1234 //创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法 Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler); 到这里肯定都会很疑惑，这动态代理到底是如何执行的，是如何通过代理对象来执行被代理对象的方法的，先不急，我们先看看一个简单的完整的动态代理的例子。还是上面静态代理的例子，班长需要帮学生代交班费。****首先是定义一个Person接口: 12345678/** * 创建Person接口 * @author Gonjan */public interface Person &#123; //上交班费 void giveMoney();&#125; 创建需要被代理的实际类： 123456789101112131415161718public class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void giveMoney() &#123; try &#123; //假设数钱花了一秒时间 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot;上交班费50元&quot;); &#125;&#125; 再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。 1234567891011121314public class MonitorUtil &#123; private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;(); public static void start() &#123; tl.set(System.currentTimeMillis()); &#125; //结束时打印耗时 public static void finish(String methodName) &#123; long finishTime = System.currentTimeMillis(); System.out.println(methodName + &quot;方法耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;); &#125;&#125; 创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。 再再invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。 123456789101112131415161718192021222324public class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123; //invocationHandler持有的被代理对象 T target; public StuInvocationHandler(T target) &#123; this.target = target; &#125; /** * proxy:代表动态代理对象 * method：代表正在执行的方法 * args：代表调用目标方法时传入的实参 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;); */ //代理过程中插入监测方法,计算该方法耗时 MonitorUtil.start(); Object result = method.invoke(target, args); MonitorUtil.finish(method.getName()); return result; &#125;&#125; 做完上面的工作后，我们就可以具体来创建动态代理对象了，上面简单介绍了如何创建动态代理对象，我们使用简化的方式创建动态代理对象： 12345678910111213141516public class ProxyTest &#123; public static void main(String[] args) &#123; //创建一个实例对象，这个对象是被代理的对象 Person zhangsan = new Student(&quot;张三&quot;); //创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan); //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法 Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler); //代理执行上交班费的方法 stuProxy.giveMoney(); &#125;&#125; 我们执行这个ProxyTest类，先想一下，我们创建了一个需要被代理的学生张三，将zhangsan对象传给了stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数了的，上面也有说到所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。 运行结果： 上面说到，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。 动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行。带着这些问题，我们就需要对java动态代理的源码进行简要的分析，弄清楚其中缘由。 四、动态代理原理分析 1、Java动态代理创建出来的动态代理类 上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125;&#125; 其实，我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容： 123456789byte[] classFile = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, Student.class.getInterfaces());String path = &quot;G:/javacode/javase/Test/bin/proxy/StuProxy.class&quot;;try(FileOutputStream fos = new FileOutputStream(path)) &#123; fos.write(classFile); fos.flush(); System.out.println(&quot;代理类class文件写入成功&quot;);&#125; catch (Exception e) &#123; System.out.println(&quot;写文件错误&quot;);&#125; 对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.Person;public final class $Proxy0 extends Proxy implements Person&#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; /** *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白 *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个 *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。 * *super(paramInvocationHandler)，是调用父类Proxy的构造方法。 *父类持有：protected InvocationHandler h; *Proxy构造方法： * protected Proxy(InvocationHandler h) &#123; * Objects.requireNonNull(h); * this.h = h; * &#125; * */ public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; //这个静态块本来是在最后的，我把它拿到前面来，方便描述 static &#123; try &#123; //看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管 m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); m3 = Class.forName(&quot;proxy.Person&quot;).getMethod(&quot;giveMoney&quot;, new Class[0]); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125; /** * *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。 *this.h.invoke(this, m3, null);这里简单，明了。 *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象， *再联系到InvacationHandler中的invoke方法。嗯，就是这样。 */ public final void giveMoney() throws &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; //注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。&#125; jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。 我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。 代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。 特点动态生成的代理类本身的一些特点 包：如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect或private，所以除 public之外就是默认的package访问级别，那么它将被定义在该接口所在包，这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问； 类修饰符：该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承； 类名：格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。 类继承关系：Proxy 类是它的父类，这个规则适用于所有由 Proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口; 代理类实例的一些特点： 每个实例都会关联一个InvocationHandler(调用处理器对象)，在代理类实例上调用其代理接口中声明的方法时，最终都会由InvocationHandler的invoke方法执行； java.lang.Object中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString； 被代理接口的一组特点： 要注意不能有重复的接口 接口对于类装载器必须可见，否则类装载器将无法链接它们 被代理的所有非 public 的接口必须在同一个包中，接口的数目不能超过65535 五、总结生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。","categories":[],"tags":[]},{"title":"","slug":"多态","date":"2021-10-18T07:13:48.265Z","updated":"2021-10-18T07:12:44.310Z","comments":true,"path":"2021/10/18/多态/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E5%A4%9A%E6%80%81/","excerpt":"","text":"多态多态的意义其中之一就是上转型 如果针对于每个导出类我们都进行重写： 1234567891011121314151617181920212223242526272829303132333435class Stringed extends Instrument &#123; public void play(Note n) &#123; print(&quot;Stringed.play() &quot; + n); &#125;&#125;class Brass extends Instrument &#123; public void play(Note n) &#123; print(&quot;Brass.play() &quot; + n); &#125;&#125;public class Music2 &#123; public static void tune(Wind i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tune(Stringed i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tune(Brass i) &#123; i.play(Note.MIDDLE_C); &#125; public static void main(String[] args) &#123; Wind flute = new Wind(); Stringed violin = new Stringed(); Brass frenchHorn = new Brass(); tune(flute); // No upcasting tune(violin); tune(frenchHorn); &#125;&#125; /* Output:Wind.play() MIDDLE_CStringed.play() MIDDLE_CBrass.play() MIDDLE_C*///:~ 这将是很大的工作量，并且如果这样做，如果有时我们忘记了去重写父类的方法，那么我们就会收获未知的错误，因为他会继承父类的方法，并且不会有任何的提示。 方法调用绑定将一个方法调用和一个方法主体关联起来被称作绑定，若在程序执行前进行绑定，叫做前期绑定，它是面向过程的语言中默认的绑定方式，例如C语言。 12345678910111213public class Music &#123; public static void tune(Instrument i) &#123; // ... i.play(Note.MIDDLE_C); &#125; public static void main(String[] args) &#123; Wind flute = new Wind(); tune(flute); // Upcasting &#125;&#125; /* Output:Wind.play() MIDDLE_C*///:~ 像这段代码，编译器如何确定传入的Instrument就是Wind类型而非其他类型呢？ 主要是通过后期绑定: 后期绑定是在运行时根据对象的类型进行绑定，后期绑定也叫做动态绑定或运行时绑定，如果一种语言想实现后期绑定，就必须有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法，后期绑定机制随编程语言的不同而有所不同，但是不管怎么样都必须在对象中安置某种“类型信息”。 java中除了static 和 final 方法之外，其他所有的方法都是后期绑定，也就是说，final方法可以有效地解除动态绑定，即我们不需要这个类继续被继承。 产生正确的行为向上转型可以像以下的语句一样简单： Shape s= new Circle(); 如果这时你调用一个基类的方法，它会调用的是导出类中重写过的方法（如果存在）而非基类的方法。这里就是动态绑定的体现。 多态使用的注意事项1、私有方法不可覆盖2、域与静态方法，静态方法不具有多态的意义构造器与多态构造器实际上是static方法，只不过它的static声明是隐式的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Meal &#123; Meal() &#123; print(&quot;Meal()&quot;); &#125;&#125;class Bread &#123; Bread() &#123; print(&quot;Bread()&quot;); &#125;&#125;class Cheese &#123; Cheese() &#123; print(&quot;Cheese()&quot;); &#125;&#125;class Lettuce &#123; Lettuce() &#123; print(&quot;Lettuce()&quot;); &#125;&#125;class Lunch extends Meal &#123; Lunch() &#123; print(&quot;Lunch()&quot;); &#125;&#125;class PortableLunch extends Lunch &#123; PortableLunch() &#123; print(&quot;PortableLunch()&quot;);&#125;&#125;public class Sandwich extends PortableLunch &#123; private Bread b = new Bread(); private Cheese c = new Cheese(); private Lettuce l = new Lettuce(); public Sandwich() &#123; print(&quot;Sandwich()&quot;); &#125; public static void main(String[] args) &#123; new Sandwich(); &#125;&#125; /* Output:Meal()Lunch()PortableLunch()Bread()Cheese()Lettuce()Sandwich()*///:~ 这个例子实际上展示了构造器的构造顺序 继承与清理如果我们在清理方法上对导出类做了一些特殊的处理，但是同时还要用到基类中的方法，这时候一定要记得使用super()来调用父类的清理方法，否则不会进行。 构造器内部多态方法的行为123456789101112131415161718192021222324252627282930313233class Glyph &#123; void draw() &#123; print(&quot;Glyph.draw()&quot;); &#125; Glyph() &#123; print(&quot;Glyph() before draw()&quot;); draw(); print(&quot;Glyph() after draw()&quot;); &#125;&#125; class RoundGlyph extends Glyph &#123; private int radius = 1; RoundGlyph(int r) &#123; radius = r; print(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius); &#125; void draw() &#123; print(&quot;RoundGlyph.draw(), radius = &quot; + radius); &#125;&#125; public class PolyConstructors &#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125; /* Output:Glyph() before draw()RoundGlyph.draw(), radius = 0 由动态绑定得到的答案。Glyph() after draw()RoundGlyph.RoundGlyph(), radius = 5*///:~ 正如这个例子，在glyph的构造方法中调用了draw，这是一个需要被覆盖的方法。 这里引出了实际的初始化过程，首先第一步，将所有要分配的空间都初始化为二进制的0； 在构造器内唯一能够安全调用的方法就是基类中的final方法。 向下转型与运行时类型识别RTTI 运行时类型识别 1234567891011121314151617181920212223242526272829class Useful &#123; public void f() &#123;&#125; public void g() &#123;&#125;&#125;class MoreUseful extends Useful &#123; public void f() &#123;&#125; public void g() &#123;&#125; public void u() &#123;&#125; public void v() &#123;&#125; public void w() &#123;&#125;&#125; public class RTTI &#123; public static void main(String[] args) &#123; Useful[] x = &#123; new Useful(), new MoreUseful() &#125;; x[0].f(); x[1].g(); // Compile time: method not found in Useful: //! x[1].u(); ((MoreUseful)x[1]).u(); // Downcast/RTTI ((MoreUseful)x[0]).u(); // Exception thrown &#125;&#125; ///:~ 实际上直接调用x[1].u()是无法实现的。但是向下转型之后可以进行调用，但是X[0]即使向下转型也无法调用。 java 中 add/offer，element/peek，remove/polljava LinkedList和Queue中 add/offer，element/peek，remove/poll中的三个方法均为重复的方法，在选择使用时不免有所疑惑，这里简单区别一下： 1、add()和offer()区别: add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！ 2、poll()和remove()区别： remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。 3、element() 和 peek() 区别： element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。 **下面是Java中Queue的一些常用方法：add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常offer 添加一个元素并返回true 如果队列已满，则返回falsepoll 移除并返问队列头部的元素 如果队列为空，则返回nullpeek 返回队列头部的元素 如果队列为空，则返回nullput 添加一个元素 如果队列满，则阻塞take 移除并返回队列头部的元素 ** 接口抽象类和抽象方法1abstract void f(); 这种方法是不完整的，仅有方法声明而没有方法体，包含抽象方法的类叫做抽象类，如果一个类包含一个或者多个抽象方法，该类必须被限定为抽象类。","categories":[],"tags":[]},{"title":"","slug":"常量、构造函数","date":"2021-10-18T07:13:48.263Z","updated":"2021-10-18T07:13:03.611Z","comments":true,"path":"2021/10/18/常量、构造函数/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E5%B8%B8%E9%87%8F%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"","text":"0717直接常量当生成一个常量时，如果我们想要明确的八进制、十六进制或是单精度双精度，可以像以下方式一样声明： 123int i1=0x2f; //十六进制int i2=0144; //八进制char c = 0xffff //最大的char值 指数记数法编译器通常会把指数记数法，形如： 1float f=1e-43; 当做是双精度数来处理，所以此时应该明确声明 1float f=1e-43f; 这样就可以确保f为一个单精度数了。 关于继承Java，子类不是必须重写父类所有方法的，分为以下两种情况： 父类方法为抽象方法时，子类必须重写（实现）所有父类的抽象方法（或者放到当前类的子类实现也可以）； 父类方法为普通方法时，子类可以重写父类方法，也可以不重写。 一个类实现接口和继承抽象类对于抽象方法的实现原则是相同的： 如果这个类是个普通类，那么必须实现这个接口/抽象类的所有抽象方法； 如果这个类是个抽象类，那么不必实现这个接口/抽象类的抽象方法，因为抽象类中可以定义抽象方法。 关于截尾和舍入12float a=29.7;int b=(int)a; 答案得到的是29，float和double在转型为整数型时，总是对数字进行结尾操作，如果要得到四舍五入之后的结果，需要使用Math.round()函数。 Math.ceil() //向上取整 Math.floor() //向下取整 Java的goto语句通过使用标签来进行实现： 1234567891011Lable:whilecodeblock&#123;coutinue Lable; Lable1: whilecodeblock1 &#123; continue Lable; break Lable1; &#125;&#125; 以上就是加入了两个循环代码块，并且利用Label和Label1进行跳转操作。 方法重载主要利用不同的参数列表来构造一个对象。主要就是通过不同的参数列表来实现不同的构造（也可以通过返回值类型的不同来进行方法的重载）。 12345678910111213141516171819202122Class person()&#123; person() &#123;&#125; person(int age) &#123; &#125; person(int age,int id) &#123; &#125; int person() &#123; &#125; char person() &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class PrimitiveOverloading &#123; void f1(char x) &#123; printnb(&quot;f1(char) &quot;); &#125; void f1(byte x) &#123; printnb(&quot;f1(byte) &quot;); &#125; void f1(short x) &#123; printnb(&quot;f1(short) &quot;); &#125; void f1(int x) &#123; printnb(&quot;f1(int) &quot;); &#125; void f1(long x) &#123; printnb(&quot;f1(long) &quot;); &#125; void f1(float x) &#123; printnb(&quot;f1(float) &quot;); &#125; void f1(double x) &#123; printnb(&quot;f1(double) &quot;); &#125; void f2(byte x) &#123; printnb(&quot;f2(byte) &quot;); &#125; void f2(short x) &#123; printnb(&quot;f2(short) &quot;); &#125; void f2(int x) &#123; printnb(&quot;f2(int) &quot;); &#125; void f2(long x) &#123; printnb(&quot;f2(long) &quot;); &#125; void f2(float x) &#123; printnb(&quot;f2(float) &quot;); &#125; void f2(double x) &#123; printnb(&quot;f2(double) &quot;); &#125; void f3(short x) &#123; printnb(&quot;f3(short) &quot;); &#125; void f3(int x) &#123; printnb(&quot;f3(int) &quot;); &#125; void f3(long x) &#123; printnb(&quot;f3(long) &quot;); &#125; void f3(float x) &#123; printnb(&quot;f3(float) &quot;); &#125; void f3(double x) &#123; printnb(&quot;f3(double) &quot;); &#125; void f4(int x) &#123; printnb(&quot;f4(int) &quot;); &#125; void f4(long x) &#123; printnb(&quot;f4(long) &quot;); &#125; void f4(float x) &#123; printnb(&quot;f4(float) &quot;); &#125; void f4(double x) &#123; printnb(&quot;f4(double) &quot;); &#125; void f5(long x) &#123; printnb(&quot;f5(long) &quot;); &#125; void f5(float x) &#123; printnb(&quot;f5(float) &quot;); &#125; void f5(double x) &#123; printnb(&quot;f5(double) &quot;); &#125; void f6(float x) &#123; printnb(&quot;f6(float) &quot;); &#125; void f6(double x) &#123; printnb(&quot;f6(double) &quot;); &#125; void f7(double x) &#123; printnb(&quot;f7(double) &quot;); &#125; void testConstVal() &#123; printnb(&quot;5: &quot;); f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5); print(); &#125; void testChar() &#123; char x = &#x27;x&#x27;; printnb(&quot;char: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); &#125; void testByte() &#123; byte x = 0; printnb(&quot;byte: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); &#125; void testShort() &#123; short x = 0; printnb(&quot;short: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); &#125; void testInt() &#123; int x = 0; printnb(&quot;int: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); &#125; void testLong() &#123; long x = 0; printnb(&quot;long: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); &#125; void testFloat() &#123; float x = 0; printnb(&quot;float: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); &#125; void testDouble() &#123; double x = 0; printnb(&quot;double: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); &#125; public static void main(String[] args) &#123; PrimitiveOverloading p = new PrimitiveOverloading(); p.testConstVal(); p.testChar(); p.testByte(); p.testShort(); p.testInt(); p.testLong(); p.testFloat(); p.testDouble(); &#125;&#125; /* Output:5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double)short: f1(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double)int: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)long: f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double)float: f1(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double)double: f1(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double)*///:~ 像上述代码段所展示的一样，在重载实现时，如果传入的数据类型小于方法生命中的形式参数类型，实际数据类型就会被提升，char类型不太一样，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Demotion &#123; void f1(char x) &#123; print(&quot;f1(char)&quot;); &#125; void f1(byte x) &#123; print(&quot;f1(byte)&quot;); &#125; void f1(short x) &#123; print(&quot;f1(short)&quot;); &#125; void f1(int x) &#123; print(&quot;f1(int)&quot;); &#125; void f1(long x) &#123; print(&quot;f1(long)&quot;); &#125; void f1(float x) &#123; print(&quot;f1(float)&quot;); &#125; void f1(double x) &#123; print(&quot;f1(double)&quot;); &#125; void f2(char x) &#123; print(&quot;f2(char)&quot;); &#125; void f2(byte x) &#123; print(&quot;f2(byte)&quot;); &#125; void f2(short x) &#123; print(&quot;f2(short)&quot;); &#125; void f2(int x) &#123; print(&quot;f2(int)&quot;); &#125; void f2(long x) &#123; print(&quot;f2(long)&quot;); &#125; void f2(float x) &#123; print(&quot;f2(float)&quot;); &#125; void f3(char x) &#123; print(&quot;f3(char)&quot;); &#125; void f3(byte x) &#123; print(&quot;f3(byte)&quot;); &#125; void f3(short x) &#123; print(&quot;f3(short)&quot;); &#125; void f3(int x) &#123; print(&quot;f3(int)&quot;); &#125; void f3(long x) &#123; print(&quot;f3(long)&quot;); &#125; void f4(char x) &#123; print(&quot;f4(char)&quot;); &#125; void f4(byte x) &#123; print(&quot;f4(byte)&quot;); &#125; void f4(short x) &#123; print(&quot;f4(short)&quot;); &#125; void f4(int x) &#123; print(&quot;f4(int)&quot;); &#125; void f5(char x) &#123; print(&quot;f5(char)&quot;); &#125; void f5(byte x) &#123; print(&quot;f5(byte)&quot;); &#125; void f5(short x) &#123; print(&quot;f5(short)&quot;); &#125; void f6(char x) &#123; print(&quot;f6(char)&quot;); &#125; void f6(byte x) &#123; print(&quot;f6(byte)&quot;); &#125; void f7(char x) &#123; print(&quot;f7(char)&quot;); &#125; void testDouble() &#123; double x = 0; print(&quot;double argument:&quot;); f1(x);f2((float)x);f3((long)x);f4((int)x); f5((short)x);f6((byte)x);f7((char)x); &#125; public static void main(String[] args) &#123; Demotion p = new Demotion(); p.testDouble(); &#125;&#125; /* Output:double argument:f1(double)f2(float)f3(long)f4(int)f5(short)f6(byte)f7(char)*///:~ 从上面的代码中可以看出，同时如果传入的参数类型过于大，就需要用到强制转换转换为参数类型比较低的类型进行执行。 this关键字的使用12345678910111213141516171819202122232425class Person &#123; public void eat(Apple apple) &#123; Apple peeled = apple.getPeeled(); System.out.println(&quot;Yummy&quot;); &#125;&#125;class Peeler &#123; static Apple peel(Apple apple) &#123; // ... remove peel return apple; // Peeled &#125;&#125;class Apple &#123; Apple getPeeled() &#123; return Peeler.peel(this); &#125;&#125;public class PassingThis &#123; public static void main(String[] args) &#123; new Person().eat(new Apple()); &#125;&#125; /* Output:Yummy*///:~ this的用法： 如上述例子一样，我们通过一个剥皮器进行苹果的剥皮，通过this关键字传入apple对象，在一个对象内部实现类中传入当前对象，如果是实例化之后的实例则传入的是当前实例。 返回当前对象的引用 1return this; 在构造函数中调用构造函数 12345678910111213141516171819202122232425262728293031323334353637public class Flower &#123; int petalCount = 0; String s = &quot;initial value&quot;; Flower(int petals) &#123; petalCount = petals; print(&quot;Constructor w/ int arg only, petalCount= &quot; + petalCount); &#125; Flower(String ss) &#123; print(&quot;Constructor w/ String arg only, s = &quot; + ss); s = ss; &#125; Flower(String s, int petals) &#123; this(petals);//! this(s); // Can&#x27;t call two! this.s = s; // Another use of &quot;this&quot; print(&quot;String &amp; int args&quot;); &#125; Flower() &#123; this(&quot;hi&quot;, 47); print(&quot;default constructor (no args)&quot;); &#125; void printPetalCount() &#123;//! this(11); // Not inside non-constructor! print(&quot;petalCount = &quot; + petalCount + &quot; s = &quot;+ s); &#125; public static void main(String[] args) &#123; Flower x = new Flower(); x.printPetalCount(); &#125;&#125; /* Output:Constructor w/ int arg only, petalCount= 47String &amp; int argsdefault constructor (no args)petalCount = 47 s = hi*///:~ finalize()的使用在知道了java的垃圾回收机制之后，就可以明白finalize()是如何使用的了，在进行垃圾回收准备回收一个对应的类时，我们在类中定义的finalize()函数会被调用，在finalize()中进行一些特殊的操作，并且在下一次垃圾回收的时候才会真正回收对象所占用的内存。也就是用于在垃圾回收时刻做一些重要的清理工作。但是一般使用较少，如果我们真的需要在不使用某个对象的时候进行清理操作，我们需要自己定义一个特定的函数进行清理操作。 构造器初始化12345678public class test&#123; int i; test() &#123; i=1; &#125;&#125; 那么这里的变量i在对象的值就在创建时被设为0，在进行构造器初始化之后i的值变为1。 构造器初始化顺序在类的内部，变量定义的先后顺序决定了初始化的先后顺序，即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。 1234567891011121314151617181920212223242526272829303132// When the constructor is called to create a// Window object, you&#x27;ll see a message:class Window &#123; Window(int marker) &#123; print(&quot;Window(&quot; + marker + &quot;)&quot;); &#125;&#125;class House &#123; Window w1 = new Window(1); // Before constructor House() &#123; // Show that we&#x27;re in the constructor: print(&quot;House()&quot;); w3 = new Window(33); // Reinitialize w3 &#125; Window w2 = new Window(2); // After constructor void f() &#123; print(&quot;f()&quot;); &#125; Window w3 = new Window(3); // At end&#125;public class OrderOfInitialization &#123; public static void main(String[] args) &#123; House h = new House(); h.f(); // Shows that construction is done &#125;&#125; /* Output:Window(1)Window(2)Window(3)House()Window(33)f()*///:~ 在上面的代码段中，虽然构造函数直接调用了Window(33)，但是我们可以发现，Window(33)在所有变量定义的代码都被调用之后才进行了构造函数的调用。 静态数据的初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Bowl &#123; Bowl(int marker) &#123; print(&quot;Bowl(&quot; + marker + &quot;)&quot;); &#125; void f1(int marker) &#123; print(&quot;f1(&quot; + marker + &quot;)&quot;); &#125;&#125;class Table &#123; static Bowl bowl1 = new Bowl(1); Table() &#123; print(&quot;Table()&quot;); bowl2.f1(1); &#125; void f2(int marker) &#123; print(&quot;f2(&quot; + marker + &quot;)&quot;); &#125; static Bowl bowl2 = new Bowl(2);&#125;class Cupboard &#123; Bowl bowl3 = new Bowl(3); static Bowl bowl4 = new Bowl(4); Cupboard() &#123; print(&quot;Cupboard()&quot;); bowl4.f1(2); &#125; void f3(int marker) &#123; print(&quot;f3(&quot; + marker + &quot;)&quot;); &#125; static Bowl bowl5 = new Bowl(5);&#125;public class StaticInitialization &#123; public static void main(String[] args) &#123; print(&quot;Creating new Cupboard() in main&quot;); new Cupboard(); print(&quot;Creating new Cupboard() in main&quot;); new Cupboard(); table.f2(1); cupboard.f3(1); &#125; static Table table = new Table(); static Cupboard cupboard = new Cupboard();&#125;/* Output:Bowl(1)Bowl(2)Table()f1(1)Bowl(4)Bowl(5)Bowl(3)Cupboard()f1(2)Creating new Cupboard() in mainBowl(3)Cupboard()f1(2)Creating new Cupboard() in mainBowl(3)Cupboard()f1(2)f2(1)f3(1)*///:~ 观察以上的初始化过程，我们可以发现，bowl4和bowl5为static类型，bowl3非static，在输出中，可以看到Bowl4和Bowl5比Bowl3更早被调用，在包含主函数的类中，static对象优先调用生成，我们可以看到Bowl(1)和Bowl(2)更早被输出之后才是构造函数的Table()被输出，在之后又是紧随static Table的static Cupboard被构造出，之后再进行对应非静态变量实例的初始化，静态对象的非构造函数的执行顺序就按一般的函数执行顺序进行。 非静态实例的初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445class Mug &#123; Mug(int marker) &#123; print(&quot;Mug(&quot; + marker + &quot;)&quot;); &#125; void f(int marker) &#123; print(&quot;f(&quot; + marker + &quot;)&quot;); &#125;&#125;public class Mugs &#123; Mug mug1; Mug mug2; &#123; mug1 = new Mug(1); mug2 = new Mug(2); print(&quot;mug1 &amp; mug2 initialized&quot;); &#125; Mugs() &#123; print(&quot;Mugs()&quot;); &#125; Mugs(int i) &#123; print(&quot;Mugs(int)&quot;); &#125; public static void main(String[] args) &#123; print(&quot;Inside main()&quot;); new Mugs(); print(&quot;new Mugs() completed&quot;); new Mugs(1); print(&quot;new Mugs(1) completed&quot;); &#125;&#125; /* Output:Inside main()Mug(1)Mug(2)mug1 &amp; mug2 initializedMugs()new Mugs() completedMug(1)Mug(2)mug1 &amp; mug2 initializedMugs(int)new Mugs(1) completed*///:~ 从上面可以看出，虽然没有static类型的对象实例，但是由于在Mugs类中通过一个代码段新建了mug1，mug2两个实例，所以在执行创建Mugs实例时会先执行赋值的语句，并且在这里，与两个赋值语句同属一个代码段的print语句也被执行了。（这是匿名函数类中的一个值得注意的用法）","categories":[],"tags":[]},{"title":"","slug":"测试私有方法和静态方法","date":"2021-10-18T07:13:48.261Z","updated":"2021-10-18T07:12:25.989Z","comments":true,"path":"2021/10/18/测试私有方法和静态方法/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","excerpt":"","text":"testStatic mock = new testStatic();//私有方法的mock testStatic spy=PowerMockito.spy(mock); // PowerMockito.when(spy,”testPrivate”,any()).thenReturn(true); Object is=method.invoke(mock,””); Assert.assertEquals(is,true); Object say = Whitebox.invokeMethod(mock, &quot;testPrivate&quot;, &quot;hi&quot;); Assert.assertEquals(say,true); 测试私有方法（可行） InOutValue inOutValueMock= Mockito.mock(OrderInOutValue.class); IndexOptionOrder indexOptionOrderMock=Mockito.mock(IndexOptionOrder.class); OptionOrder optionOrder=Mockito.mock(OptionOrder.class); // Comm commMock=mock(Comm.class); inOutValueMock.setPortfolioKey(&quot;11&quot;); inOutValueMock.setFuturePositionKey(&quot;111&quot;); inOutValueMock.setAssetKey(&quot;1111&quot;); PowerMockito.mockStatic(Comm.class); PowerMockito.when(Comm.isFutExchange(Mockito.any())).thenReturn(true); PowerMockito.whenNew(IndexOptionOrder.class).withArguments(Mockito.any()).thenReturn(indexOptionOrderMock); Assert.assertEquals(OptionUtil.getOptionTransaction(inOutValueMock),indexOptionOrderMock); PowerMockito.when(Comm.isFutExchange(Mockito.any())).thenReturn(false); PowerMockito.whenNew(OptionOrder.class).withArguments(Mockito.any()).thenReturn(optionOrder); Assert.assertEquals(OptionUtil.getOptionTransaction(inOutValueMock),optionOrder); 测试 静态方法 （可行）","categories":[],"tags":[]},{"title":"","slug":"ThreadLocal 源码","date":"2021-10-18T07:13:48.246Z","updated":"2021-10-18T07:12:32.489Z","comments":true,"path":"2021/10/18/ThreadLocal 源码/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/ThreadLocal%20%E6%BA%90%E7%A0%81/","excerpt":"","text":"ThreadLocal 源码解读1首先每个threadLocal类都具有一个其自身的threadlocalhashcode，通过nextHashCode(),获取下一个hashcode，Thread 可以具有初始值，通过withInitial进行设置，它的入参是一个supplier 接口。 get 函数通过拿到当前Thread ，然后再通过getMap 函数得到当前Thread 绑定的threadlocals (一个ThreadLocalMap)，Map 的Entry是各种各样的ThreadLocal类，通过对应的ThreadLocal类得到对应的Entry，如果找到了当前ThreadLocal对象(即threadLocalHashCode映射在了table中，并且table中对应位置不为空)。如果没有找到通过这个函数进行下一步的处理 getEntryAfterMiss(key, i, e) 12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; 这个函数通过一个while循环，只要没找到存在的Entry，就继续通过一定的策略进行查找。","categories":[],"tags":[]},{"title":"","slug":"static代码段 addall aslist","date":"2021-10-18T07:13:48.245Z","updated":"2021-10-18T07:12:39.301Z","comments":true,"path":"2021/10/18/static代码段 addall aslist/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/static%E4%BB%A3%E7%A0%81%E6%AE%B5%20addall%20aslist/","excerpt":"","text":"static代码段仅仅在类被初始化的时候加载一次，之后都不再加载,比如业务代码中的： 123456789101112131415161718192021222324252627static &#123; MessageFieldTagNums.addAll(Arrays.asList( &quot;7193&quot;, &quot;7198&quot;, &quot;7300&quot;, &quot;7301&quot;)); MessageFieldTags.addAll(Arrays.asList( &quot;ErrorMessage&quot;, &quot;ClientConnInfo&quot;, &quot;FunctionInfo&quot;, &quot;CheckInfo&quot;)); MessageFieldTypes.addAll(Arrays.asList( (Class) ErrorMessage.class, (Class) ClientConnInfo.class, (Class) FunctionInfo.class, (Class) CheckInfo.class)); MessageFieldDataTypes.addAll(Arrays.asList( DataType.COMPONENT, DataType.COMPONENT, DataType.COMPONENT, DataType.COMPONENT)); MessageFieldRequireds.addAll(Arrays.asList( Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.FALSE)); &#125; 那么类什么时候首次被加载呢？就是在主类中（包含main函数的类）new一个对象实例（包含static代码段的类没有main函数）或者此类有main函数，那么在进入main函数的时候首次加载此类，加载类的时候初始化顺序如下：如有父类，则按照静态成员、静态代码段、静态方法、一般成员、父类构造函数的顺序初始化父类，然后是子类的初始化，顺序与上述相同。 addAll()函数addAll()函数 123456789public boolean addAll(Collection c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 可以看到其中用了一个arraycopy函数，这个函数是System函数内的，它调用的是一个本地的native函数，就是系统定义的接口， 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 在这个接口里，将内存某块地址的一些信息直接复制到内存的另一块中，所以针对于比较大的数据量来说，addAll()方法可以拥有更快的速度。 所谓addAll()就是将一个数据集合内的信息直接赋给另一个数据集合。 ArrayList的asList()函数asList使用的一些注意事项： 由API可以知道返回的List称得上是对数组的一个引用，对List或者数组的更改都会传递给另一方。 使用这个函数还需注意不能使用基本数据类型的数组作为参数，因为函数参数是泛型，故需要引用数据类型的数组作为参数，若使用基本数据类型数组则会将该数组作为单个元素存进List中（因为数组也是引用数据类型）。若要使用基本数据类型数组，只能使用它们的包装类数组。 该List不能使用add()和remove()函数，虽然他有这两个函数，因为它的大小是固定的，所以这两个函数只有定义而没有实现，使用这两个函数会报java.lang.UnsupportedOperationException错误 可以通过创建一个ArrayList对象并以List作为参数使用addAll函数，就可以获得一个可以add和remove的列表了。如： 1234567891011121314151617181920212223242526public class aslistest &#123; public static void main(String[] args) &#123; Integer[] a = &#123;1,2,3,4&#125;; List list = Arrays.asList(a); for(Object i:list) &#123; System.out.println((int)i); &#125; a[2]=7; for(Object i:list) &#123; System.out.println((int)i); &#125; &#125;&#125;/* output12341274*/","categories":[],"tags":[]},{"title":"","slug":"Lambda表达式","date":"2021-10-18T07:13:48.243Z","updated":"2021-10-18T07:13:13.530Z","comments":true,"path":"2021/10/18/Lambda表达式/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"Lambda表达式Lambda 表达式是使用最小可能语法编写的函数定义： Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。 Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。 我们在 Strategize.java 中看到了一个 Lambda 表达式，但还有其他语法变体： 12345678910111213141516171819202122232425262728293031323334353637// functional/LambdaExpressions.javainterface Description &#123; String brief();&#125;interface Body &#123; String detailed(String head);&#125;interface Multi &#123; String twoArg(String head, Double d);&#125;public class LambdaExpressions &#123; static Body bod = h -&gt; h + &quot; No Parens!&quot;; // [1] static Body bod2 = (h) -&gt; h + &quot; More details&quot;; // [2] static Description desc = () -&gt; &quot;Short info&quot;; // [3] static Multi mult = (h, n) -&gt; h + n; // [4] static Description moreLines = () -&gt; &#123; // [5] System.out.println(&quot;moreLines()&quot;); return &quot;from moreLines()&quot;; &#125;; public static void main(String[] args) &#123; System.out.println(bod.detailed(&quot;Oh!&quot;)); System.out.println(bod2.detailed(&quot;Hi!&quot;)); System.out.println(desc.brief()); System.out.println(mult.twoArg(&quot;Pi! &quot;, 3.14159)); System.out.println(moreLines.brief()); &#125;&#125; 输出结果： 123456Oh! No Parens!Hi! More detailsShort infoPi! 3.14159moreLines()from moreLines() 我们从三个接口开始，每个接口都有一个单独的方法（很快就会理解它的重要性）。但是，每个方法都有不同数量的参数，以便演示 Lambda 表达式语法。 任何 Lambda 表达式的基本语法是： 参数。 接着 -&gt;，可视为“产出”。 -&gt; 之后的内容都是方法体。 [1] 当只用一个参数，可以不需要括号 ()。 然而，这是一个特例。 [2] 正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。 [3] 如果没有参数，则必须使用括号 () 表示空参数列表。 [4] 对于多个参数，将参数列表放在括号 () 中。 到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 return 关键字是非法的。 这是 Lambda 表达式简化相应语法的另一种方式。 **[5] **如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 return。 Lambda 表达式通常比匿名内部类产生更易读的代码，因此我们将在本书中尽可能使用它们。","categories":[],"tags":[]},{"title":"","slug":"JAVA容器类","date":"2021-10-18T07:13:48.241Z","updated":"2021-10-18T07:13:15.954Z","comments":true,"path":"2021/10/18/JAVA容器类/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/JAVA%E5%AE%B9%E5%99%A8%E7%B1%BB/","excerpt":"","text":"JAVA容器类基本概念Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口： 集合（Collection） ：一个独立元素的序列，这些元素都服从一条或多条规则。List 必须以插入的顺序保存元素， Set 不能包含重复元素， Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。 映射（Map） ： 一组成对的“键值对”对象，允许使用键来查找值。 ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 map 允许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作字典（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 Map 是强大的编程工具。 尽管并非总是可行，但在理想情况下，你编写的大部分代码都在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个 List ： 1List&lt;Apple&gt; apples = new ArrayList&lt;&gt;(); 请注意， ArrayList 已经被向上转型为了 List ，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样： 1List&lt;Apple&gt; apples = new LinkedList&lt;&gt;(); 因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。 这种方式并非总是有效的，因为某些具体类有额外的功能。例如， LinkedList 具有 List 接口中未包含的额外方法，而 TreeMap 也具有在 Map 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。 Collection 接口概括了序列的概念——一种存放一组对象的方式。下面是个简单的示例，用 Integer 对象填充了一个 Collection （这里用 ArrayList 表示），然后打印集合中的每个元素： 123456789101112131415// collections/SimpleCollection.javaimport java.util.*;public class SimpleCollection &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; c = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 10; i++) c.add(i); // Autoboxing for(Integer i : c) System.out.print(i + &quot;, &quot;); &#125;&#125;/* Output:0, 1, 2, 3, 4, 5, 6, 7, 8, 9,*/ 这个例子仅使用了 Collection 中的方法（即 add() ），所以使用任何继承自 Collection 的类的对象都可以正常工作。但是 ArrayList 是最基本的序列类型。 add() 方法的名称就表明它是在 Collection 中添加一个新元素。但是，文档中非常详细地叙述到 add() “要确保这个 Collection 包含指定的元素。”这是因为考虑到了 Set 的含义，因为在 Set中，只有当元素不存在时才会添加元素。在使用 ArrayList ，或任何其他类型的 List 时，add() 总是表示“把它放进去”，因为 List 不关心是否存在重复元素。 可以使用 for-in 语法来遍历所有的 Collection ，就像这里所展示的那样。在本章的后续部分，还将学习到一个更灵活的概念，迭代器。 添加元素组在 java.util 包中的 Arrays 和 Collections 类中都有很多实用的方法，可以在一个 Collection 中添加一组元素。 Arrays.asList() 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 List 对象。 Collections.addAll() 方法接受一个 Collection 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 Collection 中。下边的示例展示了这两个方法，以及更通用的 、所有 Collection 类型都包含的addAll() 方法： 123456789101112131415161718192021// collections/AddingGroups.java// Adding groups of elements to Collection objectsimport java.util.*;public class AddingGroups &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5)); Integer[] moreInts = &#123; 6, 7, 8, 9, 10 &#125;; collection.addAll(Arrays.asList(moreInts)); // Runs significantly faster, but you can&#x27;t // construct a Collection this way: Collections.addAll(collection, 11, 12, 13, 14, 15); Collections.addAll(collection, moreInts); // Produces a list &quot;backed by&quot; an array: List&lt;Integer&gt; list = Arrays.asList(16,17,18,19,20); list.set(1, 99); // OK -- modify an element // list.add(21); // Runtime error; the underlying // array cannot be resized. &#125;&#125; Collection 的构造器可以接受另一个 Collection，用它来将自身初始化。因此，可以使用 Arrays.asList() 来为这个构造器产生输入。但是， Collections.addAll() 运行得更快，而且很容易构建一个不包含元素的 Collection ，然后调用 Collections.addAll() ，因此这是首选方式。 Collection.addAll() 方法只能接受另一个 Collection 作为参数，因此它没有 Arrays.asList() 或 Collections.addAll() 灵活。这两个方法都使用可变参数列表。 也可以直接使用 Arrays.asList() 的输出作为一个 List，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 List上调用 add() 或 remove()，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误： 12345678910111213141516171819202122232425262728293031// collections/AsListInference.javaimport java.util.*;class Snow &#123;&#125;class Powder extends Snow &#123;&#125;class Light extends Powder &#123;&#125;class Heavy extends Powder &#123;&#125;class Crusty extends Snow &#123;&#125;class Slush extends Snow &#123;&#125;public class AsListInference &#123; public static void main(String[] args) &#123; List&lt;Snow&gt; snow1 = Arrays.asList( new Crusty(), new Slush(), new Powder()); //- snow1.add(new Heavy()); // Exception List&lt;Snow&gt; snow2 = Arrays.asList( new Light(), new Heavy()); //- snow2.add(new Slush()); // Exception List&lt;Snow&gt; snow3 = new ArrayList&lt;&gt;(); Collections.addAll(snow3, new Light(), new Heavy(), new Powder()); snow3.add(new Crusty()); // Hint with explicit type argument specification: List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList( new Light(), new Heavy(), new Slush()); //- snow4.add(new Powder()); // Exception &#125;&#125; 在 snow4 中，注意 Arrays.asList() 中间的“暗示”（即 &lt;Snow&gt; ），告诉编译器 Arrays.asList() 生成的结果 List 类型的实际目标类型是什么。这称为显式类型参数说明（explicit type argument specification）。 列表ListList承诺将元素保存在特定的序列中。 List 接口在 Collection 的基础上添加了许多方法，允许在 List 的中间插入和删除元素。 有两种类型的 List ： 基本的 ArrayList ，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。 LinkedList ，它通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。 LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。 下面的示例导入 typeinfo.pets ，超前使用了类型信息一章中的类库。这个类库包含了 Pet 类层次结构，以及用于随机生成 Pet 对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点： 有一个 Pet 类，以及 Pet 的各种子类型。 静态的 Pets.arrayList() 方法返回一个填充了随机选取的 Pet 对象的 ArrayList： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// collections/ListFeatures.javaimport typeinfo.pets.*;import java.util.*;public class ListFeatures &#123; public static void main(String[] args) &#123; Random rand = new Random(47); List&lt;Pet&gt; pets = Pets.list(7); System.out.println(&quot;1: &quot; + pets); Hamster h = new Hamster(); pets.add(h); // Automatically resizes System.out.println(&quot;2: &quot; + pets); System.out.println(&quot;3: &quot; + pets.contains(h)); pets.remove(h); // Remove by object Pet p = pets.get(2); System.out.println( &quot;4: &quot; + p + &quot; &quot; + pets.indexOf(p)); Pet cymric = new Cymric(); System.out.println(&quot;5: &quot; + pets.indexOf(cymric)); System.out.println(&quot;6: &quot; + pets.remove(cymric)); // Must be the exact object: System.out.println(&quot;7: &quot; + pets.remove(p)); System.out.println(&quot;8: &quot; + pets); pets.add(3, new Mouse()); // Insert at an index System.out.println(&quot;9: &quot; + pets); List&lt;Pet&gt; sub = pets.subList(1, 4); System.out.println(&quot;subList: &quot; + sub); System.out.println(&quot;10: &quot; + pets.containsAll(sub)); Collections.sort(sub); // In-place sort System.out.println(&quot;sorted subList: &quot; + sub); // Order is not important in containsAll(): System.out.println(&quot;11: &quot; + pets.containsAll(sub)); Collections.shuffle(sub, rand); // Mix it up System.out.println(&quot;shuffled subList: &quot; + sub); System.out.println(&quot;12: &quot; + pets.containsAll(sub)); List&lt;Pet&gt; copy = new ArrayList&lt;&gt;(pets); sub = Arrays.asList(pets.get(1), pets.get(4)); System.out.println(&quot;sub: &quot; + sub); copy.retainAll(sub); System.out.println(&quot;13: &quot; + copy); copy = new ArrayList&lt;&gt;(pets); // Get a fresh copy copy.remove(2); // Remove by index System.out.println(&quot;14: &quot; + copy); copy.removeAll(sub); // Only removes exact objects System.out.println(&quot;15: &quot; + copy); copy.set(1, new Mouse()); // Replace an element System.out.println(&quot;16: &quot; + copy); copy.addAll(2, sub); // Insert a list in the middle System.out.println(&quot;17: &quot; + copy); System.out.println(&quot;18: &quot; + pets.isEmpty()); pets.clear(); // Remove all elements System.out.println(&quot;19: &quot; + pets); System.out.println(&quot;20: &quot; + pets.isEmpty()); pets.addAll(Pets.list(4)); System.out.println(&quot;21: &quot; + pets); Object[] o = pets.toArray(); System.out.println(&quot;22: &quot; + o[3]); Pet[] pa = pets.toArray(new Pet[0]); System.out.println(&quot;23: &quot; + pa[3].id()); &#125;&#125;/* Output:1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]3: true4: Cymric 25: -16: false7: true8: [Rat, Manx, Mutt, Pug, Cymric, Pug]9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]subList: [Manx, Mutt, Mouse]10: truesorted subList: [Manx, Mouse, Mutt]11: trueshuffled subList: [Mouse, Manx, Mutt]12: truesub: [Mouse, Pug]13: [Mouse, Pug]14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]15: [Rat, Mutt, Cymric, Pug]16: [Rat, Mouse, Cymric, Pug]17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]18: false19: []20: true21: [Manx, Cymric, Rat, EgyptianMau]22: EgyptianMau23: 14*/ 打印行都编了号，因此可从输出追溯到源代码。 第 1 行输出展示了原始的由 Pet 组成的 List 。 与数组不同， List 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。在第 2 行输出中可以看到添加一个 Hamster 的结果，该对象将被追加到列表的末尾。 可以使用 contains() 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 remove() 方法。同样，如果有一个对象的引用，可以使用 indexOf() 在 List 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。 当确定元素是否是属于某个 List ，寻找某个元素的索引，以及通过引用从 List 中删除元素时，都会用到 equals() 方法（根类 Object 的一个方法）。每个 Pet 被定义为一个唯一的对象，所以即使列表中已经有两个 Cymrics ，如果再创建一个新的 Cymric 对象并将其传递给 indexOf() 方法，结果仍为 -1 （表示未找到），并且尝试调用 remove() 方法来删除这个对象将返回 false 。对于其他类， equals() 的定义可能有所不同。例如，如果两个 String 的内容相同，则这两个 String 相等。因此，为了防止出现意外，请务必注意 List 行为会根据 equals() 行为而发生变化。 第 7、8 行输出展示了删除与 List 中的对象完全匹配的对象是成功的。 可以在 List 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 LinkedList ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 ArrayList ，这可是代价高昂的操作。这是否意味着永远不应该在 ArrayList 的中间插入元素，并最好是转换为 LinkedList ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 ArrayList 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 List 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。 subList() 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 containsAll() 方法时，很自然地会得到 true。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 sub 上调用直观命名的 Collections.sort() 和 Collections.shuffle() 方法，不会影响 containsAll() 的结果。 subList() 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。 retainAll() 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 copy 和 sub 中的所有元素。请再次注意，所产生的结果行为依赖于 equals() 方法。 第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 equals() 的行为。 removeAll() 方法也是基于 equals() 方法运行的。 顾名思义，它会从 List 中删除在参数 List 中的所有元素。 set() 方法的命名显得很不合时宜，因为它与 Set 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。 第 17 行输出表明，对于 List ，有一个重载的 addAll() 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 Collection 的 addAll() 方法将其追加到列表的末尾。 第 18 - 20 行输出展示了 isEmpty() 和 clear() 方法的效果。 第 22、23 行输出展示了如何使用 toArray() 方法将任意的 Collection 转换为数组。这是一个重载方法，其无参版本返回一个 Object 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 List 中的所有元素（就像本例一样），则 toArray() 会创建一个具有合适尺寸的新数组。 Pet 对象有一个 id() 方法，可以在所产生的数组中的对象上调用这个方法。 迭代器Iterators在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 List ， add() 是插入元素的一种方式， get() 是获取元素的一种方式。 如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 List 编码的，但是后来发现如果能够将相同的代码应用于 Set 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？ 迭代器（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为轻量级对象（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 Iterator 只能单向移动。这个 Iterator 只能用来： 使用 iterator() 方法要求集合返回一个 Iterator。 Iterator 将准备好返回序列中的第一个元素。 使用 next() 方法获得序列中的下一个元素。 使用 hasNext() 方法检查序列中是否还有元素。 使用 remove() 方法将迭代器最近返回的那个元素删除。 为了观察它的工作方式，这里再次使用类型信息章节中的 Pet 工具： 123456789101112131415161718192021222324252627282930313233// collections/SimpleIteration.javaimport typeinfo.pets.*;import java.util.*;public class SimpleIteration &#123; public static void main(String[] args) &#123; List&lt;Pet&gt; pets = Pets.list(12); Iterator&lt;Pet&gt; it = pets.iterator(); while(it.hasNext()) &#123; Pet p = it.next(); System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;); &#125; System.out.println(); // A simpler approach, when possible: for(Pet p : pets) System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;); System.out.println(); // An Iterator can also remove elements: it = pets.iterator(); for(int i = 0; i &lt; 6; i++) &#123; it.next(); it.remove(); &#125; System.out.println(pets); &#125;&#125;/* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]*/ 有了 Iterator ，就不必再为集合中元素的数量操心了。这是由 hasNext() 和 next() 关心的事情。 如果只是想向前遍历 List ，并不打算修改 List 对象本身，那么使用 for-in 语法更加简洁。 Iterator还可以删除由 next() 生成的最后一个元素，这意味着在调用 remove() 之前必须先调用 next() 。 在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。 现在考虑创建一个 display() 方法，它不必知晓集合的确切类型： 123456789101112131415161718192021222324252627282930313233// collections/CrossCollectionIteration.javaimport typeinfo.pets.*;import java.util.*;public class CrossCollectionIteration &#123; public static void display(Iterator&lt;Pet&gt; it) &#123; while(it.hasNext()) &#123; Pet p = it.next(); System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; List&lt;Pet&gt; pets = Pets.list(8); LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;&gt;(pets); HashSet&lt;Pet&gt; petsHS = new HashSet&lt;&gt;(pets); TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;&gt;(pets); display(pets.iterator()); display(petsLL.iterator()); display(petsHS.iterator()); display(petsTS.iterator()); &#125;&#125;/* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug0:Rat*/ display() 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 Iterator 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。 我们可以使用 Iterable 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 Iterator 的任何东西”： 12345678910111213141516171819202122232425262728293031323334// collections/CrossCollectionIteration2.javaimport typeinfo.pets.*;import java.util.*;public class CrossCollectionIteration2 &#123; public static void display(Iterable&lt;Pet&gt; ip) &#123; Iterator&lt;Pet&gt; it = ip.iterator(); while(it.hasNext()) &#123; Pet p = it.next(); System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; List&lt;Pet&gt; pets = Pets.list(8); LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;&gt;(pets); HashSet&lt;Pet&gt; petsHS = new HashSet&lt;&gt;(pets); TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;&gt;(pets); display(pets); display(petsLL); display(petsHS); display(petsTS); &#125;&#125;/* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug7:Manx5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug0:Rat*/ 这里所有的类都是 Iterable ，所以现在对 display() 的调用显然更简单。 ListIteratorListIterator 是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。 Iterator 只能向前移动，而 ListIterator 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 set() 方法替换它访问过的最近一个元素。可以通过调用 listIterator() 方法来生成指向 List 开头处的 ListIterator ，还可以通过调用 listIterator(n) 创建一个一开始就指向列表索引号为 n 的元素处的 ListIterator 。 下面的示例演示了所有这些能力： 12345678910111213141516171819202122232425262728293031323334// collections/ListIteration.javaimport typeinfo.pets.*;import java.util.*;public class ListIteration &#123; public static void main(String[] args) &#123; List&lt;Pet&gt; pets = Pets.list(8); ListIterator&lt;Pet&gt; it = pets.listIterator(); while(it.hasNext()) System.out.print(it.next() + &quot;, &quot; + it.nextIndex() + &quot;, &quot; + it.previousIndex() + &quot;; &quot;); System.out.println(); // Backwards: while(it.hasPrevious()) System.out.print(it.previous().id() + &quot; &quot;); System.out.println(); System.out.println(pets); it = pets.listIterator(3); while(it.hasNext()) &#123; it.next(); it.set(Pets.get()); &#125; System.out.println(pets); &#125;&#125;/* Output:Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug,5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;7 6 5 4 3 2 1 0[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx][Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster,EgyptianMau]*/ Pets.get() 方法用来从位置 3 开始替换 List 中的所有 Pet 对象。 链表LinkedListLinkedList 也像 ArrayList 一样实现了基本的 List 接口，但它在 List 中间执行插入和删除操作时比 ArrayList 更高效。然而,它在随机访问操作效率方面却要逊色一些。 LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque） 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 Queue 中）。例如： getFirst() 和 element() 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 List 为空，则抛出 NoSuchElementException 异常。 peek() 方法与这两个方法只是稍有差异，它在列表为空时返回 null 。 removeFirst() 和 remove() 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 NoSuchElementException 异常。 poll() 稍有差异，它在列表为空时返回 null 。 addFirst() 在列表的开头插入一个元素。 offer() 与 add() 和 addLast() 相同。 它们都在列表的尾部（末尾）添加一个元素。 removeLast() 删除并返回列表的最后一个元素。 下面的示例展示了这些功能之间基本的相似性和差异性。它并不是重复执行 ListFeatures.java 中所示的行为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// collections/LinkedListFeatures.javaimport typeinfo.pets.*;import java.util.*;public class LinkedListFeatures &#123; public static void main(String[] args) &#123; LinkedList&lt;Pet&gt; pets = new LinkedList&lt;&gt;(Pets.list(5)); System.out.println(pets); // Identical: System.out.println( &quot;pets.getFirst(): &quot; + pets.getFirst()); System.out.println( &quot;pets.element(): &quot; + pets.element()); // Only differs in empty-list behavior: System.out.println(&quot;pets.peek(): &quot; + pets.peek()); // Identical; remove and return the first element: System.out.println( &quot;pets.remove(): &quot; + pets.remove()); System.out.println( &quot;pets.removeFirst(): &quot; + pets.removeFirst()); // Only differs in empty-list behavior: System.out.println(&quot;pets.poll(): &quot; + pets.poll()); System.out.println(pets); pets.addFirst(new Rat()); System.out.println(&quot;After addFirst(): &quot; + pets); pets.offer(Pets.get()); System.out.println(&quot;After offer(): &quot; + pets); pets.add(Pets.get()); System.out.println(&quot;After add(): &quot; + pets); pets.addLast(new Hamster()); System.out.println(&quot;After addLast(): &quot; + pets); System.out.println( &quot;pets.removeLast(): &quot; + pets.removeLast()); &#125;&#125;/* Output:[Rat, Manx, Cymric, Mutt, Pug]pets.getFirst(): Ratpets.element(): Ratpets.peek(): Ratpets.remove(): Ratpets.removeFirst(): Manxpets.poll(): Cymric[Mutt, Pug]After addFirst(): [Rat, Mutt, Pug]After offer(): [Rat, Mutt, Pug, Cymric]After add(): [Rat, Mutt, Pug, Cymric, Pug]After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]pets.removeLast(): Hamster*/ Pets.list() 的结果被传递给 LinkedList 的构造器，以便使用它来填充 LinkedList 。如果查看 Queue 接口就会发现，它在 LinkedList 的基础上添加了 element() ， offer() ， peek() ， poll() 和 remove() 方法，以使其可以成为一个 Queue 的实现。 Queue 的完整示例将在本章稍后给出。 堆栈Stack堆栈是“后进先出”（LIFO）集合。它有时被称为叠加栈（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。经常用来类比栈的事物是带有弹簧支架的自助餐厅托盘。最后装入的托盘总是最先拿出来使用的。 Java 1.0 中附带了一个 Stack 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 ArrayDeque ，其中包含直接实现堆栈功能的方法： 123456789101112131415// collections/StackTest.javaimport java.util.*;public class StackTest &#123; public static void main(String[] args) &#123; Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) stack.push(s); while(!stack.isEmpty()) System.out.print(stack.pop() + &quot; &quot;); &#125;&#125;/* Output:fleas has dog My*/ 即使它是作为一个堆栈在使用，我们仍然必须将其声明为 Deque 。有时一个名为 Stack 的类更能把事情讲清楚： 1234567891011121314151617// onjava/Stack.java// A Stack class built with an ArrayDequepackage onjava;import java.util.Deque;import java.util.ArrayDeque;public class Stack&lt;T&gt; &#123; private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;(); public void push(T v) &#123; storage.push(v); &#125; public T peek() &#123; return storage.peek(); &#125; public T pop() &#123; return storage.pop(); &#125; public boolean isEmpty() &#123; return storage.isEmpty(); &#125; @Override public String toString() &#123; return storage.toString(); &#125;&#125; 这里引入了使用泛型的类定义的最简单的可能示例。类名称后面的 告诉编译器这是一个参数化类型，而其中的类型参数 T 会在使用类时被实际类型替换。基本上，这个类是在声明“我们在定义一个可以持有 T 类型对象的 Stack 。” Stack 是使用 ArrayDeque 实现的，而 ArrayDeque 也被告知它将持有 T 类型对象。注意， push() 接受类型为 T 的对象，而 peek() 和 pop() 返回类型为 T 的对象。 peek() 方法将返回栈顶元素，但并不将其从栈顶删除，而 pop() 删除并返回顶部元素。 如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 ArrayDeque 的其它所有方法的类（在附录：集合主题中将会看到， Java 1.0 设计者在创建 java.util.Stack 时，就犯了这个错误）。使用组合，可以选择要公开的方法以及如何命名它们。 下面将使用 StackTest.java 中的相同代码来演示这个新的 Stack 类： 123456789101112131415// collections/StackTest2.javaimport onjava.*;public class StackTest2 &#123; public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) stack.push(s); while(!stack.isEmpty()) System.out.print(stack.pop() + &quot; &quot;); &#125;&#125;/* Output:fleas has dog My*/ 如果想在自己的代码中使用这个 Stack 类，当在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能会与 java.util 包中的 Stack 发生冲突。例如，如果我们在上面的例子中导入 **java.util.***，那么就必须使用包名来防止冲突： 12345678910111213141516171819202122// collections/StackCollision.javapublic class StackCollision &#123; public static void main(String[] args) &#123; onjava.Stack&lt;String&gt; stack = new onjava.Stack&lt;&gt;(); for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) stack.push(s); while(!stack.isEmpty()) System.out.print(stack.pop() + &quot; &quot;); System.out.println(); java.util.Stack&lt;String&gt; stack2 = new java.util.Stack&lt;&gt;(); for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;)) stack2.push(s); while(!stack2.empty()) System.out.print(stack2.pop() + &quot; &quot;); &#125;&#125;/* Output:fleas has dog Myfleas has dog My*/ 尽管已经有了 java.util.Stack ，但是 ArrayDeque 可以产生更好的 Stack ，因此更可取。 还可以使用显式导入来控制对“首选” Stack 实现的选择： 1import onjava.Stack; 现在,任何对 Stack 的引用都将选择 onjava 版本，而在选择 java.util.Stack 时，必须使用全限定名称（full qualification）。","categories":[],"tags":[]},{"title":"","slug":"JAVA垃圾回收","date":"2021-10-18T07:13:48.228Z","updated":"2021-10-18T07:12:20.155Z","comments":true,"path":"2021/10/18/JAVA垃圾回收/","link":"","permalink":"http://youngyjmaze.github.io/2021/10/18/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"","text":"JAVA垃圾回收垃圾回收的意义如果不进行垃圾回收，内存迟早会被消耗空。垃圾回收机制的引入可以有效的防止内存泄露、保证内存的有效使用，也减轻了 Java 程序员的对内存管理的工作量。 内存泄露：指该内存空间使用完毕后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有是也将其称为“对象游离”。 垃圾回收机制中的算法垃圾回收算法需要做的基本事情： 发现无用对象回收被无用对象占用的内存空间，使该空间可被程序再次使用 1. 可达性检测算法1.1 引用计数法（Reference Counting Collector）引用计数是垃圾收集器中的早期策略。此方法中，堆中的每个对象都会添加一个引用计数器。每当一个地方引用这个对象时，计数器值 +1；当引用失效时，计数器值 -1。任何时刻计数值为 0 的对象就是不可能再被使用的。 这种算法无法解决对象之间相互引用的情况。比如对象有一个对子对象的引用，子对象反过来引用父对象，它们的引用计数永远不可能为 0。 123456789101112public class Main &#123; public static void main(String[] args) &#123; MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; &#125;&#125; 最后面两句将 object1 和 object2 赋值为 null，也就是说 object1 和 object2 指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。 1.2 根搜索算法（可达性分析算法）由于引用计数法存在缺陷，所有现在一般使用根搜索算法。 根搜索算法图解 根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。如上图中的 ObjF、ObjD、ObjE通过 GC Root 是无法找到的，所以它们是无用节点。 Java 中可作为 GC Root 的对象： 虚拟机栈中引用的对象（本地变量表）方法区中静态属性引用的对象方法区中常量引用的对象本地方法栈中引用的对象（Native对象）可参考：《JVM 内存模型概述》 小结：无论是引用计数法还是跟搜索法，都是为了找到可回收的对象（内存块）。 2.垃圾收集算法在确定了哪些垃圾可以被回收后，垃圾收集器要做的就是进行垃圾的回收，有下面的几中算法： 2.1 标记-清除（Mark-Sweep）算法标记-清除算法分为两个阶段： 标记阶段：标记出需要被回收的对象。清除阶段：回收被标记的可回收对象的内部空间。 标记-清除算法图 标记-清除算法实现较容易，不需要移动对象，但是存在较严重的问题： 算法过程需要暂停整个应用，效率不高。 标记清除后会产生大量不连续的内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作 2.2 复制（Copying）算法 为了解决标志-清除算法的缺陷，由此有了复制算法。 复制算法将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。 复制算法图 小结： 优点：实现简单，不易产生内存碎片，每次只需要对半个区进行内存回收。 缺点：内存空间缩减为原来的一半；算法的效率和存活对象的数目有关，存活对象越多，效率越低。 2.3 标记-整理（Mark-Compact）算法 为了更充分利用内存空间，提出了标记-整理算法。 此算法结合了“标记-清除”和“复制”两个算法的优点。 该算法标记阶段和“标志-清除”算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 标志-整理算法图 2.4 分代收集（Generational Collection）算法分代收集算法是目前大部分 JVM 的垃圾收集器采用的算法。核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。 分代算法图 区域划分： 年轻代（Young Generation） 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 新生代内存按照8:1:1的比例分为一个 eden 区和两个 survivor(survivor0,survivor1) 区。一个 Eden 区，两个 Survivor 区(一般而言)。大部分对象在 Eden 区中生成。回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的，然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。 当 survivor1区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次 Full GC ，也就是新生代、老年代都进行回收。 新生代发生的 GC 也叫做 Minor GC ，Minor GC 发生频率比较高(不一定等 Eden 区满了才触发)。 年老代（Old Generation） 在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。 持久代（Permanent Generation） 用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class ，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。 GC 类型： Minor GC(新生代 GC):新生代 GC，指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生熄灭的特点，所以 Minor GC 十分频繁，回收速度也较快。Major GC(老年代 GC): 老年代 GC，指发生在老年代的垃圾收集动作，当出现 Major GC 时，一般也会伴有至少一次的 Minor GC（并非绝对，例如 Parallel Scavenge 收集器会单独直接触发 Major GC 的机制）。 Major GC 的速度一般会比 Minor GC 慢十倍以上。 Full GC:清理整个堆空间—包括年轻代和老年代。Major GC == Full GC。参考： 产生 Full GC 可能的原因： 年老代被写满。 持久代被写满。 System.gc() 被显式调用。 上一次 GC 之后 Heap 的各域分配策略动态变化。 垃圾收集器（GC）不同虚拟机所提供的垃圾收集器可能会有很大差别，下面的例子是 HotSpot。 新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge。老年代收集器使用的收集器：Serial Old、Parallel Old、CMS。 垃圾收集器图 Serial 收集器（复制算法)新生代单线程收集器，标记和清理都是单线程，优点是简单高效。 Serial Old收集器(标记-整理算法)老年代单线程收集器，Serial 收集器的老年代版本。 ParNew 收集器(停止-复制算法) 新生代收集器，可以认为是 Serial 收集器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现。 Parallel Scavenge 收集器(停止-复制算法)并行收集器，追求高吞吐量，高效利用 CPU。吞吐量一般为 99%， 吞吐量 = 用户线程时间 / (用户线程时间 + GC线程时间)。适合后台应用等对交互相应要求不高的场景。 Parallel Old 收集器(停止-复制算法)Parallel Scavenge 收集器的老年代版本，并行收集器，吞吐量优先。 CMS(Concurrent Mark Sweep) 收集器（标记-清理算法）高并发、低停顿，追求最短 GC 回收停顿时间，cpu 占用比较高，响应时间快，停顿时间短，多核 cpu 追求高响应时间的选择。 根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。 四种引用状态在实际开发中，我们对 new 出来的对象也会根据重要程度，有个等级划分。有些必须用到的对象，我们希望它在其被引用的周期内能一直存在；有些对象可能没那么重要，当内存空间还足够时，可以保留在内存中，如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。由此，Java 对引用划分为四种：强引用、软引用、弱引用、虚引用，四种引用强度依次减弱。 强引用代码中普遍存在的类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。2. 软引用描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java 中的类 SoftReference 表示软引用。 弱引用 描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java 中的类 WeakReference 表示弱引用。 虚引用这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java 中的类 PhantomReference 表示虚引用。 作者：安静的蓝孩子链接：https://www.jianshu.com/p/b78ac4bf13ae来源：简书","categories":[],"tags":[]}],"categories":[],"tags":[]}