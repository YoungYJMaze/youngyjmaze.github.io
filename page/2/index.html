<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="injune的个人空间"><meta name="keywords"><meta name="author" content="injune,undefined"><meta name="copyright" content="injune"><title>injune的个人空间【injune'zone】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="injune'zone" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">injune</div><div class="author-info-description">injune的个人空间</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/YoungYJMaze" target="_blank">GitHub<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="mailto:q2235133943@gmail.com" target="_blank">E-Mail<i class="icon-dot bg-color0"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">24</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">35</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">injune'zone</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E5%B8%B8%E9%87%8F%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">常量及构造函数</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%B8%B8%E9%87%8F/">常量</a></div></div><div class="post-content"><div class="main-content content"><h1 id="0717"><a href="#0717" class="headerlink" title="0717"></a>0717</h1><h2 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h2><p>当生成一个常量时，如果我们想要明确的八进制、十六进制或是单精度双精度，可以像以下方式一样声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i1=0x2f; //十六进制</span><br><span class="line">int i2=0144; //八进制</span><br><span class="line">char c = 0xffff //最大的char值</span><br></pre></td></tr></table></figure>

<h2 id="指数记数法"><a href="#指数记数法" class="headerlink" title="指数记数法"></a>指数记数法</h2><p>编译器通常会把指数记数法，形如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f=1e-43;</span><br></pre></td></tr></table></figure>
<p>当做是双精度数来处理，所以此时应该明确声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f=1e-43f;</span><br></pre></td></tr></table></figure>
<p>这样就可以确保f为一个单精度数了。</p>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>Java，子类不是必须重写父类所有方法的，分为以下两种情况：</p>
<ol>
<li>父类方法为抽象方法时，子类必须重写（实现）所有父类的抽象方法（或者放到当前类的子类实现也可以）；</li>
<li>父类方法为普通方法时，子类可以重写父类方法，也可以不重写。</li>
</ol>
<p>一个类实现接口和继承抽象类对于抽象方法的实现原则是相同的：</p>
<ol>
<li>如果这个类是个普通类，那么必须实现这个接口/抽象类的所有抽象方法；</li>
<li>如果这个类是个抽象类，那么不必实现这个接口/抽象类的抽象方法，因为抽象类中可以定义抽象方法。</li>
</ol>
<h2 id="关于截尾和舍入"><a href="#关于截尾和舍入" class="headerlink" title="关于截尾和舍入"></a>关于截尾和舍入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float a=29.7;</span><br><span class="line">int b=(int)a;</span><br></pre></td></tr></table></figure>
<p>答案得到的是29，float和double在转型为整数型时，总是对数字进行结尾操作，如果要得到四舍五入之后的结果，需要使用Math.round()函数。</p>
<pre><code>Math.ceil() //向上取整
Math.floor() //向下取整
</code></pre>
<h2 id="Java的goto语句"><a href="#Java的goto语句" class="headerlink" title="Java的goto语句"></a>Java的goto语句</h2><p>通过使用标签来进行实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lable:</span><br><span class="line">whilecodeblock</span><br><span class="line">&#123;</span><br><span class="line">coutinue Lable;</span><br><span class="line">    Lable1:</span><br><span class="line">    whilecodeblock1</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">continue</span> Lable;</span><br><span class="line">    <span class="keyword">break</span> Lable1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是加入了两个循环代码块，并且利用Label和Label1进行跳转操作。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>主要利用不同的参数列表来构造一个对象。主要就是通过不同的参数列表来实现不同的构造（也可以通过返回值类型的不同来进行方法的重载）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Class person()</span><br><span class="line">&#123;</span><br><span class="line">    person()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    person(int age)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    person(int age,int id)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    char person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveOverloading</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(char) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(byte) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(short) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(int) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f1(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(byte) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(short) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(int) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f2(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(short) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(int) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f3(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f4(int) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f4(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f4(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f4(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f5(long) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f5(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f5(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f6(float) &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f6(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f7</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; printnb(<span class="string">&quot;f7(double) &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testConstVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printnb(<span class="string">&quot;5: &quot;</span>);</span><br><span class="line">    f1(<span class="number">5</span>);f2(<span class="number">5</span>);f3(<span class="number">5</span>);f4(<span class="number">5</span>);f5(<span class="number">5</span>);f6(<span class="number">5</span>);f7(<span class="number">5</span>); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    printnb(<span class="string">&quot;char: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;byte: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;short: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;int: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;long: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;float: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">    printnb(<span class="string">&quot;double: &quot;</span>);</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PrimitiveOverloading p =</span><br><span class="line">      <span class="keyword">new</span> PrimitiveOverloading();</span><br><span class="line">    p.testConstVal();</span><br><span class="line">    p.testChar();</span><br><span class="line">    p.testByte();</span><br><span class="line">    p.testShort();</span><br><span class="line">    p.testInt();</span><br><span class="line">    p.testLong();</span><br><span class="line">    p.testFloat();</span><br><span class="line">    p.testDouble();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">short: f1(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">int: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">long: f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">float: f1(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double)</span></span><br><span class="line"><span class="comment">double: f1(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>像上述代码段所展示的一样，在重载实现时，如果传入的数据类型小于方法生命中的形式参数类型，实际数据类型就会被提升，char类型不太一样，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demotion</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(short)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(int)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(long)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(float)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; print(<span class="string">&quot;f1(double)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(short)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(int)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(long)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123; print(<span class="string">&quot;f2(float)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(short)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(int)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123; print(<span class="string">&quot;f3(long)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f4(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f4(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f4(short)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; print(<span class="string">&quot;f4(int)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f5(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f5(byte)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123; print(<span class="string">&quot;f5(short)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f6(char)&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123; print(<span class="string">&quot;f6(byte)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f7</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; print(<span class="string">&quot;f7(char)&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">    print(<span class="string">&quot;double argument:&quot;</span>);</span><br><span class="line">    f1(x);f2((<span class="keyword">float</span>)x);f3((<span class="keyword">long</span>)x);f4((<span class="keyword">int</span>)x);</span><br><span class="line">    f5((<span class="keyword">short</span>)x);f6((<span class="keyword">byte</span>)x);f7((<span class="keyword">char</span>)x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Demotion p = <span class="keyword">new</span> Demotion();</span><br><span class="line">    p.testDouble();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">double argument:</span></span><br><span class="line"><span class="comment">f1(double)</span></span><br><span class="line"><span class="comment">f2(float)</span></span><br><span class="line"><span class="comment">f3(long)</span></span><br><span class="line"><span class="comment">f4(int)</span></span><br><span class="line"><span class="comment">f5(short)</span></span><br><span class="line"><span class="comment">f6(byte)</span></span><br><span class="line"><span class="comment">f7(char)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出，同时如果传入的参数类型过于大，就需要用到强制转换转换为参数类型比较低的类型进行执行。</p>
<h2 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">    Apple peeled = apple.getPeeled();</span><br><span class="line">    System.out.println(<span class="string">&quot;Yummy&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peeler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... remove peel</span></span><br><span class="line">    <span class="keyword">return</span> apple; <span class="comment">// Peeled</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">  <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassingThis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Person().eat(<span class="keyword">new</span> Apple());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Yummy</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
<p>this的用法：</p>
<ol>
<li>如上述例子一样，我们通过一个剥皮器进行苹果的剥皮，通过this关键字传入apple对象，在一个对象内部实现类中传入当前对象，如果是实例化之后的实例则传入的是当前实例。</li>
<li>返回当前对象的引用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return this;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在构造函数中调用构造函数 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">  String s = <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">  Flower(<span class="keyword">int</span> petals) &#123;</span><br><span class="line">    petalCount = petals;</span><br><span class="line">    print(<span class="string">&quot;Constructor w/ int arg only, petalCount= &quot;</span></span><br><span class="line">      + petalCount);</span><br><span class="line">  &#125;</span><br><span class="line">  Flower(String ss) &#123;</span><br><span class="line">    print(<span class="string">&quot;Constructor w/ String arg only, s = &quot;</span> + ss);</span><br><span class="line">    s = ss;</span><br><span class="line">  &#125;</span><br><span class="line">  Flower(String s, <span class="keyword">int</span> petals) &#123;</span><br><span class="line">    <span class="keyword">this</span>(petals);</span><br><span class="line"><span class="comment">//!    this(s); // Can&#x27;t call two!</span></span><br><span class="line">    <span class="keyword">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line">    print(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Flower() &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    print(<span class="string">&quot;default constructor (no args)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printPetalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//! this(11); // Not inside non-constructor!</span></span><br><span class="line">    print(<span class="string">&quot;petalCount = &quot;</span> + petalCount + <span class="string">&quot; s = &quot;</span>+ s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Flower x = <span class="keyword">new</span> Flower();</span><br><span class="line">    x.printPetalCount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Constructor w/ int arg only, petalCount= 47</span></span><br><span class="line"><span class="comment">String &amp; int args</span></span><br><span class="line"><span class="comment">default constructor (no args)</span></span><br><span class="line"><span class="comment">petalCount = 47 s = hi</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="finalize-的使用"><a href="#finalize-的使用" class="headerlink" title="finalize()的使用"></a>finalize()的使用</h2><p>在知道了java的垃圾回收机制之后，就可以明白finalize()是如何使用的了，在进行垃圾回收准备回收一个对应的类时，我们在类中定义的finalize()函数会被调用，在finalize()中进行一些特殊的操作，并且在下一次垃圾回收的时候才会真正回收对象所占用的内存。也就是用于在垃圾回收时刻做一些重要的清理工作。但是一般使用较少，如果我们真的需要在不使用某个对象的时候进行清理操作，我们需要自己定义一个特定的函数进行清理操作。</p>
<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class test</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  test()</span><br><span class="line">  &#123;</span><br><span class="line">    i=1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这里的变量i在对象的值就在创建时被设为0，在进行构造器初始化之后i的值变为1。</p>
<h2 id="构造器初始化顺序"><a href="#构造器初始化顺序" class="headerlink" title="构造器初始化顺序"></a>构造器初始化顺序</h2><p>在类的内部，变量定义的先后顺序决定了初始化的先后顺序，即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When the constructor is called to create a</span></span><br><span class="line"><span class="comment">// Window object, you&#x27;ll see a message:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">  Window(<span class="keyword">int</span> marker) &#123; print(<span class="string">&quot;Window(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">  Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>); <span class="comment">// Before constructor</span></span><br><span class="line">  House() &#123;</span><br><span class="line">    <span class="comment">// Show that we&#x27;re in the constructor:</span></span><br><span class="line">    print(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">    w3 = <span class="keyword">new</span> Window(<span class="number">33</span>); <span class="comment">// Reinitialize w3</span></span><br><span class="line">  &#125;</span><br><span class="line">  Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>); <span class="comment">// After constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;f()&quot;</span>); &#125;</span><br><span class="line">  Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>); <span class="comment">// At end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    House h = <span class="keyword">new</span> House();</span><br><span class="line">    h.f(); <span class="comment">// Shows that construction is done</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Window(1)</span></span><br><span class="line"><span class="comment">Window(2)</span></span><br><span class="line"><span class="comment">Window(3)</span></span><br><span class="line"><span class="comment">House()</span></span><br><span class="line"><span class="comment">Window(33)</span></span><br><span class="line"><span class="comment">f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码段中，虽然构造函数直接调用了Window(33)，但是我们可以发现，Window(33)在所有变量定义的代码都被调用之后才进行了构造函数的调用。</p>
<h2 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span> </span>&#123;</span><br><span class="line">  Bowl(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">  Table() &#123;</span><br><span class="line">    print(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">    bowl2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span> </span>&#123;</span><br><span class="line">  Bowl bowl3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">  Cupboard() &#123;</span><br><span class="line">    print(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">    bowl4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    print(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">  <span class="keyword">static</span> Cupboard cupboard = <span class="keyword">new</span> Cupboard();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Bowl(1)</span></span><br><span class="line"><span class="comment">Bowl(2)</span></span><br><span class="line"><span class="comment">Table()</span></span><br><span class="line"><span class="comment">f1(1)</span></span><br><span class="line"><span class="comment">Bowl(4)</span></span><br><span class="line"><span class="comment">Bowl(5)</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">Creating new Cupboard() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">f2(1)</span></span><br><span class="line"><span class="comment">f3(1)</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>观察以上的初始化过程，我们可以发现，bowl4和bowl5为static类型，bowl3非static，在输出中，可以看到Bowl4和Bowl5比Bowl3更早被调用，在包含主函数的类中，static对象优先调用生成，我们可以看到Bowl(1)和Bowl(2)更早被输出之后才是构造函数的Table()被输出，在之后又是紧随static Table的static Cupboard被构造出，之后再进行对应非静态变量实例的初始化，静态对象的非构造函数的执行顺序就按一般的函数执行顺序进行。</p>
<h2 id="非静态实例的初始化"><a href="#非静态实例的初始化" class="headerlink" title="非静态实例的初始化"></a>非静态实例的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mug</span> </span>&#123;</span><br><span class="line">  Mug(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mugs</span> </span>&#123;</span><br><span class="line">  Mug mug1;</span><br><span class="line">  Mug mug2;</span><br><span class="line">  &#123;</span><br><span class="line">    mug1 = <span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">    mug2 = <span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">    print(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Mugs() &#123;</span><br><span class="line">    print(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Mugs(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    print(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Mugs();</span><br><span class="line">    print(<span class="string">&quot;new Mugs() completed&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Mugs(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">&quot;new Mugs(1) completed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Inside main()</span></span><br><span class="line"><span class="comment">Mug(1)</span></span><br><span class="line"><span class="comment">Mug(2)</span></span><br><span class="line"><span class="comment">mug1 &amp; mug2 initialized</span></span><br><span class="line"><span class="comment">Mugs()</span></span><br><span class="line"><span class="comment">new Mugs() completed</span></span><br><span class="line"><span class="comment">Mug(1)</span></span><br><span class="line"><span class="comment">Mug(2)</span></span><br><span class="line"><span class="comment">mug1 &amp; mug2 initialized</span></span><br><span class="line"><span class="comment">Mugs(int)</span></span><br><span class="line"><span class="comment">new Mugs(1) completed</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可以看出，虽然没有static类型的对象实例，但是由于在Mugs类中通过一个代码段新建了mug1，mug2两个实例，所以在执行创建Mugs实例时会先执行赋值的语句，并且在这里，与两个赋值语句同属一个代码段的print语句也被执行了。（这是匿名函数类中的一个值得注意的用法）</p>
</div></div><a class="button-hover more" href="/2020/05/26/%E5%B8%B8%E9%87%8F%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E6%8E%A5%E5%8F%A3/">接口</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%8E%A5%E5%8F%A3/">接口</a></div></div><div class="post-content"><div class="main-content content"><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h3><p>复用代码的第一种方式是客户端程序员遵循该接口来编写他们自己的类，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String s =</span><br><span class="line">    <span class="string">&quot;If she weighs the same as a duck, she&#x27;s made of wood&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Apply.process(<span class="keyword">new</span> Upcase(), s);</span><br><span class="line">    Apply.process(<span class="keyword">new</span> Downcase(), s);</span><br><span class="line">    Apply.process(<span class="keyword">new</span> Splitter(), s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123; <span class="comment">// Covariant return</span></span><br><span class="line">    <span class="keyword">return</span> ((String)input).toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((String)input).toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(((String)input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">  &#125;    </span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Using Processor Upcase</span></span><br><span class="line"><span class="comment">IF SHE WEIGHS THE SAME AS A DUCK, SHE&#x27;S MADE OF WOOD</span></span><br><span class="line"><span class="comment">Using Processor Downcase</span></span><br><span class="line"><span class="comment">if she weighs the same as a duck, she&#x27;s made of wood</span></span><br><span class="line"><span class="comment">Using Processor Splitter</span></span><br><span class="line"><span class="comment">[If, she, weighs, the, same, as, a, duck,, she&#x27;s, made, of, wood]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="组合接口中的命名冲突："><a href="#组合接口中的命名冲突：" class="headerlink" title="组合接口中的命名冲突："></a>组合接口中的命名冲突：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; <span class="comment">// overloaded</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; <span class="comment">// overloaded</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Identical, no problem:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods differ only by return type:</span></span><br><span class="line"><span class="comment">//! class C5 extends C implements I1 &#123;&#125;</span></span><br><span class="line"><span class="comment">//! interface I4 extends I1, I3 &#123;&#125; ///:~</span></span><br></pre></td></tr></table></figure>

<p>正如上面所展示的一样。实际上C5继承C并实现I1，I4继承 I2,I3，但是C、I1，I2、I3都有f()方法，在进行实现时，f()方法m无法仅仅根据返回类型来进行足够的判断，所以被当做是一个编译时错误。</p>
<h2 id="JAVA正则表达式"><a href="#JAVA正则表达式" class="headerlink" title="JAVA正则表达式"></a>JAVA正则表达式</h2><p>利用(!=)()(!?)可以实现类似python中匹配的效果，如果不使用(!=)他在匹配过我们的结尾之后直接就从这次的结尾开始继续匹配，</p>
</div></div><a class="button-hover more" href="/2020/05/26/%E6%8E%A5%E5%8F%A3/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/">接口与工厂</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%8E%A5%E5%8F%A3/">接口</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%B7%A5%E5%8E%82/">工厂</a></div></div><div class="post-content"><div class="main-content content"><h2 id="接口与工厂"><a href="#接口与工厂" class="headerlink" title="接口与工厂"></a>接口与工厂</h2><p>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方法就是<code>工厂方法</code>设计模式，它与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象，理论上，通过这种方式，我们的代码将完全与接口的实现分离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  Implementation1() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation1 method1&quot;</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation1 method2&quot;</span>);&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  Implementation2() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation2 method1&quot;</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation2 method2&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Implementation2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span> </span>&#123;</span><br><span class="line">    Service s = fact.getService();</span><br><span class="line">    s.method1();</span><br><span class="line">    s.method2();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    serviceConsumer(<span class="keyword">new</span> Implementation1Factory());</span><br><span class="line">    <span class="comment">// Implementations are completely interchangeable:</span></span><br><span class="line">    serviceConsumer(<span class="keyword">new</span> Implementation2Factory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Implementation1 method1</span></span><br><span class="line"><span class="comment">Implementation1 method2</span></span><br><span class="line"><span class="comment">Implementation2 method1</span></span><br><span class="line"><span class="comment">Implementation2 method2</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p>如果没有使用工厂方法，代码就必须在某处指定将要创建的Service的确切类型，以便调用合适的构造器。</p>
<p>对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h3><p>一种典型的创建内部类的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">// Using inner classes looks just like</span></span><br><span class="line">  <span class="comment">// using any other class, within Parcel1:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">    Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">    Destination d = <span class="keyword">new</span> Destination(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>更加普遍的一种创建方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">    Contents c = contents();</span><br><span class="line">    Destination d = to(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel2 p = <span class="keyword">new</span> Parcel2();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    Parcel2 q = <span class="keyword">new</span> Parcel2();</span><br><span class="line">    <span class="comment">// Defining references to inner classes:</span></span><br><span class="line">    Parcel2.Contents c = q.contents();</span><br><span class="line">    Parcel2.Destination d = q.to(<span class="string">&quot;Borneo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>内部类被用来作为一种名字隐藏和组织代码的模式。但是它的更有用的作用是：</p>
<ul>
<li>当生成一个内部类的对象时，此对象与制造它的外围对象就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件，此外，内部类还拥有其外围类的所有元素的访问权：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; items = <span class="keyword">new</span> Object[size]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(next &lt; items.length)</span><br><span class="line">      items[next++] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i == items.length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> items[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(i &lt; items.length) i++; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      sequence.add(Integer.toString(i));</span><br><span class="line">    Selector selector = sequence.selector();</span><br><span class="line">    <span class="keyword">while</span>(!selector.end()) &#123;</span><br><span class="line">      System.out.print(selector.current() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      selector.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h3><p>如果你需要生成对外部类对象的引用，可以使用外部类的名字后面跟着this，这样产生的引用自动地具有正确的类型，<strong>这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">    DotThis.Inner dti = dt.inner();</span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DotThis.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时你需要创建某个内部类的对象，需要在new表达式中提供对其他外部类对象的引用，同时需要使用.new语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">    DotNew.Inner dni = dn.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>



<h2 id="内部类与上转型"><a href="#内部类与上转型" class="headerlink" title="内部类与上转型"></a>内部类与上转型</h2></div></div><a class="button-hover more" href="/2020/05/26/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/">接口嵌套、线程池</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%8E%A5%E5%8F%A3/">接口</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div></div><div class="post-content"><div class="main-content content"><h2 id="接口嵌套、线程池"><a href="#接口嵌套、线程池" class="headerlink" title="接口嵌套、线程池"></a>接口嵌套、线程池</h2><p>接口可以嵌套在类或其他接口中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp2</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CImp2</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp2</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> DImp2(); &#125;</span><br><span class="line">  <span class="keyword">private</span> D dRef;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line">    dRef = d;</span><br><span class="line">    dRef.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Redundant &quot;public&quot;:</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// Cannot be private within an interface:</span></span><br><span class="line">  <span class="comment">//! private interface I &#123;&#125;</span></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterfaces</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Cannot implement a private interface except</span></span><br><span class="line">  <span class="comment">// within that interface&#x27;s defining class:</span></span><br><span class="line">  <span class="comment">//! class DImp implements A.D &#123;</span></span><br><span class="line">  <span class="comment">//!  public void f() &#123;&#125;</span></span><br><span class="line">  <span class="comment">//! &#125;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">EImp</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">EGImp</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">EImp2</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EG</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="comment">// Can&#x27;t access A.D:</span></span><br><span class="line">    <span class="comment">//! A.D ad = a.getD();</span></span><br><span class="line">    <span class="comment">// Doesn&#x27;t return anything but A.D:</span></span><br><span class="line">    <span class="comment">//! A.DImp2 di2 = a.getD();</span></span><br><span class="line">    <span class="comment">// Cannot access a member of the interface:</span></span><br><span class="line">    <span class="comment">//! a.getD().f();</span></span><br><span class="line">    <span class="comment">// Only another A can do anything with getD():</span></span><br><span class="line">    A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    a2.receiveD(a.getD());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p>在类中嵌套接口的语法是相当显而易见的，就像非嵌套接口一样，可以拥有public和“包访问性”两种可视性。</p>
<p>接口也可以被实现为private，就像在A.D中所看到的，DImp2依然将这个接口实现为了一个public类，但是A.DImpl2只能被其自身所使用。因此，实现一个接口是一个方式，可以强制该接口中的方法定义不添加任何类型信息，也就是无法进行向上转型。</p>
<p>getD()方法是一个对private接口的引用的public方法，在main()中，数次尝试使用返回值都无法成功，只有一种方式可以成功，就是将返回值交给有权使用它的对象，在本例中，是另一个A通过receivedD()方法来实现的。</p>
<ul>
<li><p><strong>当我们实现某个接口时，并不需要实现其内部所嵌套的接口。</strong></p>
</li>
<li><p><strong>private接口只能在定义它的类中被实现。</strong></p>
</li>
</ul>
<h2 id="可缓存线程池newCachedThreadPool"><a href="#可缓存线程池newCachedThreadPool" class="headerlink" title="可缓存线程池newCachedThreadPool"></a>可缓存线程池newCachedThreadPool</h2><p> CachedThreadPool 是通过 java.util.concurrent.Executors 创建的 ThreadPoolExecutor 实例。这个实例会根据需要，在线程可用时，重用之前构造好的池中线程。这个线程池在执行 <strong>大量短生命周期的异步任务时（many short-lived asynchronous task）</strong>，可以显著提高程序性能。调用 <strong>execute</strong> 时，可以重用之前已构造的可用线程，如果不存在可用线程，那么会重新创建一个新的线程并将其加入到线程池中。如果线程超过 60 秒还未被使用，就会被中止并从缓存中移除。因此，线程池在长时间空闲后不会消耗任何资源。</p>
<p>注意队列实例是：new SynchronousQueue()</p>
<h2 id="固定数量线程池FixedThreadPool"><a href="#固定数量线程池FixedThreadPool" class="headerlink" title="固定数量线程池FixedThreadPool"></a>固定数量线程池FixedThreadPool</h2><p>FixedThreadPool 是通过 java.util.concurrent.Executors 创建的 ThreadPoolExecutor 实例。这个实例会复用 <strong>固定数量的线程</strong> 处理一个 <strong>共享的无边界队列</strong> 。任何时间点，最多有 nThreads 个线程会处于活动状态执行任务。如果当所有线程都是活动时，有多的任务被提交过来，那么它会一致在队列中等待直到有线程可用。如果任何线程在执行过程中因为错误而中止，新的线程会替代它的位置来执行后续的任务。所有线程都会一致存于线程池中，直到显式的执行 ExecutorService.shutdown() 关闭。</p>
<p>注意队列实例是：new LinkedBlockingQueue()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="slf4j-logback关系详解和相关用法"><a href="#slf4j-logback关系详解和相关用法" class="headerlink" title="slf4j  logback关系详解和相关用法"></a>slf4j  logback关系详解和相关用法</h1></div></div><a class="button-hover more" href="/2020/05/26/%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/">私有方法和静态方法的测试</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%B5%8B%E8%AF%95/">测试</a></div></div><div class="post-content"><div class="main-content content"><pre><code>        testStatic mock = new testStatic();//私有方法的mock
        testStatic spy=PowerMockito.spy(mock);
</code></pre>
<p>//        PowerMockito.when(spy,”testPrivate”,any()).thenReturn(true);<br>           Object is=method.invoke(mock,””);<br>            Assert.assertEquals(is,true);</p>
<pre><code>    Object say = Whitebox.invokeMethod(mock, &quot;testPrivate&quot;, &quot;hi&quot;);
    Assert.assertEquals(say,true);
        测试私有方法（可行）
        
        
        
                InOutValue inOutValueMock= Mockito.mock(OrderInOutValue.class);
    IndexOptionOrder indexOptionOrderMock=Mockito.mock(IndexOptionOrder.class);
    OptionOrder optionOrder=Mockito.mock(OptionOrder.class);
</code></pre>
<p>//        Comm commMock=mock(Comm.class);</p>
<pre><code>    inOutValueMock.setPortfolioKey(&quot;11&quot;);
    inOutValueMock.setFuturePositionKey(&quot;111&quot;);
    inOutValueMock.setAssetKey(&quot;1111&quot;);

    PowerMockito.mockStatic(Comm.class);


    PowerMockito.when(Comm.isFutExchange(Mockito.any())).thenReturn(true);
    PowerMockito.whenNew(IndexOptionOrder.class).withArguments(Mockito.any()).thenReturn(indexOptionOrderMock);
    Assert.assertEquals(OptionUtil.getOptionTransaction(inOutValueMock),indexOptionOrderMock);

    PowerMockito.when(Comm.isFutExchange(Mockito.any())).thenReturn(false);
    PowerMockito.whenNew(OptionOrder.class).withArguments(Mockito.any()).thenReturn(optionOrder);
    Assert.assertEquals(OptionUtil.getOptionTransaction(inOutValueMock),optionOrder);


    测试 静态方法 （可行）
</code></pre>
</div></div><a class="button-hover more" href="/2020/05/26/%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/">java 类</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%B1%BB/">类</a></div></div><div class="post-content"><div class="main-content content"><h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><p>每个编译单元只能存在一个public类，(一个.java文件)，同时这个java文件的文件名必须和类确保一致，包括大小写，如果不存在public类，则文件命名没有特殊要求，其他的访问权限相关类似于方法和变量的访问权限。</p>
<p>除了内部类，其他类不可以是private 和protected的。只能是包访问权限和public之中的一种，</p>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>继承的时候，父类的构造方法最先被调用，然后调用子类的构造方法，如果父类的构造方法中含有参数，就需要通过super()方法显式的调用并且传递合适的参数才能完成构造。</p>
<h2 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipDelegation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> SpaceShipControls controls =</span><br><span class="line">    <span class="keyword">new</span> SpaceShipControls();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpaceShipDelegation</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Delegated methods:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.back(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.down(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.forward(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.left(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.right(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    controls.turboBoost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.up(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpaceShipDelegation protector =</span><br><span class="line">      <span class="keyword">new</span> SpaceShipDelegation(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所呈现的一样，我们在spaceshipdelegation类中创建了一个spaceshipcontrols的实例，并且通过这一实例来进行spaceshipcontrols的方法的调用，这个过程就被称为代理，代理是通过另一个类来实现其功能，而装饰器是在原类上进行功能的拓展。</p>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><p>final 修饰变量用来指代这一变量是不可修改的，如果一个基本类型同时又用final进行修饰，代表这一变量成为编译时常量，即该变量在编译时就已经有一个确定的值了，对于对象的引用来说，final虽然也意味着引用无法指向别处，但是引用所指向的值可以进行改变，我们还可以不给静态final变量赋值，<strong>但是这也意味着我们需要在构造器中为final的对象进行赋值，否则将会产生错误；</strong>（这样的情况又被称为空白final）</p>
<p>像如下这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poppet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  Poppet(<span class="keyword">int</span> ii) &#123; i = ii; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// Initialized final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> j; <span class="comment">// Blank final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Poppet p; <span class="comment">// Blank final reference</span></span><br><span class="line">  <span class="comment">// Blank finals MUST be initialized in the constructor:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">// Initialize blank final</span></span><br><span class="line">    p = <span class="keyword">new</span> Poppet(<span class="number">1</span>); <span class="comment">// Initialize blank final reference</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    j = x; <span class="comment">// Initialize blank final</span></span><br><span class="line">    p = <span class="keyword">new</span> Poppet(x); <span class="comment">// Initialize blank final reference</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> BlankFinal();</span><br><span class="line">    <span class="keyword">new</span> BlankFinal(<span class="number">47</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h5><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味着你无法在方法中更改参数引用所指向的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spin</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalArguments</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">with</span><span class="params">(<span class="keyword">final</span> Gizmo g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//! g = new Gizmo(); // Illegal -- g is final</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">without</span><span class="params">(Gizmo g)</span> </span>&#123;</span><br><span class="line">    g = <span class="keyword">new</span> Gizmo(); <span class="comment">// OK -- g not final</span></span><br><span class="line">    g.spin();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// void f(final int i) &#123; i++; &#125; // Can&#x27;t change</span></span><br><span class="line">  <span class="comment">// You can only read from a final primitive:</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FinalArguments bf = <span class="keyword">new</span> FinalArguments();</span><br><span class="line">    bf.without(<span class="keyword">null</span>);</span><br><span class="line">    bf.with(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如代码中呈现的一样，final 指向的参数我们只能看，而不能对他做出任何的改变，对传入的参数仅仅能够读和返回，而不能做出改变。</p>
<h3 id="final-修饰方法"><a href="#final-修饰方法" class="headerlink" title="final 修饰方法"></a>final 修饰方法</h3><p>final修饰方法的原因有两个：第一个原因是把方法锁定，以防任何继承类修改它的含义，这是出于设计的考虑：想要确保在继承中使方法的行为保持不变，<strong>并且不会被覆盖。</strong></p>
<p>过去使用final方法的第二个原因是效率，在JAVA早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用，当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值。）并且以方法体中的实际代码的副本来替代方法调用，这将消除方法调用的开销。但是当代码段过长，程序代码过于膨胀，可能看不到内嵌带来的任何性能提高。<strong>在最近的java版本中，虚拟机可以探测到这些情况，并且优化去掉这些效率反而降低的额外内嵌调用</strong></p>
<p>！！！！所以现在用final修饰方法单纯是由于第一个原因！</p>
<h3 id="final-修饰类"><a href="#final-修饰类" class="headerlink" title="final 修饰类"></a>final 修饰类</h3><p>当将某个类整体定义为final时，就表明了你不打算继承该类，而且也不允许别人这样做，出于某种原因，你对该类的设计永远不需要做任何变动，或者出于安全的考虑，你不希望它有子类，</p>
<h3 id="继承与初始化"><a href="#继承与初始化" class="headerlink" title="继承与初始化"></a>继承与初始化</h3><p>static初始化的顺序按照定义类时的书写顺序依次初始化。</p>
<p>如以下这个程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: reusing/Beetle.java</span></span><br><span class="line"><span class="comment">// The full process of initialization.</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> j;</span><br><span class="line">  Insect() &#123;</span><br><span class="line">    print(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    j = <span class="number">39</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x1 =</span><br><span class="line">    printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printInit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    print(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> k = printInit(<span class="string">&quot;Beetle.k initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Beetle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;k = &quot;</span> + k);</span><br><span class="line">    print(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x2 =</span><br><span class="line">    printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">    Beetle b = <span class="keyword">new</span> Beetle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">static Insect.x1 initialized</span></span><br><span class="line"><span class="comment">static Beetle.x2 initialized</span></span><br><span class="line"><span class="comment">Beetle constructor</span></span><br><span class="line"><span class="comment">i = 9, j = 0</span></span><br><span class="line"><span class="comment">Beetle.k initialized</span></span><br><span class="line"><span class="comment">k = 47</span></span><br><span class="line"><span class="comment">j = 39</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在加载beetle的时候发现beetle具有一个基类insect 所以编译器继续加载了insect类，（不管是否有新建一个insect对象），加载完基类之后先加载根基类中的static，之后是下一个导出类，以此类推，这个过程结束完之后可以进行对象的创建了，即通过构造器进行对象的构建。</p>
</div></div><a class="button-hover more" href="/2020/05/26/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/CGLIB/">CGLIB</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/cglib/">cglib</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E4%BB%A3%E7%90%86/">代理</a></div></div><div class="post-content"><div class="main-content content"><h1 id="什么是CGLIB"><a href="#什么是CGLIB" class="headerlink" title="什么是CGLIB"></a>什么是CGLIB</h1><p>CGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a></p>
<h1 id="为什么使用CGLIB"><a href="#为什么使用CGLIB" class="headerlink" title="为什么使用CGLIB"></a>为什么使用CGLIB</h1><p>CGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。关于Java动态代理，可以参者这里<a target="_blank" rel="noopener" href="http://blog.csdn.net/danchu/article/details/70146985">Java动态代理分析</a></p>
<h1 id="CGLIB组成结构"><a href="#CGLIB组成结构" class="headerlink" title="CGLIB组成结构"></a>CGLIB组成结构</h1><p><img src="http://jnb.ociweb.com/jnb/jnbNov2005_files/jnbNov2005-1.PNG" alt="image"></p>
<p>CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类。除了CGLIB库外，脚本语言（如Groovy何BeanShell）也使用ASM生成字节码。ASM使用类似SAX的解析器来实现高性能。我们不鼓励直接使用ASM，因为它需要对Java字节码的格式足够的了解</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>说了这么多，可能大家还是不知道CGLIB是干什么用的。下面我们将使用一个简单的例子来演示如何使用CGLIB对一个方法进行拦截。<br>首先，我们需要在工程的POM文件中引入cglib的dependency，这里我们使用的是2.2.2版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;12345</span><br></pre></td></tr></table></figure>

<p>依赖包下载后，我们就可以干活了，按照国际惯例，写个hello world</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before method run...&quot;</span>);</span><br><span class="line">                Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;after method run...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        SampleClass sample = (SampleClass) enhancer.create();</span><br><span class="line">        sample.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在mian函数中，我们通过一个Enhancer和一个MethodInterceptor来实现对方法的拦截，运行程序后输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method run...</span><br><span class="line">hello world</span><br><span class="line">after method run...123</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们引入了Enhancer和MethodInterceptor，可能有些读者还不太了解。别急，我们后面将会一一进行介绍。就目前而言，一个使用CGLIB的小demo就完成了</p>
<h1 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h1><p>目前网络上对CGLIB的介绍资料比较少，造成对cglib的学习困难。这里我将对cglib中的常用类进行一个介绍。为了避免解释的不清楚，我将为每个类都配有一个demo，用来做进一步的说明。首先就从Enhancer开始吧。</p>
<h2 id="Enhancer"><a href="#Enhancer" class="headerlink" title="Enhancer"></a>Enhancer</h2><p>Enhancer可能是CGLIB中最常用的一个类，和Java1.3动态代理中引入的Proxy类差不多(如果对Proxy不懂，可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/danchu/article/details/70146985">这里</a>)。和Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。基于同样的道理，Enhancer也不能对fianl类进行代理操作。这也是Hibernate为什么不能持久化final class的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们将以这个类作为主要的测试类，来测试调用各种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFixedValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello cglib&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    System.out.println(proxy.test(<span class="keyword">null</span>)); <span class="comment">//拦截test，输出Hello cglib</span></span><br><span class="line">    System.out.println(proxy.toString()); </span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    System.out.println(proxy.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello cglib</span><br><span class="line">Hello cglib</span><br><span class="line">class com.zeus.cglib.SampleClass$$EnhancerByCGLIB$$e3ea9b7</span><br><span class="line"></span><br><span class="line">java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number</span><br><span class="line"></span><br><span class="line">    at com.zeus.cglib.SampleClass$$EnhancerByCGLIB$$e3ea9b7.hashCode(&lt;generated&gt;)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>上述代码中，FixedValue用来对所有拦截的方法返回相同的值，从输出我们可以看出来，Enhancer对非final方法test()、toString()、hashCode()进行了拦截，没有对getClass进行拦截。由于hashCode()方法需要返回一个Number，但是我们返回的是一个String，这解释了上面的程序中为什么会抛出异常。</p>
<p>Enhancer.setSuperclass用来设置父类型，从toString方法可以看出，使用CGLIB生成的类为被代理类的一个子类，形如：SampleClass$$EnhancerByCGLIB$$e3ea9b7</p>
<p>Enhancer.create(Object…)方法是用来创建增强对象的，其提供了很多不同参数的方法用来匹配被增强类的不同构造方法。（虽然类的构造放法只是Java字节码层面的函数，但是Enhancer却不能对其进行操作。Enhancer同样不能操作static或者final类）。我们也可以先使用Enhancer.createClass()来创建字节码(.class)，然后用字节码动态的生成增强后的对象。</p>
<p>可以使用一个InvocationHandler(如果对InvocationHandler不懂，可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/danchu/article/details/70146985">这里</a>)作为回调，使用invoke方法来替换直接访问类的方法，但是你必须注意死循环。因为invoke中调用的任何原代理类方法，均会重新代理到invoke方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInvocationHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;hello cglib&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Do not know what to do&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;hello cglib&quot;</span>, proxy.test(<span class="keyword">null</span>));</span><br><span class="line">    Assert.assertNotEquals(<span class="string">&quot;Hello cglib&quot;</span>, proxy.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免这种死循环，我们可以使用MethodInterceptor，MethodInterceptor的例子在前面的hello world中已经介绍过了，这里就不浪费时间了。</p>
<p>有些时候我们可能只想对特定的方法进行拦截，对其他的方法直接放行，不做任何操作，使用Enhancer处理这种需求同样很简单,只需要一个CallbackFilter即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallbackFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    CallbackHelper callbackHelper = <span class="keyword">new</span> CallbackHelper(SampleClass.class, <span class="keyword">new</span> Class[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">getCallback</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Hello cglib&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> NoOp.INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallbackFilter(callbackHelper);</span><br><span class="line">    enhancer.setCallbacks(callbackHelper.getCallbacks());</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, proxy.test(<span class="keyword">null</span>));</span><br><span class="line">    Assert.assertNotEquals(<span class="string">&quot;Hello cglib&quot;</span>,proxy.toString());</span><br><span class="line">    System.out.println(proxy.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ImmutableBean"><a href="#ImmutableBean" class="headerlink" title="ImmutableBean"></a>ImmutableBean</h2><p>通过名字就可以知道，不可变的Bean。ImmutableBean允许创建一个原来对象的包装类，这个包装类是不可变的，任何改变底层对象的包装类操作都会抛出IllegalStateException。但是我们可以通过直接操作底层对象来改变包装类对象。这有点类似于Guava中的不可变视图</p>
<p>为了对ImmutableBean进行测试，这里需要再引入一个bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleBean</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写测试类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected = IllegalStateException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImmutableBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    SampleBean bean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    SampleBean immutableBean = (SampleBean) ImmutableBean.create(bean); <span class="comment">//创建不可变类</span></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello world&quot;</span>,immutableBean.getValue()); </span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world, again&quot;</span>); <span class="comment">//可以通过底层对象来进行修改</span></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello world, again&quot;</span>, immutableBean.getValue());</span><br><span class="line">    immutableBean.setValue(<span class="string">&quot;Hello cglib&quot;</span>); <span class="comment">//直接修改将throw exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bean-generator"><a href="#Bean-generator" class="headerlink" title="Bean generator"></a>Bean generator</h2><p>cglib提供的一个操作bean的工具，使用它能够在运行时动态的创建一个bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanGenerator</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanGenerator beanGenerator = <span class="keyword">new</span> BeanGenerator();</span><br><span class="line">    beanGenerator.addProperty(<span class="string">&quot;value&quot;</span>,String.class);</span><br><span class="line">    Object myBean = beanGenerator.create();</span><br><span class="line">    Method setter = myBean.getClass().getMethod(<span class="string">&quot;setValue&quot;</span>,String.class);</span><br><span class="line">    setter.invoke(myBean,<span class="string">&quot;Hello cglib&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Method getter = myBean.getClass().getMethod(<span class="string">&quot;getValue&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello cglib&quot;</span>,getter.invoke(myBean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用cglib动态的创建了一个和SampleBean相同的Bean对象，包含一个属性value以及getter、setter方法</p>
<h2 id="Bean-Copier"><a href="#Bean-Copier" class="headerlink" title="Bean Copier"></a>Bean Copier</h2><p>cglib提供的能够从一个bean复制到另一个bean中，而且其还提供了一个转换器，用来在转换的时候对bean的属性进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSampleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanCopier</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanCopier copier = BeanCopier.create(SampleBean.class, OtherSampleBean.class, <span class="keyword">false</span>);<span class="comment">//设置为true，则使用converter</span></span><br><span class="line">    SampleBean myBean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    myBean.setValue(<span class="string">&quot;Hello cglib&quot;</span>);</span><br><span class="line">    OtherSampleBean otherBean = <span class="keyword">new</span> OtherSampleBean();</span><br><span class="line">    copier.copy(myBean, otherBean, <span class="keyword">null</span>); <span class="comment">//设置为true，则传入converter指明怎么进行转换</span></span><br><span class="line">   assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, otherBean.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BulkBean"><a href="#BulkBean" class="headerlink" title="BulkBean"></a>BulkBean</h2><p>相比于BeanCopier，BulkBean将copy的动作拆分为getPropertyValues和setPropertyValues两个方法，允许自定义处理属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBulkBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BulkBean bulkBean = BulkBean.create(SampleBean.class,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">&quot;getValue&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">&quot;setValue&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">    SampleBean bean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    Object[] propertyValues = bulkBean.getPropertyValues(bean);</span><br><span class="line">    assertEquals(<span class="number">1</span>, bulkBean.getPropertyValues(bean).length);</span><br><span class="line">    assertEquals(<span class="string">&quot;Hello world&quot;</span>, bulkBean.getPropertyValues(bean)[<span class="number">0</span>]);</span><br><span class="line">    bulkBean.setPropertyValues(bean,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;Hello cglib&quot;</span>&#125;);</span><br><span class="line">    assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, bean.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注意：<br>\1. 避免每次进行BulkBean.create创建对象，一般将其声明为static的<br>\2. 应用场景：针对特定属性的get,set操作，一般适用通过xml配置注入和注出的属性，运行时才确定处理的Source,Target类，只需要关注属性名即可。</p>
<h2 id="BeanMap"><a href="#BeanMap" class="headerlink" title="BeanMap"></a>BeanMap</h2><p>BeanMap类实现了Java Map，将一个bean对象中的所有属性转换为一个String-to-Obejct的Java Map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanGenerator generator = <span class="keyword">new</span> BeanGenerator();</span><br><span class="line">    generator.addProperty(<span class="string">&quot;username&quot;</span>,String.class);</span><br><span class="line">    generator.addProperty(<span class="string">&quot;password&quot;</span>,String.class);</span><br><span class="line">    Object bean = generator.create();</span><br><span class="line">    Method setUserName = bean.getClass().getMethod(<span class="string">&quot;setUsername&quot;</span>, String.class);</span><br><span class="line">    Method setPassword = bean.getClass().getMethod(<span class="string">&quot;setPassword&quot;</span>, String.class);</span><br><span class="line">    setUserName.invoke(bean, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    setPassword.invoke(bean,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    BeanMap map = BeanMap.create(bean);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;admin&quot;</span>, map.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;password&quot;</span>, map.get(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用BeanGenerator生成了一个含有两个属性的Java Bean，对其进行赋值操作后，生成了一个BeanMap对象，通过获取值来进行验证</p>
<h2 id="keyFactory"><a href="#keyFactory" class="headerlink" title="keyFactory"></a>keyFactory</h2><p>keyFactory类用来动态生成接口的实例，接口需要只包含一个newInstance方法，返回一个Object。keyFactory为构造出来的实例动态生成了Object.equals和Object.hashCode方法，能够确保相同的参数构造出的实例为单例的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SampleKeyFactory &#123;</span><br><span class="line">    Object newInstance(String first, int second);</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure>

<p>我们首先构造一个满足条件的接口，然后进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testKeyFactory() throws Exception&#123;</span><br><span class="line">    SampleKeyFactory keyFactory = (SampleKeyFactory) KeyFactory.create(SampleKeyFactory.class);</span><br><span class="line">    Object key = keyFactory.newInstance(&quot;foo&quot;, 42);</span><br><span class="line">    Object key1 = keyFactory.newInstance(&quot;foo&quot;, 42);</span><br><span class="line">    Assert.assertEquals(key,key1);//测试参数相同，结果是否相等</span><br><span class="line">&#125;1234567</span><br></pre></td></tr></table></figure>

<h2 id="Mixin-混合"><a href="#Mixin-混合" class="headerlink" title="Mixin(混合)"></a>Mixin(混合)</h2><p>Mixin能够让我们将多个对象整合到一个对象中去，前提是这些对象必须是接口的实现。可能这样说比较晦涩，以代码为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class MixinInterfaceTest &#123;</span><br><span class="line">    interface Interface1&#123;</span><br><span class="line">        String first();</span><br><span class="line">    &#125;</span><br><span class="line">    interface Interface2&#123;</span><br><span class="line">        String second();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Class1 implements Interface1&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String first() &#123;</span><br><span class="line">            return &quot;first&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Class2 implements Interface2&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String second() &#123;</span><br><span class="line">            return &quot;second&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface MixinInterface extends Interface1, Interface2&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMixin() throws Exception&#123;</span><br><span class="line">        Mixin mixin = Mixin.create(new Class[]&#123;Interface1.class, Interface2.class,</span><br><span class="line">                        MixinInterface.class&#125;, new Object[]&#123;new Class1(),new Class2()&#125;);</span><br><span class="line">        MixinInterface mixinDelegate = (MixinInterface) mixin;</span><br><span class="line">        assertEquals(&quot;first&quot;, mixinDelegate.first());</span><br><span class="line">        assertEquals(&quot;second&quot;, mixinDelegate.second());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011121314151617181920212223242526272829303132333435</span><br></pre></td></tr></table></figure>

<p>Mixin类比较尴尬，因为他要求Minix的类（例如MixinInterface）实现一些接口。既然被Minix的类已经实现了相应的接口，那么我就直接可以通过纯Java的方式实现，没有必要使用Minix类。</p>
<h2 id="String-switcher"><a href="#String-switcher" class="headerlink" title="String switcher"></a>String switcher</h2><p>用来模拟一个String到int类型的Map类型。如果在Java7以后的版本中，类似一个switch语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testStringSwitcher() throws Exception&#123;</span><br><span class="line">    String[] strings = new String[]&#123;&quot;one&quot;, &quot;two&quot;&#125;;</span><br><span class="line">    int[] values = new int[]&#123;10,20&#125;;</span><br><span class="line">    StringSwitcher stringSwitcher = StringSwitcher.create(strings,values,true);</span><br><span class="line">    assertEquals(10, stringSwitcher.intValue(&quot;one&quot;));</span><br><span class="line">    assertEquals(20, stringSwitcher.intValue(&quot;two&quot;));</span><br><span class="line">    assertEquals(-1, stringSwitcher.intValue(&quot;three&quot;));</span><br><span class="line">&#125;123456789</span><br></pre></td></tr></table></figure>

<h2 id="Interface-Maker"><a href="#Interface-Maker" class="headerlink" title="Interface Maker"></a>Interface Maker</h2><p>正如名字所言，Interface Maker用来创建一个新的Interface</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testInterfaceMarker() throws Exception&#123;</span><br><span class="line">    Signature signature = new Signature(&quot;foo&quot;, Type.DOUBLE_TYPE, new Type[]&#123;Type.INT_TYPE&#125;);</span><br><span class="line">    InterfaceMaker interfaceMaker = new InterfaceMaker();</span><br><span class="line">    interfaceMaker.add(signature, new Type[0]);</span><br><span class="line">    Class iface = interfaceMaker.create();</span><br><span class="line">    assertEquals(1, iface.getMethods().length);</span><br><span class="line">    assertEquals(&quot;foo&quot;, iface.getMethods()[0].getName());</span><br><span class="line">    assertEquals(double.class, iface.getMethods()[0].getReturnType());</span><br><span class="line">&#125;12345678910</span><br></pre></td></tr></table></figure>

<p>上述的Interface Maker创建的接口中只含有一个方法，签名为double foo(int)。Interface Maker与上面介绍的其他类不同，它依赖ASM中的Type类型。由于接口仅仅只用做在编译时期进行类型检查，因此在一个运行的应用中动态的创建接口没有什么作用。但是InterfaceMaker可以用来自动生成代码，为以后的开发做准备。</p>
<h2 id="Method-delegate"><a href="#Method-delegate" class="headerlink" title="Method delegate"></a>Method delegate</h2><p>MethodDelegate主要用来对方法进行代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface BeanDelegate&#123;</span><br><span class="line">    String getValueFromDelegate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testMethodDelegate()  throws Exception&#123;</span><br><span class="line">    SampleBean bean = new SampleBean();</span><br><span class="line">    bean.setValue(&quot;Hello cglib&quot;);</span><br><span class="line">    BeanDelegate delegate = (BeanDelegate) MethodDelegate.create(bean,&quot;getValue&quot;, BeanDelegate.class);</span><br><span class="line">    assertEquals(&quot;Hello cglib&quot;, delegate.getValueFromDelegate());</span><br><span class="line">&#125;1234567891011</span><br></pre></td></tr></table></figure>

<p>关于Method.create的参数说明：<br>\1. 第二个参数为即将被代理的方法<br>\2. 第一个参数必须是一个无参数构造的bean。因此MethodDelegate.create并不是你想象的那么有用<br>\3. 第三个参数为只含有一个方法的接口。当这个接口中的方法被调用的时候，将会调用第一个参数所指向bean的第二个参数方法</p>
<p>缺点：<br>\1. 为每一个代理类创建了一个新的类，这样可能会占用大量的永久代堆内存<br>\2. 你不能代理需要参数的方法<br>\3. 如果你定义的接口中的方法需要参数，那么代理将不会工作，并且也不会抛出异常；如果你的接口中方法需要其他的返回类型，那么将抛出IllegalArgumentException</p>
<h2 id="MulticastDelegate"><a href="#MulticastDelegate" class="headerlink" title="MulticastDelegate"></a>MulticastDelegate</h2><ol>
<li>多重代理和方法代理差不多，都是将代理类方法的调用委托给被代理类。使用前提是需要一个接口，以及一个类实现了该接口</li>
<li>通过这种interface的继承关系，我们能够将接口上方法的调用分散给各个实现类上面去。</li>
<li>多重代理的缺点是接口只能含有一个方法，如果被代理的方法拥有返回值，那么调用代理类的返回值为最后一个添加的被代理类的方法返回值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface DelegatationProvider &#123;</span><br><span class="line">    void setValue(String value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleMulticastBean implements DelegatationProvider &#123;</span><br><span class="line">    private String value;</span><br><span class="line">    @Override</span><br><span class="line">    public void setValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testMulticastDelegate() throws Exception&#123;</span><br><span class="line">    MulticastDelegate multicastDelegate = MulticastDelegate.create(DelegatationProvider.class);</span><br><span class="line">    SimpleMulticastBean first = new SimpleMulticastBean();</span><br><span class="line">    SimpleMulticastBean second = new SimpleMulticastBean();</span><br><span class="line">    multicastDelegate = multicastDelegate.add(first);</span><br><span class="line">    multicastDelegate  = multicastDelegate.add(second);</span><br><span class="line"></span><br><span class="line">    DelegatationProvider provider = (DelegatationProvider) multicastDelegate;</span><br><span class="line">    provider.setValue(&quot;Hello world&quot;);</span><br><span class="line"></span><br><span class="line">    assertEquals(&quot;Hello world&quot;, first.getValue());</span><br><span class="line">    assertEquals(&quot;Hello world&quot;, second.getValue());</span><br><span class="line">&#125;123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure>

<h2 id="Constructor-delegate"><a href="#Constructor-delegate" class="headerlink" title="Constructor delegate"></a>Constructor delegate</h2><p>为了对构造函数进行代理，我们需要一个接口，这个接口只含有一个Object newInstance(…)方法，用来调用相应的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface SampleBeanConstructorDelegate&#123;</span><br><span class="line">    Object newInstance(String value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对构造函数进行代理</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testConstructorDelegate() throws Exception&#123;</span><br><span class="line">    SampleBeanConstructorDelegate constructorDelegate = (SampleBeanConstructorDelegate) ConstructorDelegate.create(</span><br><span class="line">            SampleBean.class, SampleBeanConstructorDelegate.class);</span><br><span class="line">    SampleBean bean = (SampleBean) constructorDelegate.newInstance(&quot;Hello world&quot;);</span><br><span class="line">    assertTrue(SampleBean.class.isAssignableFrom(bean.getClass()));</span><br><span class="line">    System.out.println(bean.getValue());</span><br><span class="line">&#125;12345678910111213141516</span><br></pre></td></tr></table></figure>

<h2 id="Parallel-Sorter-并行排序器"><a href="#Parallel-Sorter-并行排序器" class="headerlink" title="Parallel Sorter(并行排序器)"></a>Parallel Sorter(并行排序器)</h2><p>能够对多个数组同时进行排序，目前实现的算法有归并排序和快速排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testParallelSorter() throws Exception&#123;</span><br><span class="line">    Integer[][] value = &#123;</span><br><span class="line">            &#123;4, 3, 9, 0&#125;,</span><br><span class="line">            &#123;2, 1, 6, 0&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ParallelSorter.create(value).mergeSort(0);</span><br><span class="line">    for(Integer[] row : value)&#123;</span><br><span class="line">        int former = -1;</span><br><span class="line">        for(int val : row)&#123;</span><br><span class="line">            assertTrue(former &lt; val);</span><br><span class="line">            former = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;123456789101112131415</span><br></pre></td></tr></table></figure>

<h2 id="FastClass"><a href="#FastClass" class="headerlink" title="FastClass"></a>FastClass</h2><p>顾明思义，FastClass就是对Class对象进行特定的处理，比如通过数组保存method引用，因此FastClass引出了一个index下标的新概念，比如getIndex(String name, Class[] parameterTypes)就是以前的获取method的方法。通过数组存储method,constructor等class信息，从而将原先的反射调用，转化为class.index的直接调用，从而体现所谓的FastClass。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFastClass() throws Exception&#123;</span><br><span class="line">    FastClass fastClass = FastClass.create(SampleBean.class);</span><br><span class="line">    FastMethod fastMethod = fastClass.getMethod(&quot;getValue&quot;,new Class[0]);</span><br><span class="line">    SampleBean bean = new SampleBean();</span><br><span class="line">    bean.setValue(&quot;Hello world&quot;);</span><br><span class="line">    assertEquals(&quot;Hello world&quot;,fastMethod.invoke(bean, new Object[0]));</span><br><span class="line">&#125;12345678</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。</p>
<h1 id="CGLIB和Java动态代理的区别"><a href="#CGLIB和Java动态代理的区别" class="headerlink" title="CGLIB和Java动态代理的区别"></a>CGLIB和Java动态代理的区别</h1><ol>
<li>Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；</li>
<li>Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效</li>
<li>3.</li>
</ol>
<p>CGLIB相关的文章：<br>- <a target="_blank" rel="noopener" href="http://jnb.ociweb.com/jnb/jnbNov2005.html">http://jnb.ociweb.com/jnb/jnbNov2005.html</a><br>- <a target="_blank" rel="noopener" href="http://www.iteye.com/topic/799827">http://www.iteye.com/topic/799827</a><br>- <a target="_blank" rel="noopener" href="http://mydailyjava.blogspot.kr/2013/11/cglib-missing-manual.html">http://mydailyjava.blogspot.kr/2013/11/cglib-missing-manual.html</a></p>
</div></div><a class="button-hover more" href="/2020/05/26/CGLIB/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/JAVA%20%E6%B3%9B%E5%9E%8B/">JAVA泛型</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%8E%A5%E5%8F%A3/">接口</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%B3%9B%E5%9E%8B/">泛型</a></div></div><div class="post-content"><div class="main-content content"><h2 id="JAVA-泛型"><a href="#JAVA-泛型" class="headerlink" title="JAVA 泛型"></a>JAVA 泛型</h2><p>一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。</p>
<p>因此，与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，<code>T</code> 就是类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Automobile&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;Automobile&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Automobile()); <span class="comment">// 此处有类型校验</span></span><br><span class="line">        Automobile a = h3.get();  <span class="comment">// 无需类型转换</span></span><br><span class="line">        <span class="comment">//- h3.set(&quot;Not an Automobile&quot;); // 报错</span></span><br><span class="line">        <span class="comment">//- h3.set(1);  // 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>GenericHolder</code> 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 <code>main()</code> 中那样使用。然后，你就只能在 <code>GenericHolder</code> 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 <code>get()</code> 取值时，直接就是正确的类型。</p>
<p>这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p>
<p>你可能注意到 <code>h3</code> 的定义非常繁复。在 <code>=</code> 左边有 <code>GenericHolder&lt;Automobile&gt;</code>, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Diamond.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bob</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diamond</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Bob&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Bob());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在 <code>h3</code> 的定义处，<code>=</code> 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。</p>
<h2 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h2><p>有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。</p>
<p>这个概念称为<em>元组</em>，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 <em>数据传输对象</em> 或 <em>信使</em> ）。</p>
<p>通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple2.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B a2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple2</span><span class="params">(A a, B b)</span> </span>&#123; a1 = a; a2 = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a1 + <span class="string">&quot;, &quot;</span> + a2; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + rep() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。</p>
<p>初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。<code>a1</code> 和 <code>a2</code> 应该声明为 <strong>private</strong>，然后提供 <code>getFirst()</code> 和 <code>getSecond()</code> 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 <code>a1</code> 和 <code>a2</code> 然后对它们执行任何操作，但无法对 <code>a1</code> 和 <code>a2</code> 重新赋值。例子中的 <code>final</code> 可以实现同样的效果，并且更为简洁明了。</p>
<p>另一种设计思路是允许元组的用户给 <code>a1</code> 和 <code>a2</code> 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 <code>Tuple2</code> 对象。</p>
<p>我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple3.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C a3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple3</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">        a3 = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple4.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> D a4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple4</span><span class="params">(A a, B b, C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c);</span><br><span class="line">        a4 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple5.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple5</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> E a5;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple5</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c, d);</span><br><span class="line">        a5 = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示需要，再定义两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Amphibian.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/Vehicle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 47 自动装箱为 Integer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        <span class="comment">// ttsi.a1 = &quot;there&quot;; // 编译错误，因为 final 不能重新赋值</span></span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> (hi, 47)</span></span><br><span class="line"><span class="comment"> (Amphibian@1540e19d, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。</p>
<p>通过 <code>ttsi.a1 = &quot;there&quot;</code> 语句的报错，我们可以看出，<strong>final</strong> 声明确实可以确保 <strong>public</strong> 字段在对象被构造出来之后就不能重新赋值了。</p>
<p>在上面的程序中，<code>new</code> 表达式有些啰嗦。本章稍后会介绍，如何利用 <em>泛型方法</em> 简化它们。</p>
<p>接下来我们看一个稍微复杂一点的例子：堆栈。在 <a target="_blank" rel="noopener" href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book/book/12-Collections.md">集合</a> 一章中，我们用 <code>LinkedList</code> 实现了 <code>onjava.Stack</code> 类。在那个例子中，<code>LinkedList</code> 本身已经具备了创建堆栈所需的方法。<code>Stack</code> 是通过两个泛型类 <code>Stack&lt;T&gt;</code> 和 <code>LinkedList&lt;T&gt;</code> 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p>
<p>这次我们不用 <code>LinkedList</code> 来实现自己的内部链式存储机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LinkedStack.java</span></span><br><span class="line"><span class="comment">// 用链式结构实现的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node() &#123; item = <span class="keyword">null</span>; next = <span class="keyword">null</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;&gt;();  <span class="comment">// 栈顶</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; lss = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">&quot;Phasers on stun!&quot;</span>.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            lss.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = lss.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stun!</span><br><span class="line">on</span><br><span class="line">Phasers</span><br></pre></td></tr></table></figure>

<p>内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数。</p>
<p>这个例子使用了一个 <em>末端标识</em> (end sentinel) 来判断栈何时为空。这个末端标识是在构造 <code>LinkedStack</code> 时创建的。然后，每次调用 <code>push()</code> 就会创建一个 <code>Node&lt;T&gt;</code> 对象，并将其链接到前一个 <code>Node&lt;T&gt;</code> 对象。当你调用 <code>pop()</code> 方法时，总是返回 <code>top.item</code>，然后丢弃当前 <code>top</code> 所指向的 <code>Node&lt;T&gt;</code>，并将 <code>top</code> 指向下一个 <code>Node&lt;T&gt;</code>，除非到达末端标识，这时就不能再移动 <code>top</code> 了。如果已经到达末端，程序还继续调用 <code>pop()</code> 方法，它只能得到 <code>null</code>，说明栈已经空了。</p>
<h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RandomList.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(rand.nextInt(size()));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs = <span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        Arrays.stream(<span class="string">&quot;The quick brown fox jumped over the lazy brown dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)).forEach(rs::add);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">11</span>).forEach(i -&gt; </span><br><span class="line">            System.out.print(rs.select() + <span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brown over fox quick quick dog brown The brown lazy brown</span><br></pre></td></tr></table></figure>

<p><code>RandomList</code> 继承了 <code>ArrayList</code> 的所有方法。本例中只添加了 <code>select()</code> 这个方法。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口。例如 <em>生成器</em>，这是一种专门负责创建对象的类。实际上，这是 <em>工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。</p>
<p>一般而言，一个生成器只定义一个方法，用于创建对象。例如 <code>java.util.function</code> 类库中的 <code>Supplier</code> 就是一个生成器，调用其 <code>get()</code> 获取对象。<code>get()</code> 是泛型方法，返回值为类型参数 <code>T</code>。</p>
<p>为了演示 <code>Supplier</code>，我们需要定义几个类。下面是个咖啡相关的继承体系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/Coffee.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">&quot; &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Latte.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Mocha.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Cappuccino.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Americano.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Breve.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Breve</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以编写一个类，实现 <code>Supplier&lt;Coffee&gt;</code> 接口，它能够随机生成不同类型的 <code>Coffee</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/CoffeeSupplier.java</span></span><br><span class="line"><span class="comment">// &#123;java generics.coffee.CoffeeSupplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeSupplier</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Coffee</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] types = &#123; Latte.class, Mocha.class, </span><br><span class="line">        Cappuccino.class, Americano.class, Breve.class &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// For iteration:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123; size = sz; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = size;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count &gt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeSupplier.<span class="keyword">this</span>.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> CoffeeSupplier())</span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">for</span> (Coffee c : <span class="keyword">new</span> CoffeeSupplier(<span class="number">5</span>)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Americano 0</span><br><span class="line">Latte 1</span><br><span class="line">Americano 2</span><br><span class="line">Mocha 3</span><br><span class="line">Mocha 4</span><br><span class="line">Breve 5</span><br><span class="line">Americano 6</span><br><span class="line">Latte 7</span><br><span class="line">Cappuccino 8</span><br><span class="line">Cappuccino 9</span><br></pre></td></tr></table></figure>

<p>参数化的 <code>Supplier</code> 接口确保 <code>get()</code> 返回值是参数的类型。<code>CoffeeSupplier</code> 同时还实现了 <code>Iterable</code> 接口，所以能用于 <em>for-in</em> 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。</p>
<p>下面是另一个实现 <code>Supplier&lt;T&gt;</code> 接口的例子，它负责生成 Fibonacci 数列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Fibonacci.java</span></span><br><span class="line"><span class="comment">// Generate a Fibonacci sequence</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> Fibonacci())</span><br><span class="line">              .limit(<span class="number">18</span>)</span><br><span class="line">              .map(n -&gt; n + <span class="string">&quot; &quot;</span>)</span><br><span class="line">              .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584</span><br></pre></td></tr></table></figure>

<p>虽然我们在 <code>Fibonacci</code> 类的里里外外使用的都是 <code>int</code> 类型，但是其参数类型却是 <code>Integer</code>。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 <code>Fibonacci</code> 类对 <code>int</code> 的使用，我们已经看到了这种效果。</p>
<p>如果还想更进一步，编写一个实现了 <code>Iterable</code> 的 <code>Fibnoacci</code> 生成器。我们的一个选择是重写这个类，令其实现 <code>Iterable</code> 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 <em>适配器</em> (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。</p>
<p>有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/IterableFibonacci.java</span></span><br><span class="line"><span class="comment">// Adapt the Fibonacci class to make it Iterable</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableFibonacci</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IterableFibonacci</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; n = count; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> IterableFibonacci.<span class="keyword">this</span>.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="keyword">new</span> IterableFibonacci(<span class="number">18</span>))</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584</span><br></pre></td></tr></table></figure>

<p>在 <em>for-in</em> 语句中使用 <code>IterableFibonacci</code>，必须在构造函数中提供一个边界值，这样 <code>hasNext()</code> 才知道何时返回 <strong>false</strong>，结束循环。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。</p>
<p>泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。</p>
<p>如果方法是 <strong>static</strong> 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。</p>
<p>要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericMethods.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethods gm = <span class="keyword">new</span> GenericMethods();</span><br><span class="line">        gm.f(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">        gm.f(<span class="number">1.0F</span>);</span><br><span class="line">        gm.f(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.String</span></span><br><span class="line"><span class="comment">java.lang.Integer</span></span><br><span class="line"><span class="comment">java.lang.Double</span></span><br><span class="line"><span class="comment">java.lang.Float</span></span><br><span class="line"><span class="comment">java.lang.Character</span></span><br><span class="line"><span class="comment">GenericMethods</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>尽管可以同时对类及其方法进行参数化，但这里未将 <strong>GenericMethods</strong> 类参数化。只有方法 <code>f()</code> 具有类型参数，该参数由方法返回类型之前的参数列表指示。</p>
<p>对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 <em>类型参数推断</em>。因此，对 <code>f()</code> 的调用看起来像普通的方法调用，并且 <code>f()</code> 看起来像被重载了无数次一样。它甚至会接受 <strong>GenericMethods</strong> 类型的参数。</p>
<p>如果使用基本类型调用 <code>f()</code> ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。</p>
<h3 id="变长参数和泛型方法"><a href="#变长参数和泛型方法" class="headerlink" title="变长参数和泛型方法"></a>变长参数和泛型方法</h3><p>泛型方法和变长参数列表可以很好地共存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(</span><br><span class="line">                <span class="string">&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;</span>.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A]</span></span><br><span class="line"><span class="comment">[A, B, C]</span></span><br><span class="line"><span class="comment">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,</span></span><br><span class="line"><span class="comment">S, T, U, V, W, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>此处显示的 <code>makeList()</code> 方法产生的功能与标准库的 <code>java.util.Arrays.asList()</code> 方法相同。</p>
<p><code>@SafeVarargs</code> 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。</p>
<h3 id="一个泛型的-Supplier"><a href="#一个泛型的-Supplier" class="headerlink" title="一个泛型的 Supplier"></a>一个泛型的 Supplier</h3><p>这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/BasicSupplier.java</span></span><br><span class="line"><span class="comment">// Supplier from a class with a no-arg constructor</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicSupplier</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Assumes type is a public class:</span></span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Produce a default Supplier from a type token:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicSupplier&lt;&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此类提供了产生以下对象的基本实现：</p>
<ol>
<li>是 <strong>public</strong> 的。 因为 <strong>BasicSupplier</strong> 在单独的包中，所以相关的类必须具有 <strong>public</strong> 权限，而不仅仅是包级访问权限。</li>
<li>具有无参构造方法。要创建一个这样的 <strong>BasicSupplier</strong> 对象，请调用 <code>create()</code> 方法，并将要生成类型的类型令牌传递给它。通用的 <code>create()</code> 方法提供了 <code>BasicSupplier.create(MyType.class)</code> 这种较简洁的语法来代替较笨拙的 <code>new BasicSupplier &lt;MyType&gt;(MyType.class)</code>。</li>
</ol>
<p>例如，这是一个具有无参构造方法的简单类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CountedObject.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CountedObject &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CountedObject</strong> 类可以跟踪自身创建了多少个实例，并通过 <code>toString()</code> 报告这些实例的数量。 <strong>BasicSupplier</strong> 可以轻松地为 <strong>CountedObject</strong> 创建 <strong>Supplier</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// generics/BasicSupplierDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.BasicSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(</span><br><span class="line">                BasicSupplier.create(CountedObject.class))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CountedObject 0</span></span><br><span class="line"><span class="comment">CountedObject 1</span></span><br><span class="line"><span class="comment">CountedObject 2</span></span><br><span class="line"><span class="comment">CountedObject 3</span></span><br><span class="line"><span class="comment">CountedObject 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>泛型方法减少了产生 <strong>Supplier</strong> 对象所需的代码量。 Java 泛型强制传递 <strong>Class</strong> 对象，以便在 <code>create()</code> 方法中将其用于类型推断。</p>
</div></div><a class="button-hover more" href="/2020/05/26/JAVA%20%E6%B3%9B%E5%9E%8B/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%B5%8B%E8%AF%95/">测试</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/junit/">junit</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/testng/">testng</a></div></div><div class="post-content"><div class="main-content content"><h1 id="0818"><a href="#0818" class="headerlink" title="0818"></a>0818</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>人们倾向于将术语 <em>JUnit 5</em> 和 <em>JUnit Jupiter</em> 当作同义词使用。在大部分情况下，这种互换使用没有什么问题。但是，一定要认识到这两个术语是不同的。<em>JUnit Jupiter</em> 是使用 JUnit 5 编写测试内容的 API。<em>JUnit 5</em> 是一个项目名称（和版本），其 3 个主要模块关注不同的方面：JUnit Jupiter、JUnit Platform 和 JUnit Vintage。</p>
<p>当我提及 JUnit Jupiter 时，指的是编写单元测试的 API；提及 JUnit 5 时，指的是整个项目。</p>
<h4 id="JUnit-5-概述"><a href="#JUnit-5-概述" class="headerlink" title="JUnit 5 概述"></a>JUnit 5 概述</h4><p>以前的 JUnit 版本都是整体式的。除了在 4.4 版中包含 Hamcrest JAR，JUnit 基本来讲就是一个很大的 JAR 文件。测试内容编写者 — 像您我这样的开发人员 — 和工具供应商都使用它的 API，但后者使用很多内部 JUnit API。</p>
<p>大量使用内部 API 给 JUnit 的维护者造成了一些麻烦，并且留给他们推动该技术发展的选择余地不多。来自 <a target="_blank" rel="noopener" href="http://junit.org/junit5/docs/current/user-guide/#api-evolution"><em>JUnit 5 用户指南</em></a>：</p>
<blockquote>
<p>“在 JUnit 4 中，只有外部扩展编写者和工具构建者才使用最初作为内部结构而添加的许多功能。这让更改 JUnit 4 变得特别困难，有时甚至根本不可能。”</p>
</blockquote>
<p>JUnit Lambda（现在称为 JUnit 5）团队决定将 JUnit 重新设计为两个明确且不同的关注区域：</p>
<ul>
<li>一个是编写测试内容的 API。</li>
<li>一个是发现和运行这些测试的 API。</li>
</ul>
<p>这些关注区域现在已整合到 JUnit 5 的架构中，并且它们是明确分离的。图 1 演示了新架构（图像来自 <a target="_blank" rel="noopener" href="https://blog.codefx.org/design/architecture/junit-5-architecture/">Nicolai Parlog</a>）：</p>
<h5 id="图-1-JUnit-5-的架构"><a href="#图-1-JUnit-5-的架构" class="headerlink" title="图 1. JUnit 5 的架构"></a>图 1. JUnit 5 的架构</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-1.png" alt="JUnit 5 架构示意图。"></p>
<p>如果仔细查看图 1，就会发现 JUnit 5 的架构有多么强大。好了，让我们<em>仔细</em>看看这个架构。右上角的方框表明，对 JUnit 5 而言，JUnit Jupiter API 只是<em>另一个 API</em>！因为 JUnit Jupiter 的组件遵循新的架构，所以它们可应用 JUnit 5，但您可以轻松定义不同的测试框架。只要一个框架实现了 <code>TestEngine</code> 接口，就可以将它插入任何支持 <code>junit-platform-engine</code> 和 <code>junit-platform-launcher</code> API 的工具中！</p>
<p>我仍然认为 JUnit Jupiter 非常特殊（毕竟我即将用一整篇教程来介绍它），但 JUnit 5 团队完成的工作确实具有开创性。我只是想指出这一点。我们继续看看图 1，直到我们完全达成一致。</p>
<h4 id="使用-JUnit-Jupiter-编写测试内容"><a href="#使用-JUnit-Jupiter-编写测试内容" class="headerlink" title="使用 JUnit Jupiter 编写测试内容"></a>使用 JUnit Jupiter 编写测试内容</h4><p>就测试编写者而言，任何符合 JUnit 规范的测试框架（包括 JUnit Jupiter）都包含两个组件：</p>
<ul>
<li>我们为其编写测试的 API。</li>
<li>理解这个特定 API 的 JUnit <code>TestEngine</code> 实现。</li>
</ul>
<p>对于本教程，前者是 JUnit Jupiter API，后者是 JUnit Jupiter Test Engine。我将介绍这二者。</p>
<h5 id="JUnit-Jupiter-API"><a href="#JUnit-Jupiter-API" class="headerlink" title="JUnit Jupiter API"></a>JUnit Jupiter API</h5><p>作为开发人员，您将使用 JUnit Jupiter API 创建单元测试来测试您的应用程序代码。使用该 API 的基本特性 — 注解、断言等 — 是本部分教程的主要关注点。</p>
<p>JUnit Jupiter API 的设计让您可通过插入各种生命周期回调来扩展它的功能。您将在第 2 部分中了解如何使用这些回调完成有趣的工作，比如运行参数化测试，将参数传递给测试方法，等等。</p>
<h5 id="JUnit-Jupiter-Test-Engine"><a href="#JUnit-Jupiter-Test-Engine" class="headerlink" title="JUnit Jupiter Test Engine"></a>JUnit Jupiter Test Engine</h5><p>您将使用 JUnit Jupiter Test Engine 发现和执行 JUnit Jupiter 单元测试。该测试引擎实现了 JUnit Platform 中包含的 <code>TestEngine</code> 接口。可将 <code>TestEngine</code> 看作单元测试与用于启动它们的工具（比如 IDE）之间的桥梁。</p>
<h4 id="使用-JUnit-Platform-运行测试"><a href="#使用-JUnit-Platform-运行测试" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h4><p>在 JUnit 术语中，运行单元测试的过程分为两部分：</p>
<ul>
<li><em>发现</em>测试和创建<em>测试计划</em>。</li>
<li><em>启动</em>测试计划，以 (1) 执行测试和 (2) 向用户报告结果。</li>
</ul>
<h4 id="用于发现测试的-API"><a href="#用于发现测试的-API" class="headerlink" title="用于发现测试的 API"></a>用于发现测试的 API</h4><p>用于发现测试和创建测试计划的 API 包含在 JUnit Platform 中，由一个 <code>TestEngine</code> 实现。该测试框架将测试发现功能封装到其 <code>TestEngine</code> 实现中。JUnit Platform 负责使用 IDE 和构建工具（比如 Gradle 和 Maven）发起测试发现流程。</p>
<p>测试发现的目的是创建测试计划，该计划中包含一个<em>测试规范</em>。测试规范包含以下组件：</p>
<ul>
<li><p>选择器</p>
<p>，比如：</p>
<ul>
<li>要扫描哪个包来寻找测试类</li>
<li>特定的类名称</li>
<li>特定的方法</li>
<li>类路径根文件夹</li>
</ul>
</li>
<li><p>过滤器</p>
<p>，比如：</p>
<ul>
<li>类名称模式（比如 “.*Test”）</li>
<li>标签（将在第 2 部分中讨论）</li>
<li>特定的测试引擎（比如 “junit-jupiter”）</li>
</ul>
</li>
</ul>
<p>测试计划是根据测试规范所发现的所有测试类、这些类中的测试方法、测试引擎等的分层视图。测试计划准备就绪后，就可以执行了。</p>
<h4 id="用于执行测试的-API"><a href="#用于执行测试的-API" class="headerlink" title="用于执行测试的 API"></a>用于执行测试的 API</h4><p>用于执行测试的 API 包含在 JUnit Platform 中，由一个或多个 <code>TestEngine</code> 实现。测试框架将测试执行功能封装在它们的 <code>TestEngine</code> 实现中，但 JUnit Platform 负责发起测试执行流程。通过 IDE 和构建工具（比如 Gradle 和 Maven）发起测试执行工作。</p>
<p>一个名为 <code>Launcher</code> 的 JUnit Platform 组件负责执行在测试发现期间创建的测试计划。某个流程 — 假设是您的 IDE — 通过 JUnit Platform（具体来讲是 <code>junit-platform-launcher</code> API）发起测试执行流程。这时，JUnit Platform 将测试计划连同 <code>TestExecutionListener</code> 一起传递给 <code>Launcher</code>。<code>TestExecutionListener</code> 将报告测试执行结果，从而在您的 IDE 中显示该结果。</p>
<p>测试执行流程的目的是向用户准确报告在测试运行时发生了哪些事件。这包括测试成功和失败报告，以及伴随失败而生成的消息，帮助用户理解所发生的事件。</p>
<h4 id="后向兼容性：JUnit-Vintage"><a href="#后向兼容性：JUnit-Vintage" class="headerlink" title="后向兼容性：JUnit Vintage"></a>后向兼容性：JUnit Vintage</h4><p>许多组织对 JUnit 3 和 4 进行了大力投资，因此无法承担向 JUnit 5 的大规模转换。了解到这一点后，JUnit 5 团队提供了 <code>junit-vintage-engine</code> 和 <code>junit-jupiter-migration-support</code> 组件来帮助企业进行迁移。</p>
<p>对 JUnit Platform 而言，JUnit Vintage 只是另一个测试框架，包含自己的 <code>TestEngine</code> 和 API（具体来讲是 JUnit 4 API）。</p>
<p>图 2 显示了各种 JUnit 5 包之间的依赖关系。</p>
<h5 id="图-2-JUnit-5-包关系图"><a href="#图-2-JUnit-5-包关系图" class="headerlink" title="图 2. JUnit 5 包关系图"></a>图 2. JUnit 5 包关系图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-2.png" alt="JUnit 5 包示意图。"></p>
<h4 id="opentest4j-的用途"><a href="#opentest4j-的用途" class="headerlink" title="opentest4j 的用途"></a>opentest4j 的用途</h4><p>支持 JUnit 的测试框架在如何处理测试执行期间抛出的异常方面有所不同。JVM 上的测试没有统一标准，这是 JUnit 团队一直要面对的问题。除了 <code>java.lang.AssertionError</code>，测试框架还必须定义自己的异常分层结构，或者将自身与 JUnit 支持的异常结合起来（或者在某些情况下同时采取两种方法）。</p>
<p><strong>支持 opentest4j</strong>：要加入 Open Test Alliance for the JVM，或者提供反馈来帮助该联盟推进工作，请访问 <a target="_blank" rel="noopener" href="https://github.com/ota4j-team/opentest4j">opentest4j</a> Github 存储库并单击 <em>CONTRIBUTING.md</em> 链接。</p>
<p>为了解决一致性问题，JUnit 团队提议建立一个开源项目，该项目目前称为 Open Test Alliance for the JVM（JVM 开放测试联盟）。该联盟在此阶段仅是一个提案，它仅定义了初步的异常分层结构。但是，JUnit 5 使用 <code>opentest4j</code> 异常。（可在图 2 中看到这一点；请注意从 <code>junit-jupiter-api</code> 和 <code>junit-platform-engine</code> 包到 <code>opentest4j</code> 包的依赖线。）</p>
<p>现在您已基本了解各种 JUnit 5 组件如何结合在一起，是时候使用 JUnit Jupiter API 编写一些测试了！</p>
<h3 id="使用-JUnit-Jupiter-编写测试"><a href="#使用-JUnit-Jupiter-编写测试" class="headerlink" title="使用 JUnit Jupiter 编写测试"></a>使用 JUnit Jupiter 编写测试</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>从 JUnit 4 开始，注解 (annotation) 就成为测试框架的核心特性，这一趋势在 JUnit 5 中得以延续。我无法介绍 JUnit 5 的所有注解，本节仅简要介绍最常用的注解。</p>
<p>首先，我将比较 JUnit 4 中与 JUnit 5 中的注解。JUnit 5 团队更改了一些注解的名称，让它们更直观，同时保持功能不变。如果您正在使用 JUnit 4，下表将帮助您适应这些更改。</p>
<h5 id="表-1-JUnit-4-与-JUnit-5-中的注解比较"><a href="#表-1-JUnit-4-与-JUnit-5-中的注解比较" class="headerlink" title="表 1. JUnit 4 与 JUnit 5 中的注解比较"></a>表 1. JUnit 4 与 JUnit 5 中的注解比较</h5><table>
<thead>
<tr>
<th>JUnit 5</th>
<th>JUnit 4</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>@Test</td>
<td>被注解的方法是一个测试方法。与 JUnit 4 相同。</td>
</tr>
<tr>
<td>@BeforeAll</td>
<td>@BeforeClass</td>
<td>被注解的（静态）方法将在当前类中的所有 @Test 方法前执行一次。</td>
</tr>
<tr>
<td>@BeforeEach</td>
<td>@Before</td>
<td>被注解的方法将在当前类中的每个 @Test 方法前执行。</td>
</tr>
<tr>
<td>@AfterEach</td>
<td>@After</td>
<td>被注解的方法将在当前类中的每个 @Test 方法后执行。</td>
</tr>
<tr>
<td>@AfterAll</td>
<td>@AfterClass</td>
<td>被注解的（静态）方法将在当前类中的所有 @Test 方法后执行一次。</td>
</tr>
<tr>
<td>@Disabled</td>
<td>@Ignore</td>
<td>被注解的方法不会执行（将被跳过），但会报告为已执行。</td>
</tr>
</tbody></table>
<h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>接下来看看一些使用这些注解的示例。尽管一些注解已在 JUnit 5 中重命名，但如果您使用过 JUnit 4，应熟悉它们的功能。清单 1 中的代码来自 <code>JUnit5AppTest.java</code>，可在 <a target="_blank" rel="noopener" href="https://github.com/makotogo/HelloJUnit5">HelloJUnit5</a> 示例应用程序中找到。</p>
<h5 id="清单-1-基本注解"><a href="#清单-1-基本注解" class="headerlink" title="清单 1. 基本注解"></a>清单 1. 基本注解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing using JUnit 5&quot;)``public class JUnit5AppTest &#123;`` ` ` ``private static final Logger log = LoggerFactory.getLogger(JUnit5AppTest.class);`` ` ` ``private App classUnderTest;`` ` ` ``@BeforeAll`` ``public static void init() &#123;``  ``// Do something before ANY test is run in this class`` ``&#125;`` ` ` ``@AfterAll`` ``public static void done() &#123;``  ``// Do something after ALL tests in this class are run`` ``&#125;`` ` ` ``@BeforeEach`` ``public void setUp() throws Exception &#123;``  ``classUnderTest = new App();`` ``&#125;`` ` ` ``@AfterEach`` ``public void tearDown() throws Exception &#123;``  ``classUnderTest = null;`` ``&#125;`` ` ` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void aTest() &#123;``  ``log.info(&quot;As written, this test will always pass!&quot;);``  ``assertEquals(4, (2 + 2));`` ``&#125;`` ` ` ``@Test`` ``@Disabled`` ``@DisplayName(&quot;A disabled test&quot;)`` ``void testNotRun() &#123;``  ``log.info(&quot;This test will not run (it is disabled, silly).&quot;);`` ``&#125;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>看看上面突出显示行中的注解：</p>
<ul>
<li>第 1 行：<code>@RunWith</code> 连同它的参数 <code>JUnitPlatform.class</code>（一个基于 JUnit 4 且理解 JUnit Platform 的 <code>Runner</code>）让您可以在 Eclipse 内运行 JUnit Jupiter 单元测试。Eclipse 尚未原生支持 JUnit 5。未来，Eclipse 将提供原生的 JUnit 5 支持，那时我们不再需要此注解。</li>
<li>第 2 行：<code>@DisplayName</code> 告诉 JUnit 在报告测试结果时显示 <code>String</code> “Testing using JUnit 5”，而不是测试类的名称。</li>
<li>第 9 行：<code>@BeforeAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之前</em>运行 <code>init()</code> 方法<strong>一次</strong>。</li>
<li>第 14 行：<code>@AfterAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之后</em>运行 <code>done()</code> 方法<strong>一次</strong>。</li>
<li>第 19 行：<code>@BeforeEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之前</em>运行 <code>setUp()</code> 方法。</li>
<li>第 24 行：<code>@AfterEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之后</em>运行 <code>tearDown()</code> 方法。</li>
<li>第 29 行：<code>@Test</code> 告诉 JUnit，<code>aTest()</code> 方法是一个 JUnit Jupiter 测试方法。</li>
<li>第 37 行：<code>@Disabled</code> 告诉 JUnit 不运行此 <code>@Test</code> 方法，因为它已被禁用。</li>
</ul>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p><em>断言 (assertion)</em> 是 <code>org.junit.jupiter.api.Assertions</code> 类上的众多静态方法之一。断言用于测试一个条件，该条件必须计算为 <code>true</code>，测试才能继续执行。</p>
<p>如果断言失败，测试会在断言所在的代码行上停止，并生成断言失败报告。如果断言成功，测试会继续执行下一行代码。</p>
<p>表 2 中列出的所有 JUnit Jupiter 断言方法都接受一个可选的 <code>message</code> 参数（作为最后一个参数），以显示断言是否失败，而不是显示标准的缺省消息。</p>
<h5 id="表-2-JUnit-Jupiter-中的断言"><a href="#表-2-JUnit-Jupiter-中的断言" class="headerlink" title="表 2. JUnit Jupiter 中的断言"></a>表 2. JUnit Jupiter 中的断言</h5><table>
<thead>
<tr>
<th>断言方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>assertEquals(expected, actual)</code></td>
<td>如果 <em>expected</em> 不等于 <em>actual</em>，则断言失败。</td>
</tr>
<tr>
<td><code>assertFalse(booleanExpression)</code></td>
<td>如果 <em>booleanExpression</em> 不是 <code>false</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertNull(actual)</code></td>
<td>如果 <em>actual</em> 不是 <code>null</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertNotNull(actual)</code></td>
<td>如果 <em>actual</em> 是 <code>null</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertTrue(booleanExpression)</code></td>
<td>如果 <em>booleanExpression</em> 不是 <code>true</code>，则断言失败。</td>
</tr>
</tbody></table>
<p>清单 2 给出了一个使用这些断言的示例，该示例来自 HelloJUnit5 示例应用程序。</p>
<h5 id="清单-2-示例应用程序中的-JUnit-Jupiter-断言"><a href="#清单-2-示例应用程序中的-JUnit-Jupiter-断言" class="headerlink" title="清单 2. 示例应用程序中的 JUnit Jupiter 断言"></a>清单 2. 示例应用程序中的 JUnit Jupiter 断言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertEquals;``import static org.junit.jupiter.api.Assertions.assertFalse;``import static org.junit.jupiter.api.Assertions.assertNotNull;``import static org.junit.jupiter.api.Assertions.assertNull;``import static org.junit.jupiter.api.Assertions.assertTrue;``.``.`` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void dummyTest() &#123;``  ``int expected = 4;``  ``int actual = 2 + 2;``  ``assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;);``  ``//``  ``Object nullValue = null;``  ``assertFalse(nullValue != null);``  ``assertNull(nullValue);``  ``assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;);``  ``assertTrue(nullValue == null);``  ``.``  ``.`` ``&#125;</span><br></pre></td></tr></table></figure>

<p>看看上面突出显示行中的断言：</p>
<ul>
<li>第 13 行：<code>assertEquals</code>：如果第一个参数值 (4) 不等于第二个参数值 (2+2)，则断言失败。在报告断言失败时使用用户提供的消息（该方法的第 3 个参数）。</li>
<li>第 16 行：<code>assertFalse</code>：表达式 <code>nullValue != null</code> 必须为 <code>false</code>，否则断言失败。</li>
<li>第 17 行：<code>assertNull</code>：<code>nullValue</code> 参数必须为 <code>null</code>，否则断言失败。</li>
<li>第 18 行：<code>assertNotNull</code>：<code>String</code> 文字值 “A String” 不得为 <code>null</code>，否则断言失败并报告消息 “INCONCEIVABLE!”（而不是缺省的 “Assertion failed” 消息）。</li>
<li>第 19 行：<code>assertTrue</code>：如果表达式 <code>nullValue == null</code> 不等于 <code>true</code>，则断言失败。</li>
</ul>
<p>除了支持这些标准断言，JUnit Jupiter AP 还提供了多个新断言。下面介绍其中的两个。</p>
<h5 id="方法-assertAll"><a href="#方法-assertAll" class="headerlink" title="方法 @assertAll()"></a>方法 @assertAll()</h5><p>清单 3 中的 <code>@assertAll()</code> 方法给出了清单 2 中看到的相同断言，但包装在一个新的断言方法中：</p>
<h5 id="清单-3-assertAll"><a href="#清单-3-assertAll" class="headerlink" title="清单 3. assertAll()"></a>清单 3. assertAll()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertAll;``.``.``@Test``@DisplayName(&quot;Dummy test&quot;)``void dummyTest() &#123;`` ``int expected = 4;`` ``int actual = 2 + 2;`` ``Object nullValue = null;`` ``.`` ``.`` ``assertAll(``   ``&quot;Assert All of these&quot;,``   ``() -&gt; assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;),``   ``() -&gt; assertFalse(nullValue != null),``   ``() -&gt; assertNull(nullValue),``   ``() -&gt; assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;),``   ``() -&gt; assertTrue(nullValue == null));``&#125;</span><br></pre></td></tr></table></figure>

<p><code>assertAll()</code> 的有趣之处在于，它包含的<em>所有</em>断言都会执行，即使一个或多个断言失败也是如此。与此相反，在清单 2 中的代码中，如果<em>任何</em>断言失败，测试就会在该位置失败，意味着不会执行任何其他断言。</p>
<h5 id="方法-assertThrows"><a href="#方法-assertThrows" class="headerlink" title="方法 @assertThrows()"></a>方法 @assertThrows()</h5><p>在某些条件下，接受测试的类应抛出异常。JUnit 4 通过 <code>expected =</code> 方法参数或一个 <code>@Rule</code> 提供此能力。与此相反，JUnit Jupiter 通过 <code>Assertions</code> 类提供此能力，使它与其他断言更加一致。</p>
<p>我们将所预期的异常视为可以进行断言的另一个条件，因此 <code>Assertions</code> 包含处理此条件的方法。清单 4 引入了新的 <code>assertThrows()</code> 断言方法。</p>
<h5 id="清单-4-assertThrows"><a href="#清单-4-assertThrows" class="headerlink" title="清单 4. assertThrows()"></a>清单 4. assertThrows()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertThrows;``import static org.junit.jupiter.api.Assertions.assertEquals;``.``.``@Test()``@DisplayName(&quot;Empty argument&quot;)``public void testAdd_ZeroOperands_EmptyArgument() &#123;`` ``long[] numbersToSum = &#123;&#125;;`` ``assertThrows(IllegalArgumentException.class, () -&gt; classUnderTest.add(numbersToSum));``&#125;</span><br></pre></td></tr></table></figure>

<p>请注意第 9 行：如果对 <code>classUnderTest.add()</code> 的调用没有抛出 <code>IllegalArgumentException</code>，则断言失败。</p>
<h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>前置条件 (Assumption) 与断言类似，但前置条件必须为 true，否则测试将<em>中止</em>。与此相反，当断言失败时，则将测试视为已<em>失败</em>。测试方法只应在某些条件 —<em>前置条件</em>下执行时，前置条件很有用。</p>
<p><em>前置条件</em>是 <code>org.junit.jupiter.api.Assumptions</code> 类的静态方法。要理解前置条件的价值，只需一个简单的示例。</p>
<p>假如您只想在星期五运行一个特定的单元测试（我假设您有自己的理由）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test``@DisplayName(&quot;This test is only run on Fridays&quot;)``public void testAdd_OnlyOnFriday() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumeTrue(ldt.getDayOfWeek().getValue() == 5);`` ``// Remainder of test (only executed if assumption holds)...``&#125;</span><br></pre></td></tr></table></figure>

<p>在此情况下，如果条件不成立（第 5 行），就不会执行 lambda 表达式的内容。</p>
<h5 id="使用断言还是前置条件"><a href="#使用断言还是前置条件" class="headerlink" title="使用断言还是前置条件"></a>使用断言还是前置条件</h5><p>二者的区别可能很细微，所以可使用这条经验法则：使用断言<em>检查一个测试方法的结果</em>。使用前置条件<em>确定是否运行测试方法</em>。不会将已中止的测试报告为失败，意味着这种失败不会中断构建工作。</p>
<p>请注意第 5 行：如果该条件不成立，则跳过该测试。在此情况下，该测试不是在星期五 (5) 运行的。这不会影响项目的 “绿色” 部分，而且不会导致构建失败；会跳过 <code>assumeTrue()</code> 后的测试方法中的所有代码。</p>
<p>如果在前置条件成立时仅应执行测试方法的一<em>部分</em>，可以使用 <code>assumingThat()</code> 方法编写上述条件，该方法使用 lambda 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test``@DisplayName(&quot;This test is only run on Fridays (with lambda)&quot;)``public void testAdd_OnlyOnFriday_WithLambda() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumingThat(ldt.getDayOfWeek().getValue() == 5,``   ``() -&gt; &#123;``    ``// Execute this if assumption holds...``   ``&#125;);`` ``// Execute this regardless``&#125;</span><br></pre></td></tr></table></figure>

<p>注意，无论 <code>assumingThat()</code> 中的前置条件成立与否，都会执行 lambda 表达式后的所有代码。</p>
<h4 id="嵌套单元测试，实现清晰的结构"><a href="#嵌套单元测试，实现清晰的结构" class="headerlink" title="嵌套单元测试，实现清晰的结构"></a>嵌套单元测试，实现清晰的结构</h4><p>在继续介绍下节内容之前，我想介绍在 JUnit 5 中编写单元测试的最后一个特性。</p>
<p>JUnit Jupiter API 允许您创建嵌套的类，以保持测试代码更清晰，这有助于让测试结果更易读。通过在主类中创建嵌套的测试类，可以创建更多的名称空间，这提供了两个主要优势：</p>
<ul>
<li>每个单元测试可以拥有自己的测试前和测试后生命周期。这让您能使用特殊条件创建要测试的类，从而测试极端情况。</li>
<li>单元测试方法的名称变得更简单。在 JUnit 4 中，所有测试方法都以对等形式存在，不允许重复的方法名（所以您最终会得到类似 <code>testMethodButOnlyUnderThisOrThatCondition_2()</code> 的方法名）。从 JUnit Jupiter 开始，只有嵌套类中的方法必须具有唯一的名称。清单 6 展示了这一优势。</li>
</ul>
<h5 id="清单-5-传递一个空或-null-数组引用"><a href="#清单-5-传递一个空或-null-数组引用" class="headerlink" title="清单 5. 传递一个空或 null 数组引用"></a>清单 5. 传递一个空或 null 数组引用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing JUnit 5&quot;)``public class JUnit5AppTest &#123;``.``.        `` ``@Nested`` ``@DisplayName(&quot;When zero operands&quot;)`` ``class JUnit5AppZeroOperandsTest &#123;`` ` ` ``// @Test methods go here...`` ` ` ``&#125;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>请注意第 6 行，其中的 <code>JUnit5AppZeroOperandsTest</code> 类可以拥有测试方法。任何测试的结果都会在父类 <code>JUnit5AppTest</code> 中以嵌套的形式显示。</p>
<h4 id="使用-JUnit-Platform-运行测试-1"><a href="#使用-JUnit-Platform-运行测试-1" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h4><p>能编写单元测试很不错，但如果不能运行它们，就没有什么意义了。本节展示如何在 Eclipse 中运行 JUnit 测试，首先使用 Maven，然后从命令行使用 Gradle。</p>
<p>下面的视频展示了如何从 GitHub 克隆示例应用程序代码，并在 Eclipse 中运行测试。在该视频中，我还展示了如何从命令行以及 Eclipse 内使用 Maven 和 Gradle 运行单元测试。Eclipse 对 Maven 和 Gradle 都提供了很好的支持。</p>
<p><strong>应用 3 种工具运行单元测试</strong></p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/intro-to-java-junit.png" alt="应用 3种工具运行单元测试"></p>
<p>下面将提供一些简要的说明，但该视频提供了更多细节。观看该视频，了解如何：</p>
<ul>
<li>从 GitHub 克隆 HelloJUnit5 示例应用程序。</li>
<li>将应用程序导入 Eclipse 中。</li>
<li>从 Eclipse 内的 HelloJUnit5 应用程序运行一个 JUnit 测试。</li>
<li>使用 Maven 从命令行运行 HelloJUnit5 单元测试。</li>
<li>使用 Gradle 从命令行运行 HelloJUnit5 单元测试。</li>
</ul>
<h5 id="克隆-HelloJUnit5-示例应用程序"><a href="#克隆-HelloJUnit5-示例应用程序" class="headerlink" title="克隆 HelloJUnit5 示例应用程序"></a>克隆 HelloJUnit5 示例应用程序</h5><p>要理解教程的剩余部分，您需要从 GitHub 克隆示例应用程序。为此，可打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您希望放入代码的目录，然后输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/makotogo/HelloJUnit5</span><br></pre></td></tr></table></figure>

<p>现在您的机器上已拥有该代码，可以在 Eclipse IDE 内运行 JUnit 测试了。接下来介绍如何运行测试。</p>
<h5 id="在-Eclipse-IDE-中运行单元测试"><a href="#在-Eclipse-IDE-中运行单元测试" class="headerlink" title="在 Eclipse IDE 中运行单元测试"></a>在 Eclipse IDE 中运行单元测试</h5><p>如果您已跟随该视频进行操作，应该已将代码导入 Eclipse 中。现在，在 Eclipse 中打开 <strong>Project Explorer</strong> 视图，展开 HelloJUnit5 项目，直至看到 <code>src/test/java</code> 路径下的 <code>JUnit5AppTest</code> 类。</p>
<p>打开 <code>JUnit5AppTest.java</code> 并验证 <code>class</code> 定义前的下面这个注解（以下代码的第 3 行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.``.``@RunWith(JUnitPlatform.class)``public class JUnit5AppTest &#123;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>现在右键单击 <code>JUnit5AppTest</code> 并选择 <strong>Run As &gt; JUnit Test</strong>。单元测试运行时，JUnit 视图将会出现。您现在已准备好完成本教程的练习。</p>
<h5 id="使用-Maven-运行单元测试"><a href="#使用-Maven-运行单元测试" class="headerlink" title="使用 Maven 运行单元测试"></a>使用 Maven 运行单元测试</h5><p>打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您将 HelloJUnit5 应用程序克隆到的目录，然后输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>

<p>这会启动 Maven 构建并运行单元测试。您的输出应类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean test``[INFO] Scanning for projects...``[INFO]                                     ``[INFO] ------------------------------------------------------------------------``[INFO] Building HelloJUnit5 1.0.2``[INFO] ------------------------------------------------------------------------``[INFO] ``[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ HelloJUnit5 ---``[INFO] Deleting /Users/sperry/home/development/projects/learn/HelloJUnit5/target``[INFO] ``[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/main/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:compile (default-compile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/classes``[INFO] ``[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/test/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:testCompile (default-testCompile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/test-classes``[INFO] ``[INFO] --- maven-surefire-plugin:2.19:test (default-test) @ HelloJUnit5 ---` `-------------------------------------------------------`` ``T E S T S``-------------------------------------------------------``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Running com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Tests run: 1, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 0.038 sec - in com.makotojava.learn.hellojunit5.solution.JUnit5AppTest` `Results :` `Tests run: 1, Failures: 0, Errors: 0, Skipped: 1` `[INFO] ------------------------------------------------------------------------``[INFO] BUILD SUCCESS``[INFO] ------------------------------------------------------------------------``[INFO] Total time: 3.741 s``[INFO] Finished at: 2017-11-28T18:04:50-06:00``[INFO] Final Memory: 21M/255M``[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h5 id="Running-unit-tests-with-Gradle"><a href="#Running-unit-tests-with-Gradle" class="headerlink" title="Running unit tests with Gradle"></a>Running unit tests with Gradle</h5><p>Open a terminal window (Mac) or command prompt (Windows), navigate to the directory where you cloned the HelloJUnit5 application, and enter this command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle clean test</span><br></pre></td></tr></table></figure>

<p>The output should look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gradle clean test``Starting a Gradle Daemon (subsequent builds will be faster)``:clean``:compileJava``:processResources NO-SOURCE``:classes``:compileTestJava``:processTestResources NO-SOURCE``:testClasses``:junitPlatformTest``ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.` `Test run finished after 10097 ms``[     7 containers found   ]``[     5 containers skipped  ]``[     2 containers started  ]``[     0 containers aborted  ]``[     2 containers successful ]``[     0 containers failed   ]``[    10 tests found      ]``[    10 tests skipped     ]``[     0 tests started     ]``[     0 tests aborted     ]``[     0 tests successful   ]``[     0 tests failed     ]` `:test SKIPPED` `BUILD SUCCESSFUL` `Total time: 21.014 secs</span><br></pre></td></tr></table></figure>

<h4 id="测试练习"><a href="#测试练习" class="headerlink" title="测试练习"></a>测试练习</h4><p>现在您已了解 JUnit Jupiter，查看了代码示例，并观看了视频（希望您已跟随视频进行操作）。非常棒，但没有什么比动手编写代码更有用了！在第 1 部分的最后一节，您将完成以下任务：</p>
<ul>
<li>编写 JUnit Jupiter API 单元测试。</li>
<li>运行单元测试。</li>
<li>实现 <code>App</code> 类，让您的单元测试通过检查。</li>
</ul>
<p>采用真正的测试驱动开发 (TDD) 方式，首先编写单元测试，运行它们，并会观察到它们全部失败了。然后编写实现，直到单元测试通过，这时您就大功告成了。</p>
<p>注意，<code>JUnit5AppTest</code> 类仅提供了两个现成的测试方法。首次运行该类时，二者都是 “绿色” 的。要完成这些练习，您需要添加剩余的代码，包括用于告诉 JUnit 运行哪些测试方法的注解。记住，如果没有正确配备一个类或方法，JUnit 将跳过它。</p>
<p>如果遇到困难，请查阅 <code>com.makotojava.learn.hellojunit5.solution</code> 包来寻找解决方案。</p>
<p>1</p>
<h5 id="编写-JUnit-Jupiter-单元测试"><a href="#编写-JUnit-Jupiter-单元测试" class="headerlink" title="编写 JUnit Jupiter 单元测试"></a>编写 JUnit Jupiter 单元测试</h5><p>首先从 <code>JUnit5AppTest.java</code> 开始。打开此文件并按照 Javadoc 注解中的指示操作。</p>
<p><strong>提示</strong>：使用 Eclipse 中的 Javadoc 视图读取测试指令。要打开 Javadoc 视图，可以转到 <strong>Window &gt; Show View &gt; Javadoc</strong>。您应该看到 Javadoc 视图。根据您设置工作区的方式，该窗口可能出现在任意多个位置。在我的工作区中，该窗口与图 3 中的屏幕截图类似，出现在 IDE 右侧的编辑器窗口下方：</p>
<h5 id="图-3-Javadoc-视图"><a href="#图-3-Javadoc-视图" class="headerlink" title="图 3. Javadoc 视图"></a>图 3. Javadoc 视图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-3.png" alt="Javadoc 视图的屏幕截图。"></p>
<p>编辑器窗口中显示了具有原始 HTML 标记的 Javadoc 注解，但在 Javadoc 窗口中，已将其格式化，因此更易于阅读。</p>
<h5 id="在-Eclipse-中运行单元测试"><a href="#在-Eclipse-中运行单元测试" class="headerlink" title="在 Eclipse 中运行单元测试"></a>在 Eclipse 中运行单元测试</h5><p>如果您像我一样，您会使用 IDE 执行以下工作：</p>
<ul>
<li>编写单元测试。</li>
<li>编写单元测试所测试的实现内容。</li>
<li>运行初始测试（使用 IDE 的原生 JUnit 支持）。</li>
</ul>
<p>JUnit 5 提供了一个名为 <code>JUnitPlatform</code> 的类，它允许您在 Eclipse 中运行 JUnit 5 测试。</p>
<p><strong>Eclipse 中的 JUnit 5</strong>：Eclipse 目前能理解 JUnit 4，但尚未提供对 JUnit 5 的原生支持。幸运的是，这对大部分单元测试而言都不是什么大问题！除非您需要使用 JUnit 4 一些更复杂的特性，否则要编写单元测试来全面检查您的应用程序代码，<code>JUnitPlatform</code> 类就足够了。</p>
<p>要在 Eclipse 中运行测试，需要确保您的计算机上拥有示例应用程序。为此，最轻松的方法是从 GitHub 克隆 HelloJUnit5 应用程序，然后将它导入 Eclipse 中。（因为本教程的视频展示了如何这么做，所以这里将跳过细节，仅提供操作步骤。）</p>
<p>确保您克隆了 GitHub 存储库，然后将代码导入 Eclipse 中作为新的 Maven 项目。</p>
<p>将该项目导入 Eclipse 中后，打开 <strong>Project Explorer</strong> 视图并展开 <code>src/main/test</code> 节点，直至看到 <code>JUnit5AppTest</code>。要以 JUnit 测试的形式运行它，可以右键单击它，选择 <strong>Run As &gt; JUnit Test</strong>。</p>
<h5 id="实现-App-类，直到单元测试通过检查"><a href="#实现-App-类，直到单元测试通过检查" class="headerlink" title="实现 App 类，直到单元测试通过检查"></a>实现 App 类，直到单元测试通过检查</h5><p><code>App</code> 的单一 <code>add()</code> 方法提供的功能很容易理解，而且在设计上非常简单。我不希望复杂应用程序的业务逻辑阻碍您对 JUnit Jupiter 的学习。</p>
<p>单元测试通过后，您就大功告成了！记住，如果遇到困难，可以在 <code>com.makotojava.learn.hellojunit5.solution</code> 包中查找解决方案。</p>
<h4 id="第-1-部分小结"><a href="#第-1-部分小结" class="headerlink" title="第 1 部分小结"></a>第 1 部分小结</h4><p>在 JUnit 5 教程的前半部分中，我介绍了 JUnit 5 的架构和组件，并详细介绍了 JUnit Jupiter API。我们逐个介绍了 JUnit 5 中最常用的注解、断言和前置条件，而且通过一个快速练习演示了如何在 Eclipse、Maven 和 Gradle 中运行测试。</p>
<p>在<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part2-vintage-jupiter-extension-model/index.html">第 2 部分</a>中，您将了解 JUnit 5 的一些高级特性：</p>
<ul>
<li>JUnit Jupiter 扩展模型</li>
<li>方法参数注入</li>
<li>参数化测试</li>
</ul>
<p>那么您接下来会怎么做？</p>
<h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3></div></div><a class="button-hover more" href="/2020/05/26/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/JAVA%E5%AE%B9%E5%99%A8%E7%B1%BB/">JAVA 容器</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%AE%B9%E5%99%A8/">容器</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div></div><div class="post-content"><div class="main-content content"><h1 id="JAVA容器类"><a href="#JAVA容器类" class="headerlink" title="JAVA容器类"></a>JAVA容器类</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：</p>
<ol>
<li><strong>集合（Collection）</strong> ：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong> 必须以插入的顺序保存元素， <strong>Set</strong> 不能包含重复元素， <strong>Queue</strong> 按照<em>排队规则</em>来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li>
<li><strong>映射（Map）</strong> ： 一组成对的“键值对”对象，允许使用键来查找值。 <strong>ArrayList</strong> 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 <strong>map</strong> 允许我们使用一个对象来查找另一个对象，它也被称作<em>关联数组</em>（associative array），因为它将对象和其它对象关联在一起；或者称作<em>字典</em>（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 <strong>Map</strong> 是强大的编程工具。</li>
</ol>
<p>尽管并非总是可行，但在理想情况下，你编写的大部分代码都在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个 <strong>List</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>请注意， <strong>ArrayList</strong> 已经被向上转型为了 <strong>List</strong> ，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。</p>
<p>这种方式并非总是有效的，因为某些具体类有额外的功能。例如， <strong>LinkedList</strong> 具有 <strong>List</strong> 接口中未包含的额外方法，而 <strong>TreeMap</strong> 也具有在 <strong>Map</strong> 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。</p>
<p><strong>Collection</strong> 接口概括了<em>序列</em>的概念——一种存放一组对象的方式。下面是个简单的示例，用 <strong>Integer</strong> 对象填充了一个 <strong>Collection</strong> （这里用 <strong>ArrayList</strong> 表示），然后打印集合中的每个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SimpleCollection.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCollection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      c.add(i); <span class="comment">// Autoboxing</span></span><br><span class="line">    <span class="keyword">for</span>(Integer i : c)</span><br><span class="line">      System.out.print(i + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这个例子仅使用了 <strong>Collection</strong> 中的方法（即 <code>add()</code> ），所以使用任何继承自 <strong>Collection</strong> 的类的对象都可以正常工作。但是 <strong>ArrayList</strong> 是最基本的序列类型。</p>
<p><code>add()</code> 方法的名称就表明它是在 <strong>Collection</strong> 中添加一个新元素。但是，文档中非常详细地叙述到 <code>add()</code> “要确保这个 <strong>Collection</strong> 包含指定的元素。”这是因为考虑到了 <strong>Set</strong> 的含义，因为在 <strong>Set</strong>中，只有当元素不存在时才会添加元素。在使用 <strong>ArrayList</strong> ，或任何其他类型的 <strong>List</strong> 时，<code>add()</code> 总是表示“把它放进去”，因为 <strong>List</strong> 不关心是否存在重复元素。</p>
<p>可以使用 <em>for-in</em> 语法来遍历所有的 <strong>Collection</strong> ，就像这里所展示的那样。在本章的后续部分，还将学习到一个更灵活的概念，<em>迭代器</em>。</p>
<h2 id="添加元素组"><a href="#添加元素组" class="headerlink" title="添加元素组"></a>添加元素组</h2><p>在 <strong>java.util</strong> 包中的 <strong>Arrays</strong> 和 <strong>Collections</strong> 类中都有很多实用的方法，可以在一个 <strong>Collection</strong> 中添加一组元素。</p>
<p><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。 <code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中。下边的示例展示了这两个方法，以及更通用的 、所有 <strong>Collection</strong> 类型都包含的<code>addAll()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AddingGroups.java</span></span><br><span class="line"><span class="comment">// Adding groups of elements to Collection objects</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroups</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; collection =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    Integer[] moreInts = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    collection.addAll(Arrays.asList(moreInts));</span><br><span class="line">    <span class="comment">// Runs significantly faster, but you can&#x27;t</span></span><br><span class="line">    <span class="comment">// construct a Collection this way:</span></span><br><span class="line">    Collections.addAll(collection, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>);</span><br><span class="line">    Collections.addAll(collection, moreInts);</span><br><span class="line">    <span class="comment">// Produces a list &quot;backed by&quot; an array:</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>);</span><br><span class="line">    list.set(<span class="number">1</span>, <span class="number">99</span>); <span class="comment">// OK -- modify an element</span></span><br><span class="line">    <span class="comment">// list.add(21); // Runtime error; the underlying</span></span><br><span class="line">                     <span class="comment">// array cannot be resized.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Collection</strong> 的构造器可以接受另一个 <strong>Collection</strong>，用它来将自身初始化。因此，可以使用 <code>Arrays.asList()</code> 来为这个构造器产生输入。但是， <code>Collections.addAll()</code> 运行得更快，而且很容易构建一个不包含元素的 <strong>Collection</strong> ，然后调用 <code>Collections.addAll()</code> ，因此这是首选方式。</p>
<p><code>Collection.addAll()</code> 方法只能接受另一个 <strong>Collection</strong> 作为参数，因此它没有 <code>Arrays.asList()</code> 或 <code>Collections.addAll()</code> 灵活。这两个方法都使用可变参数列表。</p>
<p><strong>也可以直接使用 <code>Arrays.asList()</code> 的输出作为一个 List，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 List上调用 <code>add()</code> 或 <code>remove()</code>，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AsListInference.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Powder</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heavy</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crusty</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slush</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsListInference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Snow&gt; snow1 = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Crusty(), <span class="keyword">new</span> Slush(), <span class="keyword">new</span> Powder());</span><br><span class="line">    <span class="comment">//- snow1.add(new Heavy()); // Exception</span></span><br><span class="line"></span><br><span class="line">    List&lt;Snow&gt; snow2 = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy());</span><br><span class="line">    <span class="comment">//- snow2.add(new Slush()); // Exception</span></span><br><span class="line"></span><br><span class="line">    List&lt;Snow&gt; snow3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(snow3,</span><br><span class="line">      <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy(), <span class="keyword">new</span> Powder());</span><br><span class="line">    snow3.add(<span class="keyword">new</span> Crusty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint with explicit type argument specification:</span></span><br><span class="line">    List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList(</span><br><span class="line">       <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy(), <span class="keyword">new</span> Slush());</span><br><span class="line">    <span class="comment">//- snow4.add(new Powder()); // Exception</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>snow4</strong> 中，注意 <code>Arrays.asList()</code> 中间的“暗示”（即 <code>&lt;Snow&gt;</code> ），告诉编译器 <code>Arrays.asList()</code> 生成的结果 <strong>List</strong> 类型的实际目标类型是什么。这称为<em>显式类型参数说明</em>（explicit type argument specification）。</p>
<h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><p><strong>List</strong>承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p>
<p>有两种类型的 <strong>List</strong> ：</p>
<ul>
<li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li>
<li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集。</li>
</ul>
<p>下面的示例导入 <strong>typeinfo.pets</strong> ，超前使用了<a target="_blank" rel="noopener" href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book">类型信息</a>一章中的类库。这个类库包含了 <strong>Pet</strong> 类层次结构，以及用于随机生成 <strong>Pet</strong> 对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点：</p>
<ol>
<li>有一个 <strong>Pet</strong> 类，以及 <strong>Pet</strong> 的各种子类型。</li>
<li>静态的 <code>Pets.arrayList()</code> 方法返回一个填充了随机选取的 <strong>Pet</strong> 对象的 <strong>ArrayList</strong>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ListFeatures.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFeatures</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;1: &quot;</span> + pets);</span><br><span class="line">    Hamster h = <span class="keyword">new</span> Hamster();</span><br><span class="line">    pets.add(h); <span class="comment">// Automatically resizes</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2: &quot;</span> + pets);</span><br><span class="line">    System.out.println(<span class="string">&quot;3: &quot;</span> + pets.contains(h));</span><br><span class="line">    pets.remove(h); <span class="comment">// Remove by object</span></span><br><span class="line">    Pet p = pets.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;4: &quot;</span> +  p + <span class="string">&quot; &quot;</span> + pets.indexOf(p));</span><br><span class="line">    Pet cymric = <span class="keyword">new</span> Cymric();</span><br><span class="line">    System.out.println(<span class="string">&quot;5: &quot;</span> + pets.indexOf(cymric));</span><br><span class="line">    System.out.println(<span class="string">&quot;6: &quot;</span> + pets.remove(cymric));</span><br><span class="line">    <span class="comment">// Must be the exact object:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;7: &quot;</span> + pets.remove(p));</span><br><span class="line">    System.out.println(<span class="string">&quot;8: &quot;</span> + pets);</span><br><span class="line">    pets.add(<span class="number">3</span>, <span class="keyword">new</span> Mouse()); <span class="comment">// Insert at an index</span></span><br><span class="line">    System.out.println(<span class="string">&quot;9: &quot;</span> + pets);</span><br><span class="line">    List&lt;Pet&gt; sub = pets.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;10: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    Collections.sort(sub); <span class="comment">// In-place sort</span></span><br><span class="line">    System.out.println(<span class="string">&quot;sorted subList: &quot;</span> + sub);</span><br><span class="line">    <span class="comment">// Order is not important in containsAll():</span></span><br><span class="line">    System.out.println(<span class="string">&quot;11: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    Collections.shuffle(sub, rand); <span class="comment">// Mix it up</span></span><br><span class="line">    System.out.println(<span class="string">&quot;shuffled subList: &quot;</span> + sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;12: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    List&lt;Pet&gt; copy = <span class="keyword">new</span> ArrayList&lt;&gt;(pets);</span><br><span class="line">    sub = Arrays.asList(pets.get(<span class="number">1</span>), pets.get(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sub: &quot;</span> + sub);</span><br><span class="line">    copy.retainAll(sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;13: &quot;</span> + copy);</span><br><span class="line">    copy = <span class="keyword">new</span> ArrayList&lt;&gt;(pets); <span class="comment">// Get a fresh copy</span></span><br><span class="line">    copy.remove(<span class="number">2</span>); <span class="comment">// Remove by index</span></span><br><span class="line">    System.out.println(<span class="string">&quot;14: &quot;</span> + copy);</span><br><span class="line">    copy.removeAll(sub); <span class="comment">// Only removes exact objects</span></span><br><span class="line">    System.out.println(<span class="string">&quot;15: &quot;</span> + copy);</span><br><span class="line">    copy.set(<span class="number">1</span>, <span class="keyword">new</span> Mouse()); <span class="comment">// Replace an element</span></span><br><span class="line">    System.out.println(<span class="string">&quot;16: &quot;</span> + copy);</span><br><span class="line">    copy.addAll(<span class="number">2</span>, sub); <span class="comment">// Insert a list in the middle</span></span><br><span class="line">    System.out.println(<span class="string">&quot;17: &quot;</span> + copy);</span><br><span class="line">    System.out.println(<span class="string">&quot;18: &quot;</span> + pets.isEmpty());</span><br><span class="line">    pets.clear(); <span class="comment">// Remove all elements</span></span><br><span class="line">    System.out.println(<span class="string">&quot;19: &quot;</span> + pets);</span><br><span class="line">    System.out.println(<span class="string">&quot;20: &quot;</span> + pets.isEmpty());</span><br><span class="line">    pets.addAll(Pets.list(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;21: &quot;</span> + pets);</span><br><span class="line">    Object[] o = pets.toArray();</span><br><span class="line">    System.out.println(<span class="string">&quot;22: &quot;</span> + o[<span class="number">3</span>]);</span><br><span class="line">    Pet[] pa = pets.toArray(<span class="keyword">new</span> Pet[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;23: &quot;</span> + pa[<span class="number">3</span>].id());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]</span></span><br><span class="line"><span class="comment">3: true</span></span><br><span class="line"><span class="comment">4: Cymric 2</span></span><br><span class="line"><span class="comment">5: -1</span></span><br><span class="line"><span class="comment">6: false</span></span><br><span class="line"><span class="comment">7: true</span></span><br><span class="line"><span class="comment">8: [Rat, Manx, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">subList: [Manx, Mutt, Mouse]</span></span><br><span class="line"><span class="comment">10: true</span></span><br><span class="line"><span class="comment">sorted subList: [Manx, Mouse, Mutt]</span></span><br><span class="line"><span class="comment">11: true</span></span><br><span class="line"><span class="comment">shuffled subList: [Mouse, Manx, Mutt]</span></span><br><span class="line"><span class="comment">12: true</span></span><br><span class="line"><span class="comment">sub: [Mouse, Pug]</span></span><br><span class="line"><span class="comment">13: [Mouse, Pug]</span></span><br><span class="line"><span class="comment">14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">15: [Rat, Mutt, Cymric, Pug]</span></span><br><span class="line"><span class="comment">16: [Rat, Mouse, Cymric, Pug]</span></span><br><span class="line"><span class="comment">17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">18: false</span></span><br><span class="line"><span class="comment">19: []</span></span><br><span class="line"><span class="comment">20: true</span></span><br><span class="line"><span class="comment">21: [Manx, Cymric, Rat, EgyptianMau]</span></span><br><span class="line"><span class="comment">22: EgyptianMau</span></span><br><span class="line"><span class="comment">23: 14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>打印行都编了号，因此可从输出追溯到源代码。 第 1 行输出展示了原始的由 <strong>Pet</strong> 组成的 <strong>List</strong> 。 与数组不同， <strong>List</strong> 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。在第 2 行输出中可以看到添加一个 <strong>Hamster</strong> 的结果，该对象将被追加到列表的末尾。</p>
<p>可以使用 <code>contains()</code> 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 <code>remove()</code> 方法。同样，如果有一个对象的引用，可以使用 <code>indexOf()</code> 在 <strong>List</strong> 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。</p>
<p>当确定元素是否是属于某个 <strong>List</strong> ，寻找某个元素的索引，以及通过引用从 <strong>List</strong> 中删除元素时，都会用到 <code>equals()</code> 方法（根类 <strong>Object</strong> 的一个方法）。每个 <strong>Pet</strong> 被定义为一个唯一的对象，所以即使列表中已经有两个 <strong>Cymrics</strong> ，如果再创建一个新的 <strong>Cymric</strong> 对象并将其传递给 <code>indexOf()</code> 方法，结果仍为 <strong>-1</strong> （表示未找到），并且尝试调用 <code>remove()</code> 方法来删除这个对象将返回 <strong>false</strong> 。对于其他类， <code>equals()</code> 的定义可能有所不同。例如，如果两个 <strong>String</strong> 的内容相同，则这两个 <strong>String</strong> 相等。因此，为了防止出现意外，请务必注意 <strong>List</strong> 行为会根据 <code>equals()</code> 行为而发生变化。</p>
<p>第 7、8 行输出展示了删除与 <strong>List</strong> 中的对象完全匹配的对象是成功的。</p>
<p>可以在 <strong>List</strong> 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 <strong>LinkedList</strong> ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 <strong>ArrayList</strong> ，这可是代价高昂的操作。这是否意味着永远不应该在 <strong>ArrayList</strong> 的中间插入元素，并最好是转换为 <strong>LinkedList</strong> ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 <strong>ArrayList</strong> 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 <strong>List</strong> 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。</p>
<p><code>subList()</code> 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 <code>containsAll()</code> 方法时，很自然地会得到 <strong>true</strong>。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 <strong>sub</strong> 上调用直观命名的 <code>Collections.sort()</code> 和 <code>Collections.shuffle()</code> 方法，不会影响 <code>containsAll()</code> 的结果。 <code>subList()</code> 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。</p>
<p><code>retainAll()</code> 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 <strong>copy</strong> 和 <strong>sub</strong> 中的所有元素。请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。</p>
<p>第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 <code>equals()</code> 的行为。</p>
<p><code>removeAll()</code> 方法也是基于 <code>equals()</code> 方法运行的。 顾名思义，它会从 <strong>List</strong> 中删除在参数 <strong>List</strong> 中的所有元素。</p>
<p><code>set()</code> 方法的命名显得很不合时宜，因为它与 <strong>Set</strong> 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。</p>
<p>第 17 行输出表明，对于 <strong>List</strong> ，有一个重载的 <code>addAll()</code> 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 <strong>Collection</strong> 的 <code>addAll()</code> 方法将其追加到列表的末尾。</p>
<p>第 18 - 20 行输出展示了 <code>isEmpty()</code> 和 <code>clear()</code> 方法的效果。</p>
<p>第 22、23 行输出展示了如何使用 <code>toArray()</code> 方法将任意的 <strong>Collection</strong> 转换为数组。这是一个重载方法，其无参版本返回一个 <strong>Object</strong> 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 <strong>List</strong> 中的所有元素（就像本例一样），则 <code>toArray()</code> 会创建一个具有合适尺寸的新数组。 <strong>Pet</strong> 对象有一个 <code>id()</code> 方法，可以在所产生的数组中的对象上调用这个方法。</p>
<h2 id="迭代器Iterators"><a href="#迭代器Iterators" class="headerlink" title="迭代器Iterators"></a>迭代器Iterators</h2><p>在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 <strong>List</strong> ， <code>add()</code> 是插入元素的一种方式， <code>get()</code> 是获取元素的一种方式。</p>
<p>如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 <strong>List</strong> 编码的，但是后来发现如果能够将相同的代码应用于 <strong>Set</strong> 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？</p>
<p><em>迭代器</em>（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为<em>轻量级对象</em>（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p>
<ol>
<li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li>
<li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li>
<li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li>
<li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li>
</ol>
<p>为了观察它的工作方式，这里再次使用<a target="_blank" rel="noopener" href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book">类型信息</a>章节中的 <strong>Pet</strong> 工具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SimpleIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">12</span>);</span><br><span class="line">    Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// A simpler approach, when possible:</span></span><br><span class="line">    <span class="keyword">for</span>(Pet p : pets)</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// An Iterator can also remove elements:</span></span><br><span class="line">    it = pets.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>有了 <strong>Iterator</strong> ，就不必再为集合中元素的数量操心了。这是由 <code>hasNext()</code> 和 <code>next()</code> 关心的事情。</p>
<p>如果只是想向前遍历 <strong>List</strong> ，并不打算修改 <strong>List</strong> 对象本身，那么使用 <em>for-in</em> 语法更加简洁。</p>
<p><strong>Iterator还可以删除由 <code>next()</code> 生成的最后一个元素，这意味着在调用 <code>remove()</code> 之前必须先调用 <code>next()</code> 。</strong></p>
<p>在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。</p>
<p>现在考虑创建一个 <code>display()</code> 方法，它不必知晓集合的确切类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossCollectionIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> HashSet&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> TreeSet&lt;&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>display()</code> 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 <strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。</p>
<p>我们可以使用 <strong>Iterable</strong> 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 <strong>Iterator</strong> 的任何东西”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration2.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossCollectionIteration2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterable&lt;Pet&gt; ip)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Pet&gt; it = ip.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> HashSet&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> TreeSet&lt;&gt;(pets);</span><br><span class="line">    display(pets);</span><br><span class="line">    display(petsLL);</span><br><span class="line">    display(petsHS);</span><br><span class="line">    display(petsTS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里所有的类都是 <strong>Iterable</strong> ，所以现在对 <code>display()</code> 的调用显然更简单。</p>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。 下面的示例演示了所有这些能力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ListIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">      System.out.print(it.next() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.nextIndex() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// Backwards:</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasPrevious())</span><br><span class="line">      System.out.print(it.previous().id() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.set(Pets.get());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug,</span></span><br><span class="line"><span class="comment">5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;</span></span><br><span class="line"><span class="comment">7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster,</span></span><br><span class="line"><span class="comment">EgyptianMau]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Pets.get()</code> 方法用来从位置 3 开始替换 <strong>List</strong> 中的所有 Pet 对象。</p>
<h2 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h2><p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p>
<p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p>
<ul>
<li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>addFirst()</code> 在列表的开头插入一个元素。</li>
<li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>
<li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li>
</ul>
<p>下面的示例展示了这些功能之间基本的相似性和差异性。它并不是重复执行 <strong>ListFeatures.java</strong> 中所示的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/LinkedListFeatures.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListFeatures</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Pet&gt; pets =</span><br><span class="line">      <span class="keyword">new</span> LinkedList&lt;&gt;(Pets.list(<span class="number">5</span>));</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    <span class="comment">// Identical:</span></span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.getFirst(): &quot;</span> + pets.getFirst());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.element(): &quot;</span> + pets.element());</span><br><span class="line">    <span class="comment">// Only differs in empty-list behavior:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pets.peek(): &quot;</span> + pets.peek());</span><br><span class="line">    <span class="comment">// Identical; remove and return the first element:</span></span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.remove(): &quot;</span> + pets.remove());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.removeFirst(): &quot;</span> + pets.removeFirst());</span><br><span class="line">    <span class="comment">// Only differs in empty-list behavior:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pets.poll(): &quot;</span> + pets.poll());</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    pets.addFirst(<span class="keyword">new</span> Rat());</span><br><span class="line">    System.out.println(<span class="string">&quot;After addFirst(): &quot;</span> + pets);</span><br><span class="line">    pets.offer(Pets.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;After offer(): &quot;</span> + pets);</span><br><span class="line">    pets.add(Pets.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;After add(): &quot;</span> + pets);</span><br><span class="line">    pets.addLast(<span class="keyword">new</span> Hamster());</span><br><span class="line">    System.out.println(<span class="string">&quot;After addLast(): &quot;</span> + pets);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;pets.removeLast(): &quot;</span> + pets.removeLast());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug]</span></span><br><span class="line"><span class="comment">pets.getFirst(): Rat</span></span><br><span class="line"><span class="comment">pets.element(): Rat</span></span><br><span class="line"><span class="comment">pets.peek(): Rat</span></span><br><span class="line"><span class="comment">pets.remove(): Rat</span></span><br><span class="line"><span class="comment">pets.removeFirst(): Manx</span></span><br><span class="line"><span class="comment">pets.poll(): Cymric</span></span><br><span class="line"><span class="comment">[Mutt, Pug]</span></span><br><span class="line"><span class="comment">After addFirst(): [Rat, Mutt, Pug]</span></span><br><span class="line"><span class="comment">After offer(): [Rat, Mutt, Pug, Cymric]</span></span><br><span class="line"><span class="comment">After add(): [Rat, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]</span></span><br><span class="line"><span class="comment">pets.removeLast(): Hamster</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Pets.list()</code> 的结果被传递给 <strong>LinkedList</strong> 的构造器，以便使用它来填充 <strong>LinkedList</strong> 。如果查看 <strong>Queue</strong> 接口就会发现，它在 <strong>LinkedList</strong> 的基础上添加了 <code>element()</code> ， <code>offer()</code> ， <code>peek()</code> ， <code>poll()</code> 和 <code>remove()</code> 方法，以使其可以成为一个 <strong>Queue</strong> 的实现。 <strong>Queue</strong> 的完整示例将在本章稍后给出。</p>
<h2 id="堆栈Stack"><a href="#堆栈Stack" class="headerlink" title="堆栈Stack"></a>堆栈Stack</h2><p>堆栈是“后进先出”（LIFO）集合。它有时被称为<em>叠加栈</em>（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。经常用来类比栈的事物是带有弹簧支架的自助餐厅托盘。最后装入的托盘总是最先拿出来使用的。</p>
<p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 <strong>ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// collections/StackTest.java</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class StackTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">    for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    while(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + &quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Output:</span><br><span class="line">fleas has dog My</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>即使它是作为一个堆栈在使用，我们仍然必须将其声明为 <strong>Deque</strong> 。有时一个名为 <strong>Stack</strong> 的类更能把事情讲清楚：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// onjava/Stack.java</span><br><span class="line">// A Stack class built with an ArrayDeque</span><br><span class="line">package onjava;</span><br><span class="line">import java.util.Deque;</span><br><span class="line">import java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line">public class Stack&lt;T&gt; &#123;</span><br><span class="line">  private Deque&lt;T&gt; storage = new ArrayDeque&lt;&gt;();</span><br><span class="line">  public void push(T v) &#123; storage.push(v); &#125;</span><br><span class="line">  public T peek() &#123; return storage.peek(); &#125;</span><br><span class="line">  public T pop() &#123; return storage.pop(); &#125;</span><br><span class="line">  public boolean isEmpty() &#123; return storage.isEmpty(); &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return storage.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入了使用泛型的类定义的最简单的可能示例。类名称后面的 告诉编译器这是一个参数化类型，而其中的类型参数 <strong>T</strong> 会在使用类时被实际类型替换。基本上，这个类是在声明“我们在定义一个可以持有 <strong>T</strong> 类型对象的 <strong>Stack</strong> 。” <strong>Stack</strong> 是使用 <strong>ArrayDeque</strong> 实现的，而 <strong>ArrayDeque</strong> 也被告知它将持有 <strong>T</strong> 类型对象。注意， <code>push()</code> 接受类型为 <strong>T</strong> 的对象，而 <code>peek()</code> 和 <code>pop()</code> 返回类型为 <strong>T</strong> 的对象。 <code>peek()</code> 方法将返回栈顶元素，但并不将其从栈顶删除，而 <code>pop()</code> 删除并返回顶部元素。</p>
<p>如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类（在<a target="_blank" rel="noopener" href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book">附录：集合主题</a>中将会看到， <strong>Java 1.0</strong> 设计者在创建 <strong>java.util.Stack</strong> 时，就犯了这个错误）。使用组合，可以选择要公开的方法以及如何命名它们。</p>
<p>下面将使用 <strong>StackTest.java</strong> 中的相同代码来演示这个新的 <strong>Stack</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackTest2.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果想在自己的代码中使用这个 <strong>Stack</strong> 类，当在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能会与 <strong>java.util</strong> 包中的 <strong>Stack</strong> 发生冲突。例如，如果我们在上面的例子中导入 **java.util.***，那么就必须使用包名来防止冲突：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackCollision.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackCollision</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    onjava.Stack&lt;String&gt; stack = <span class="keyword">new</span> onjava.Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    java.util.Stack&lt;String&gt; stack2 =</span><br><span class="line">      <span class="keyword">new</span> java.util.Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack2.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack2.empty())</span><br><span class="line">      System.out.print(stack2.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>尽管已经有了 <strong>java.util.Stack</strong> ，但是 <strong>ArrayDeque</strong> 可以产生更好的 <strong>Stack</strong> ，因此更可取。</p>
<p>还可以使用显式导入来控制对“首选” <strong>Stack</strong> 实现的选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import onjava.Stack;</span><br></pre></td></tr></table></figure>

<p>现在,任何对 <strong>Stack</strong> 的引用都将选择 <strong>onjava</strong> 版本，而在选择 <strong>java.util.Stack</strong> 时，必须使用全限定名称（full qualification）。</p>
</div></div><a class="button-hover more" href="/2020/05/26/JAVA%E5%AE%B9%E5%99%A8%E7%B1%BB/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fas fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2021 By injune</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/haru02.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":50,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>