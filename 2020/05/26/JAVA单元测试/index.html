<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="单元测试"><meta name="keywords" content="测试,junit,testng,java"><meta name="author" content="injune,undefined"><meta name="copyright" content="injune"><title>单元测试【injune'zone】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="injune'zone" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0818"><span class="toc-number">1.</span> <span class="toc-text">0818</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.</span> <span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Junit"><span class="toc-number">1.1.1.</span> <span class="toc-text">Junit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JUnit-5-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">JUnit 5 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE-1-JUnit-5-%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">图 1. JUnit 5 的架构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-JUnit-Jupiter-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">使用 JUnit Jupiter 编写测试内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JUnit-Jupiter-API"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">JUnit Jupiter API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JUnit-Jupiter-Test-Engine"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">JUnit Jupiter Test Engine</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-JUnit-Platform-%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">使用 JUnit Platform 运行测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95%E7%9A%84-API"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">用于发现测试的 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%9A%84-API"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">用于执行测试的 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%90%91%E5%85%BC%E5%AE%B9%E6%80%A7%EF%BC%9AJUnit-Vintage"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">后向兼容性：JUnit Vintage</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE-2-JUnit-5-%E5%8C%85%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.1.1.7.1.</span> <span class="toc-text">图 2. JUnit 5 包关系图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#opentest4j-%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">opentest4j 的用途</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-JUnit-Jupiter-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">使用 JUnit Jupiter 编写测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8-1-JUnit-4-%E4%B8%8E-JUnit-5-%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">表 1. JUnit 4 与 JUnit 5 中的注解比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">使用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-1-%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">清单 1. 基本注解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">断言</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8-2-JUnit-Jupiter-%E4%B8%AD%E7%9A%84%E6%96%AD%E8%A8%80"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">表 2. JUnit Jupiter 中的断言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-2-%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84-JUnit-Jupiter-%E6%96%AD%E8%A8%80"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">清单 2. 示例应用程序中的 JUnit Jupiter 断言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-assertAll"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">方法 @assertAll()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-3-assertAll"><span class="toc-number">1.1.2.3.4.</span> <span class="toc-text">清单 3. assertAll()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-assertThrows"><span class="toc-number">1.1.2.3.5.</span> <span class="toc-text">方法 @assertThrows()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-4-assertThrows"><span class="toc-number">1.1.2.3.6.</span> <span class="toc-text">清单 4. assertThrows()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">前置条件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80%E8%BF%98%E6%98%AF%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.2.4.1.</span> <span class="toc-text">使用断言还是前置条件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B8%85%E6%99%B0%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">嵌套单元测试，实现清晰的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E5%8D%95-5-%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%88%96-null-%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.2.5.1.</span> <span class="toc-text">清单 5. 传递一个空或 null 数组引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-JUnit-Platform-%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95-1"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">使用 JUnit Platform 运行测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%8B%E9%9A%86-HelloJUnit5-%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.2.6.1.</span> <span class="toc-text">克隆 HelloJUnit5 示例应用程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8-Eclipse-IDE-%E4%B8%AD%E8%BF%90%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.2.6.2.</span> <span class="toc-text">在 Eclipse IDE 中运行单元测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Maven-%E8%BF%90%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.2.6.3.</span> <span class="toc-text">使用 Maven 运行单元测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Running-unit-tests-with-Gradle"><span class="toc-number">1.1.2.6.4.</span> <span class="toc-text">Running unit tests with Gradle</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%83%E4%B9%A0"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">测试练习</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E5%86%99-JUnit-Jupiter-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.2.7.1.</span> <span class="toc-text">编写 JUnit Jupiter 单元测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE-3-Javadoc-%E8%A7%86%E5%9B%BE"><span class="toc-number">1.1.2.7.2.</span> <span class="toc-text">图 3. Javadoc 视图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8-Eclipse-%E4%B8%AD%E8%BF%90%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.2.7.3.</span> <span class="toc-text">在 Eclipse 中运行单元测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-App-%E7%B1%BB%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87%E6%A3%80%E6%9F%A5"><span class="toc-number">1.1.2.7.4.</span> <span class="toc-text">实现 App 类，直到单元测试通过检查</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">第 1 部分小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mockito"><span class="toc-number">1.1.3.</span> <span class="toc-text">mockito</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">injune</div><div class="author-info-description">injune的个人空间</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/YoungYJMaze" target="_blank">GitHub<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="mailto:q2235133943@gmail.com" target="_blank">E-Mail<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">24</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">31</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">injune'zone</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">单元测试</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-05-26 | 更新于 2021-10-18</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%B5%8B%E8%AF%95/">测试</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/junit/">junit</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/testng/">testng</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a></div></div></div><div class="main-content"><h1 id="0818"><a href="#0818" class="headerlink" title="0818"></a>0818</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>人们倾向于将术语 <em>JUnit 5</em> 和 <em>JUnit Jupiter</em> 当作同义词使用。在大部分情况下，这种互换使用没有什么问题。但是，一定要认识到这两个术语是不同的。<em>JUnit Jupiter</em> 是使用 JUnit 5 编写测试内容的 API。<em>JUnit 5</em> 是一个项目名称（和版本），其 3 个主要模块关注不同的方面：JUnit Jupiter、JUnit Platform 和 JUnit Vintage。</p>
<p>当我提及 JUnit Jupiter 时，指的是编写单元测试的 API；提及 JUnit 5 时，指的是整个项目。</p>
<h4 id="JUnit-5-概述"><a href="#JUnit-5-概述" class="headerlink" title="JUnit 5 概述"></a>JUnit 5 概述</h4><p>以前的 JUnit 版本都是整体式的。除了在 4.4 版中包含 Hamcrest JAR，JUnit 基本来讲就是一个很大的 JAR 文件。测试内容编写者 — 像您我这样的开发人员 — 和工具供应商都使用它的 API，但后者使用很多内部 JUnit API。</p>
<p>大量使用内部 API 给 JUnit 的维护者造成了一些麻烦，并且留给他们推动该技术发展的选择余地不多。来自 <a target="_blank" rel="noopener" href="http://junit.org/junit5/docs/current/user-guide/#api-evolution"><em>JUnit 5 用户指南</em></a>：</p>
<blockquote>
<p>“在 JUnit 4 中，只有外部扩展编写者和工具构建者才使用最初作为内部结构而添加的许多功能。这让更改 JUnit 4 变得特别困难，有时甚至根本不可能。”</p>
</blockquote>
<p>JUnit Lambda（现在称为 JUnit 5）团队决定将 JUnit 重新设计为两个明确且不同的关注区域：</p>
<ul>
<li>一个是编写测试内容的 API。</li>
<li>一个是发现和运行这些测试的 API。</li>
</ul>
<p>这些关注区域现在已整合到 JUnit 5 的架构中，并且它们是明确分离的。图 1 演示了新架构（图像来自 <a target="_blank" rel="noopener" href="https://blog.codefx.org/design/architecture/junit-5-architecture/">Nicolai Parlog</a>）：</p>
<h5 id="图-1-JUnit-5-的架构"><a href="#图-1-JUnit-5-的架构" class="headerlink" title="图 1. JUnit 5 的架构"></a>图 1. JUnit 5 的架构</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-1.png" alt="JUnit 5 架构示意图。"></p>
<p>如果仔细查看图 1，就会发现 JUnit 5 的架构有多么强大。好了，让我们<em>仔细</em>看看这个架构。右上角的方框表明，对 JUnit 5 而言，JUnit Jupiter API 只是<em>另一个 API</em>！因为 JUnit Jupiter 的组件遵循新的架构，所以它们可应用 JUnit 5，但您可以轻松定义不同的测试框架。只要一个框架实现了 <code>TestEngine</code> 接口，就可以将它插入任何支持 <code>junit-platform-engine</code> 和 <code>junit-platform-launcher</code> API 的工具中！</p>
<p>我仍然认为 JUnit Jupiter 非常特殊（毕竟我即将用一整篇教程来介绍它），但 JUnit 5 团队完成的工作确实具有开创性。我只是想指出这一点。我们继续看看图 1，直到我们完全达成一致。</p>
<h4 id="使用-JUnit-Jupiter-编写测试内容"><a href="#使用-JUnit-Jupiter-编写测试内容" class="headerlink" title="使用 JUnit Jupiter 编写测试内容"></a>使用 JUnit Jupiter 编写测试内容</h4><p>就测试编写者而言，任何符合 JUnit 规范的测试框架（包括 JUnit Jupiter）都包含两个组件：</p>
<ul>
<li>我们为其编写测试的 API。</li>
<li>理解这个特定 API 的 JUnit <code>TestEngine</code> 实现。</li>
</ul>
<p>对于本教程，前者是 JUnit Jupiter API，后者是 JUnit Jupiter Test Engine。我将介绍这二者。</p>
<h5 id="JUnit-Jupiter-API"><a href="#JUnit-Jupiter-API" class="headerlink" title="JUnit Jupiter API"></a>JUnit Jupiter API</h5><p>作为开发人员，您将使用 JUnit Jupiter API 创建单元测试来测试您的应用程序代码。使用该 API 的基本特性 — 注解、断言等 — 是本部分教程的主要关注点。</p>
<p>JUnit Jupiter API 的设计让您可通过插入各种生命周期回调来扩展它的功能。您将在第 2 部分中了解如何使用这些回调完成有趣的工作，比如运行参数化测试，将参数传递给测试方法，等等。</p>
<h5 id="JUnit-Jupiter-Test-Engine"><a href="#JUnit-Jupiter-Test-Engine" class="headerlink" title="JUnit Jupiter Test Engine"></a>JUnit Jupiter Test Engine</h5><p>您将使用 JUnit Jupiter Test Engine 发现和执行 JUnit Jupiter 单元测试。该测试引擎实现了 JUnit Platform 中包含的 <code>TestEngine</code> 接口。可将 <code>TestEngine</code> 看作单元测试与用于启动它们的工具（比如 IDE）之间的桥梁。</p>
<h4 id="使用-JUnit-Platform-运行测试"><a href="#使用-JUnit-Platform-运行测试" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h4><p>在 JUnit 术语中，运行单元测试的过程分为两部分：</p>
<ul>
<li><em>发现</em>测试和创建<em>测试计划</em>。</li>
<li><em>启动</em>测试计划，以 (1) 执行测试和 (2) 向用户报告结果。</li>
</ul>
<h4 id="用于发现测试的-API"><a href="#用于发现测试的-API" class="headerlink" title="用于发现测试的 API"></a>用于发现测试的 API</h4><p>用于发现测试和创建测试计划的 API 包含在 JUnit Platform 中，由一个 <code>TestEngine</code> 实现。该测试框架将测试发现功能封装到其 <code>TestEngine</code> 实现中。JUnit Platform 负责使用 IDE 和构建工具（比如 Gradle 和 Maven）发起测试发现流程。</p>
<p>测试发现的目的是创建测试计划，该计划中包含一个<em>测试规范</em>。测试规范包含以下组件：</p>
<ul>
<li><p>选择器</p>
<p>，比如：</p>
<ul>
<li>要扫描哪个包来寻找测试类</li>
<li>特定的类名称</li>
<li>特定的方法</li>
<li>类路径根文件夹</li>
</ul>
</li>
<li><p>过滤器</p>
<p>，比如：</p>
<ul>
<li>类名称模式（比如 “.*Test”）</li>
<li>标签（将在第 2 部分中讨论）</li>
<li>特定的测试引擎（比如 “junit-jupiter”）</li>
</ul>
</li>
</ul>
<p>测试计划是根据测试规范所发现的所有测试类、这些类中的测试方法、测试引擎等的分层视图。测试计划准备就绪后，就可以执行了。</p>
<h4 id="用于执行测试的-API"><a href="#用于执行测试的-API" class="headerlink" title="用于执行测试的 API"></a>用于执行测试的 API</h4><p>用于执行测试的 API 包含在 JUnit Platform 中，由一个或多个 <code>TestEngine</code> 实现。测试框架将测试执行功能封装在它们的 <code>TestEngine</code> 实现中，但 JUnit Platform 负责发起测试执行流程。通过 IDE 和构建工具（比如 Gradle 和 Maven）发起测试执行工作。</p>
<p>一个名为 <code>Launcher</code> 的 JUnit Platform 组件负责执行在测试发现期间创建的测试计划。某个流程 — 假设是您的 IDE — 通过 JUnit Platform（具体来讲是 <code>junit-platform-launcher</code> API）发起测试执行流程。这时，JUnit Platform 将测试计划连同 <code>TestExecutionListener</code> 一起传递给 <code>Launcher</code>。<code>TestExecutionListener</code> 将报告测试执行结果，从而在您的 IDE 中显示该结果。</p>
<p>测试执行流程的目的是向用户准确报告在测试运行时发生了哪些事件。这包括测试成功和失败报告，以及伴随失败而生成的消息，帮助用户理解所发生的事件。</p>
<h4 id="后向兼容性：JUnit-Vintage"><a href="#后向兼容性：JUnit-Vintage" class="headerlink" title="后向兼容性：JUnit Vintage"></a>后向兼容性：JUnit Vintage</h4><p>许多组织对 JUnit 3 和 4 进行了大力投资，因此无法承担向 JUnit 5 的大规模转换。了解到这一点后，JUnit 5 团队提供了 <code>junit-vintage-engine</code> 和 <code>junit-jupiter-migration-support</code> 组件来帮助企业进行迁移。</p>
<p>对 JUnit Platform 而言，JUnit Vintage 只是另一个测试框架，包含自己的 <code>TestEngine</code> 和 API（具体来讲是 JUnit 4 API）。</p>
<p>图 2 显示了各种 JUnit 5 包之间的依赖关系。</p>
<h5 id="图-2-JUnit-5-包关系图"><a href="#图-2-JUnit-5-包关系图" class="headerlink" title="图 2. JUnit 5 包关系图"></a>图 2. JUnit 5 包关系图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-2.png" alt="JUnit 5 包示意图。"></p>
<h4 id="opentest4j-的用途"><a href="#opentest4j-的用途" class="headerlink" title="opentest4j 的用途"></a>opentest4j 的用途</h4><p>支持 JUnit 的测试框架在如何处理测试执行期间抛出的异常方面有所不同。JVM 上的测试没有统一标准，这是 JUnit 团队一直要面对的问题。除了 <code>java.lang.AssertionError</code>，测试框架还必须定义自己的异常分层结构，或者将自身与 JUnit 支持的异常结合起来（或者在某些情况下同时采取两种方法）。</p>
<p><strong>支持 opentest4j</strong>：要加入 Open Test Alliance for the JVM，或者提供反馈来帮助该联盟推进工作，请访问 <a target="_blank" rel="noopener" href="https://github.com/ota4j-team/opentest4j">opentest4j</a> Github 存储库并单击 <em>CONTRIBUTING.md</em> 链接。</p>
<p>为了解决一致性问题，JUnit 团队提议建立一个开源项目，该项目目前称为 Open Test Alliance for the JVM（JVM 开放测试联盟）。该联盟在此阶段仅是一个提案，它仅定义了初步的异常分层结构。但是，JUnit 5 使用 <code>opentest4j</code> 异常。（可在图 2 中看到这一点；请注意从 <code>junit-jupiter-api</code> 和 <code>junit-platform-engine</code> 包到 <code>opentest4j</code> 包的依赖线。）</p>
<p>现在您已基本了解各种 JUnit 5 组件如何结合在一起，是时候使用 JUnit Jupiter API 编写一些测试了！</p>
<h3 id="使用-JUnit-Jupiter-编写测试"><a href="#使用-JUnit-Jupiter-编写测试" class="headerlink" title="使用 JUnit Jupiter 编写测试"></a>使用 JUnit Jupiter 编写测试</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>从 JUnit 4 开始，注解 (annotation) 就成为测试框架的核心特性，这一趋势在 JUnit 5 中得以延续。我无法介绍 JUnit 5 的所有注解，本节仅简要介绍最常用的注解。</p>
<p>首先，我将比较 JUnit 4 中与 JUnit 5 中的注解。JUnit 5 团队更改了一些注解的名称，让它们更直观，同时保持功能不变。如果您正在使用 JUnit 4，下表将帮助您适应这些更改。</p>
<h5 id="表-1-JUnit-4-与-JUnit-5-中的注解比较"><a href="#表-1-JUnit-4-与-JUnit-5-中的注解比较" class="headerlink" title="表 1. JUnit 4 与 JUnit 5 中的注解比较"></a>表 1. JUnit 4 与 JUnit 5 中的注解比较</h5><table>
<thead>
<tr>
<th>JUnit 5</th>
<th>JUnit 4</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>@Test</td>
<td>被注解的方法是一个测试方法。与 JUnit 4 相同。</td>
</tr>
<tr>
<td>@BeforeAll</td>
<td>@BeforeClass</td>
<td>被注解的（静态）方法将在当前类中的所有 @Test 方法前执行一次。</td>
</tr>
<tr>
<td>@BeforeEach</td>
<td>@Before</td>
<td>被注解的方法将在当前类中的每个 @Test 方法前执行。</td>
</tr>
<tr>
<td>@AfterEach</td>
<td>@After</td>
<td>被注解的方法将在当前类中的每个 @Test 方法后执行。</td>
</tr>
<tr>
<td>@AfterAll</td>
<td>@AfterClass</td>
<td>被注解的（静态）方法将在当前类中的所有 @Test 方法后执行一次。</td>
</tr>
<tr>
<td>@Disabled</td>
<td>@Ignore</td>
<td>被注解的方法不会执行（将被跳过），但会报告为已执行。</td>
</tr>
</tbody></table>
<h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>接下来看看一些使用这些注解的示例。尽管一些注解已在 JUnit 5 中重命名，但如果您使用过 JUnit 4，应熟悉它们的功能。清单 1 中的代码来自 <code>JUnit5AppTest.java</code>，可在 <a target="_blank" rel="noopener" href="https://github.com/makotogo/HelloJUnit5">HelloJUnit5</a> 示例应用程序中找到。</p>
<h5 id="清单-1-基本注解"><a href="#清单-1-基本注解" class="headerlink" title="清单 1. 基本注解"></a>清单 1. 基本注解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing using JUnit 5&quot;)``public class JUnit5AppTest &#123;`` ` ` ``private static final Logger log = LoggerFactory.getLogger(JUnit5AppTest.class);`` ` ` ``private App classUnderTest;`` ` ` ``@BeforeAll`` ``public static void init() &#123;``  ``// Do something before ANY test is run in this class`` ``&#125;`` ` ` ``@AfterAll`` ``public static void done() &#123;``  ``// Do something after ALL tests in this class are run`` ``&#125;`` ` ` ``@BeforeEach`` ``public void setUp() throws Exception &#123;``  ``classUnderTest = new App();`` ``&#125;`` ` ` ``@AfterEach`` ``public void tearDown() throws Exception &#123;``  ``classUnderTest = null;`` ``&#125;`` ` ` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void aTest() &#123;``  ``log.info(&quot;As written, this test will always pass!&quot;);``  ``assertEquals(4, (2 + 2));`` ``&#125;`` ` ` ``@Test`` ``@Disabled`` ``@DisplayName(&quot;A disabled test&quot;)`` ``void testNotRun() &#123;``  ``log.info(&quot;This test will not run (it is disabled, silly).&quot;);`` ``&#125;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>看看上面突出显示行中的注解：</p>
<ul>
<li>第 1 行：<code>@RunWith</code> 连同它的参数 <code>JUnitPlatform.class</code>（一个基于 JUnit 4 且理解 JUnit Platform 的 <code>Runner</code>）让您可以在 Eclipse 内运行 JUnit Jupiter 单元测试。Eclipse 尚未原生支持 JUnit 5。未来，Eclipse 将提供原生的 JUnit 5 支持，那时我们不再需要此注解。</li>
<li>第 2 行：<code>@DisplayName</code> 告诉 JUnit 在报告测试结果时显示 <code>String</code> “Testing using JUnit 5”，而不是测试类的名称。</li>
<li>第 9 行：<code>@BeforeAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之前</em>运行 <code>init()</code> 方法<strong>一次</strong>。</li>
<li>第 14 行：<code>@AfterAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之后</em>运行 <code>done()</code> 方法<strong>一次</strong>。</li>
<li>第 19 行：<code>@BeforeEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之前</em>运行 <code>setUp()</code> 方法。</li>
<li>第 24 行：<code>@AfterEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之后</em>运行 <code>tearDown()</code> 方法。</li>
<li>第 29 行：<code>@Test</code> 告诉 JUnit，<code>aTest()</code> 方法是一个 JUnit Jupiter 测试方法。</li>
<li>第 37 行：<code>@Disabled</code> 告诉 JUnit 不运行此 <code>@Test</code> 方法，因为它已被禁用。</li>
</ul>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p><em>断言 (assertion)</em> 是 <code>org.junit.jupiter.api.Assertions</code> 类上的众多静态方法之一。断言用于测试一个条件，该条件必须计算为 <code>true</code>，测试才能继续执行。</p>
<p>如果断言失败，测试会在断言所在的代码行上停止，并生成断言失败报告。如果断言成功，测试会继续执行下一行代码。</p>
<p>表 2 中列出的所有 JUnit Jupiter 断言方法都接受一个可选的 <code>message</code> 参数（作为最后一个参数），以显示断言是否失败，而不是显示标准的缺省消息。</p>
<h5 id="表-2-JUnit-Jupiter-中的断言"><a href="#表-2-JUnit-Jupiter-中的断言" class="headerlink" title="表 2. JUnit Jupiter 中的断言"></a>表 2. JUnit Jupiter 中的断言</h5><table>
<thead>
<tr>
<th>断言方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>assertEquals(expected, actual)</code></td>
<td>如果 <em>expected</em> 不等于 <em>actual</em>，则断言失败。</td>
</tr>
<tr>
<td><code>assertFalse(booleanExpression)</code></td>
<td>如果 <em>booleanExpression</em> 不是 <code>false</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertNull(actual)</code></td>
<td>如果 <em>actual</em> 不是 <code>null</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertNotNull(actual)</code></td>
<td>如果 <em>actual</em> 是 <code>null</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertTrue(booleanExpression)</code></td>
<td>如果 <em>booleanExpression</em> 不是 <code>true</code>，则断言失败。</td>
</tr>
</tbody></table>
<p>清单 2 给出了一个使用这些断言的示例，该示例来自 HelloJUnit5 示例应用程序。</p>
<h5 id="清单-2-示例应用程序中的-JUnit-Jupiter-断言"><a href="#清单-2-示例应用程序中的-JUnit-Jupiter-断言" class="headerlink" title="清单 2. 示例应用程序中的 JUnit Jupiter 断言"></a>清单 2. 示例应用程序中的 JUnit Jupiter 断言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertEquals;``import static org.junit.jupiter.api.Assertions.assertFalse;``import static org.junit.jupiter.api.Assertions.assertNotNull;``import static org.junit.jupiter.api.Assertions.assertNull;``import static org.junit.jupiter.api.Assertions.assertTrue;``.``.`` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void dummyTest() &#123;``  ``int expected = 4;``  ``int actual = 2 + 2;``  ``assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;);``  ``//``  ``Object nullValue = null;``  ``assertFalse(nullValue != null);``  ``assertNull(nullValue);``  ``assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;);``  ``assertTrue(nullValue == null);``  ``.``  ``.`` ``&#125;</span><br></pre></td></tr></table></figure>

<p>看看上面突出显示行中的断言：</p>
<ul>
<li>第 13 行：<code>assertEquals</code>：如果第一个参数值 (4) 不等于第二个参数值 (2+2)，则断言失败。在报告断言失败时使用用户提供的消息（该方法的第 3 个参数）。</li>
<li>第 16 行：<code>assertFalse</code>：表达式 <code>nullValue != null</code> 必须为 <code>false</code>，否则断言失败。</li>
<li>第 17 行：<code>assertNull</code>：<code>nullValue</code> 参数必须为 <code>null</code>，否则断言失败。</li>
<li>第 18 行：<code>assertNotNull</code>：<code>String</code> 文字值 “A String” 不得为 <code>null</code>，否则断言失败并报告消息 “INCONCEIVABLE!”（而不是缺省的 “Assertion failed” 消息）。</li>
<li>第 19 行：<code>assertTrue</code>：如果表达式 <code>nullValue == null</code> 不等于 <code>true</code>，则断言失败。</li>
</ul>
<p>除了支持这些标准断言，JUnit Jupiter AP 还提供了多个新断言。下面介绍其中的两个。</p>
<h5 id="方法-assertAll"><a href="#方法-assertAll" class="headerlink" title="方法 @assertAll()"></a>方法 @assertAll()</h5><p>清单 3 中的 <code>@assertAll()</code> 方法给出了清单 2 中看到的相同断言，但包装在一个新的断言方法中：</p>
<h5 id="清单-3-assertAll"><a href="#清单-3-assertAll" class="headerlink" title="清单 3. assertAll()"></a>清单 3. assertAll()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertAll;``.``.``@Test``@DisplayName(&quot;Dummy test&quot;)``void dummyTest() &#123;`` ``int expected = 4;`` ``int actual = 2 + 2;`` ``Object nullValue = null;`` ``.`` ``.`` ``assertAll(``   ``&quot;Assert All of these&quot;,``   ``() -&gt; assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;),``   ``() -&gt; assertFalse(nullValue != null),``   ``() -&gt; assertNull(nullValue),``   ``() -&gt; assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;),``   ``() -&gt; assertTrue(nullValue == null));``&#125;</span><br></pre></td></tr></table></figure>

<p><code>assertAll()</code> 的有趣之处在于，它包含的<em>所有</em>断言都会执行，即使一个或多个断言失败也是如此。与此相反，在清单 2 中的代码中，如果<em>任何</em>断言失败，测试就会在该位置失败，意味着不会执行任何其他断言。</p>
<h5 id="方法-assertThrows"><a href="#方法-assertThrows" class="headerlink" title="方法 @assertThrows()"></a>方法 @assertThrows()</h5><p>在某些条件下，接受测试的类应抛出异常。JUnit 4 通过 <code>expected =</code> 方法参数或一个 <code>@Rule</code> 提供此能力。与此相反，JUnit Jupiter 通过 <code>Assertions</code> 类提供此能力，使它与其他断言更加一致。</p>
<p>我们将所预期的异常视为可以进行断言的另一个条件，因此 <code>Assertions</code> 包含处理此条件的方法。清单 4 引入了新的 <code>assertThrows()</code> 断言方法。</p>
<h5 id="清单-4-assertThrows"><a href="#清单-4-assertThrows" class="headerlink" title="清单 4. assertThrows()"></a>清单 4. assertThrows()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertThrows;``import static org.junit.jupiter.api.Assertions.assertEquals;``.``.``@Test()``@DisplayName(&quot;Empty argument&quot;)``public void testAdd_ZeroOperands_EmptyArgument() &#123;`` ``long[] numbersToSum = &#123;&#125;;`` ``assertThrows(IllegalArgumentException.class, () -&gt; classUnderTest.add(numbersToSum));``&#125;</span><br></pre></td></tr></table></figure>

<p>请注意第 9 行：如果对 <code>classUnderTest.add()</code> 的调用没有抛出 <code>IllegalArgumentException</code>，则断言失败。</p>
<h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>前置条件 (Assumption) 与断言类似，但前置条件必须为 true，否则测试将<em>中止</em>。与此相反，当断言失败时，则将测试视为已<em>失败</em>。测试方法只应在某些条件 —<em>前置条件</em>下执行时，前置条件很有用。</p>
<p><em>前置条件</em>是 <code>org.junit.jupiter.api.Assumptions</code> 类的静态方法。要理解前置条件的价值，只需一个简单的示例。</p>
<p>假如您只想在星期五运行一个特定的单元测试（我假设您有自己的理由）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test``@DisplayName(&quot;This test is only run on Fridays&quot;)``public void testAdd_OnlyOnFriday() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumeTrue(ldt.getDayOfWeek().getValue() == 5);`` ``// Remainder of test (only executed if assumption holds)...``&#125;</span><br></pre></td></tr></table></figure>

<p>在此情况下，如果条件不成立（第 5 行），就不会执行 lambda 表达式的内容。</p>
<h5 id="使用断言还是前置条件"><a href="#使用断言还是前置条件" class="headerlink" title="使用断言还是前置条件"></a>使用断言还是前置条件</h5><p>二者的区别可能很细微，所以可使用这条经验法则：使用断言<em>检查一个测试方法的结果</em>。使用前置条件<em>确定是否运行测试方法</em>。不会将已中止的测试报告为失败，意味着这种失败不会中断构建工作。</p>
<p>请注意第 5 行：如果该条件不成立，则跳过该测试。在此情况下，该测试不是在星期五 (5) 运行的。这不会影响项目的 “绿色” 部分，而且不会导致构建失败；会跳过 <code>assumeTrue()</code> 后的测试方法中的所有代码。</p>
<p>如果在前置条件成立时仅应执行测试方法的一<em>部分</em>，可以使用 <code>assumingThat()</code> 方法编写上述条件，该方法使用 lambda 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test``@DisplayName(&quot;This test is only run on Fridays (with lambda)&quot;)``public void testAdd_OnlyOnFriday_WithLambda() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumingThat(ldt.getDayOfWeek().getValue() == 5,``   ``() -&gt; &#123;``    ``// Execute this if assumption holds...``   ``&#125;);`` ``// Execute this regardless``&#125;</span><br></pre></td></tr></table></figure>

<p>注意，无论 <code>assumingThat()</code> 中的前置条件成立与否，都会执行 lambda 表达式后的所有代码。</p>
<h4 id="嵌套单元测试，实现清晰的结构"><a href="#嵌套单元测试，实现清晰的结构" class="headerlink" title="嵌套单元测试，实现清晰的结构"></a>嵌套单元测试，实现清晰的结构</h4><p>在继续介绍下节内容之前，我想介绍在 JUnit 5 中编写单元测试的最后一个特性。</p>
<p>JUnit Jupiter API 允许您创建嵌套的类，以保持测试代码更清晰，这有助于让测试结果更易读。通过在主类中创建嵌套的测试类，可以创建更多的名称空间，这提供了两个主要优势：</p>
<ul>
<li>每个单元测试可以拥有自己的测试前和测试后生命周期。这让您能使用特殊条件创建要测试的类，从而测试极端情况。</li>
<li>单元测试方法的名称变得更简单。在 JUnit 4 中，所有测试方法都以对等形式存在，不允许重复的方法名（所以您最终会得到类似 <code>testMethodButOnlyUnderThisOrThatCondition_2()</code> 的方法名）。从 JUnit Jupiter 开始，只有嵌套类中的方法必须具有唯一的名称。清单 6 展示了这一优势。</li>
</ul>
<h5 id="清单-5-传递一个空或-null-数组引用"><a href="#清单-5-传递一个空或-null-数组引用" class="headerlink" title="清单 5. 传递一个空或 null 数组引用"></a>清单 5. 传递一个空或 null 数组引用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing JUnit 5&quot;)``public class JUnit5AppTest &#123;``.``.        `` ``@Nested`` ``@DisplayName(&quot;When zero operands&quot;)`` ``class JUnit5AppZeroOperandsTest &#123;`` ` ` ``// @Test methods go here...`` ` ` ``&#125;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>请注意第 6 行，其中的 <code>JUnit5AppZeroOperandsTest</code> 类可以拥有测试方法。任何测试的结果都会在父类 <code>JUnit5AppTest</code> 中以嵌套的形式显示。</p>
<h4 id="使用-JUnit-Platform-运行测试-1"><a href="#使用-JUnit-Platform-运行测试-1" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h4><p>能编写单元测试很不错，但如果不能运行它们，就没有什么意义了。本节展示如何在 Eclipse 中运行 JUnit 测试，首先使用 Maven，然后从命令行使用 Gradle。</p>
<p>下面的视频展示了如何从 GitHub 克隆示例应用程序代码，并在 Eclipse 中运行测试。在该视频中，我还展示了如何从命令行以及 Eclipse 内使用 Maven 和 Gradle 运行单元测试。Eclipse 对 Maven 和 Gradle 都提供了很好的支持。</p>
<p><strong>应用 3 种工具运行单元测试</strong></p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/intro-to-java-junit.png" alt="应用 3种工具运行单元测试"></p>
<p>下面将提供一些简要的说明，但该视频提供了更多细节。观看该视频，了解如何：</p>
<ul>
<li>从 GitHub 克隆 HelloJUnit5 示例应用程序。</li>
<li>将应用程序导入 Eclipse 中。</li>
<li>从 Eclipse 内的 HelloJUnit5 应用程序运行一个 JUnit 测试。</li>
<li>使用 Maven 从命令行运行 HelloJUnit5 单元测试。</li>
<li>使用 Gradle 从命令行运行 HelloJUnit5 单元测试。</li>
</ul>
<h5 id="克隆-HelloJUnit5-示例应用程序"><a href="#克隆-HelloJUnit5-示例应用程序" class="headerlink" title="克隆 HelloJUnit5 示例应用程序"></a>克隆 HelloJUnit5 示例应用程序</h5><p>要理解教程的剩余部分，您需要从 GitHub 克隆示例应用程序。为此，可打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您希望放入代码的目录，然后输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/makotogo/HelloJUnit5</span><br></pre></td></tr></table></figure>

<p>现在您的机器上已拥有该代码，可以在 Eclipse IDE 内运行 JUnit 测试了。接下来介绍如何运行测试。</p>
<h5 id="在-Eclipse-IDE-中运行单元测试"><a href="#在-Eclipse-IDE-中运行单元测试" class="headerlink" title="在 Eclipse IDE 中运行单元测试"></a>在 Eclipse IDE 中运行单元测试</h5><p>如果您已跟随该视频进行操作，应该已将代码导入 Eclipse 中。现在，在 Eclipse 中打开 <strong>Project Explorer</strong> 视图，展开 HelloJUnit5 项目，直至看到 <code>src/test/java</code> 路径下的 <code>JUnit5AppTest</code> 类。</p>
<p>打开 <code>JUnit5AppTest.java</code> 并验证 <code>class</code> 定义前的下面这个注解（以下代码的第 3 行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.``.``@RunWith(JUnitPlatform.class)``public class JUnit5AppTest &#123;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>现在右键单击 <code>JUnit5AppTest</code> 并选择 <strong>Run As &gt; JUnit Test</strong>。单元测试运行时，JUnit 视图将会出现。您现在已准备好完成本教程的练习。</p>
<h5 id="使用-Maven-运行单元测试"><a href="#使用-Maven-运行单元测试" class="headerlink" title="使用 Maven 运行单元测试"></a>使用 Maven 运行单元测试</h5><p>打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您将 HelloJUnit5 应用程序克隆到的目录，然后输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>

<p>这会启动 Maven 构建并运行单元测试。您的输出应类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean test``[INFO] Scanning for projects...``[INFO]                                     ``[INFO] ------------------------------------------------------------------------``[INFO] Building HelloJUnit5 1.0.2``[INFO] ------------------------------------------------------------------------``[INFO] ``[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ HelloJUnit5 ---``[INFO] Deleting /Users/sperry/home/development/projects/learn/HelloJUnit5/target``[INFO] ``[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/main/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:compile (default-compile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/classes``[INFO] ``[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/test/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:testCompile (default-testCompile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/test-classes``[INFO] ``[INFO] --- maven-surefire-plugin:2.19:test (default-test) @ HelloJUnit5 ---` `-------------------------------------------------------`` ``T E S T S``-------------------------------------------------------``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Running com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Tests run: 1, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 0.038 sec - in com.makotojava.learn.hellojunit5.solution.JUnit5AppTest` `Results :` `Tests run: 1, Failures: 0, Errors: 0, Skipped: 1` `[INFO] ------------------------------------------------------------------------``[INFO] BUILD SUCCESS``[INFO] ------------------------------------------------------------------------``[INFO] Total time: 3.741 s``[INFO] Finished at: 2017-11-28T18:04:50-06:00``[INFO] Final Memory: 21M/255M``[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h5 id="Running-unit-tests-with-Gradle"><a href="#Running-unit-tests-with-Gradle" class="headerlink" title="Running unit tests with Gradle"></a>Running unit tests with Gradle</h5><p>Open a terminal window (Mac) or command prompt (Windows), navigate to the directory where you cloned the HelloJUnit5 application, and enter this command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle clean test</span><br></pre></td></tr></table></figure>

<p>The output should look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gradle clean test``Starting a Gradle Daemon (subsequent builds will be faster)``:clean``:compileJava``:processResources NO-SOURCE``:classes``:compileTestJava``:processTestResources NO-SOURCE``:testClasses``:junitPlatformTest``ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.` `Test run finished after 10097 ms``[     7 containers found   ]``[     5 containers skipped  ]``[     2 containers started  ]``[     0 containers aborted  ]``[     2 containers successful ]``[     0 containers failed   ]``[    10 tests found      ]``[    10 tests skipped     ]``[     0 tests started     ]``[     0 tests aborted     ]``[     0 tests successful   ]``[     0 tests failed     ]` `:test SKIPPED` `BUILD SUCCESSFUL` `Total time: 21.014 secs</span><br></pre></td></tr></table></figure>

<h4 id="测试练习"><a href="#测试练习" class="headerlink" title="测试练习"></a>测试练习</h4><p>现在您已了解 JUnit Jupiter，查看了代码示例，并观看了视频（希望您已跟随视频进行操作）。非常棒，但没有什么比动手编写代码更有用了！在第 1 部分的最后一节，您将完成以下任务：</p>
<ul>
<li>编写 JUnit Jupiter API 单元测试。</li>
<li>运行单元测试。</li>
<li>实现 <code>App</code> 类，让您的单元测试通过检查。</li>
</ul>
<p>采用真正的测试驱动开发 (TDD) 方式，首先编写单元测试，运行它们，并会观察到它们全部失败了。然后编写实现，直到单元测试通过，这时您就大功告成了。</p>
<p>注意，<code>JUnit5AppTest</code> 类仅提供了两个现成的测试方法。首次运行该类时，二者都是 “绿色” 的。要完成这些练习，您需要添加剩余的代码，包括用于告诉 JUnit 运行哪些测试方法的注解。记住，如果没有正确配备一个类或方法，JUnit 将跳过它。</p>
<p>如果遇到困难，请查阅 <code>com.makotojava.learn.hellojunit5.solution</code> 包来寻找解决方案。</p>
<p>1</p>
<h5 id="编写-JUnit-Jupiter-单元测试"><a href="#编写-JUnit-Jupiter-单元测试" class="headerlink" title="编写 JUnit Jupiter 单元测试"></a>编写 JUnit Jupiter 单元测试</h5><p>首先从 <code>JUnit5AppTest.java</code> 开始。打开此文件并按照 Javadoc 注解中的指示操作。</p>
<p><strong>提示</strong>：使用 Eclipse 中的 Javadoc 视图读取测试指令。要打开 Javadoc 视图，可以转到 <strong>Window &gt; Show View &gt; Javadoc</strong>。您应该看到 Javadoc 视图。根据您设置工作区的方式，该窗口可能出现在任意多个位置。在我的工作区中，该窗口与图 3 中的屏幕截图类似，出现在 IDE 右侧的编辑器窗口下方：</p>
<h5 id="图-3-Javadoc-视图"><a href="#图-3-Javadoc-视图" class="headerlink" title="图 3. Javadoc 视图"></a>图 3. Javadoc 视图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-3.png" alt="Javadoc 视图的屏幕截图。"></p>
<p>编辑器窗口中显示了具有原始 HTML 标记的 Javadoc 注解，但在 Javadoc 窗口中，已将其格式化，因此更易于阅读。</p>
<h5 id="在-Eclipse-中运行单元测试"><a href="#在-Eclipse-中运行单元测试" class="headerlink" title="在 Eclipse 中运行单元测试"></a>在 Eclipse 中运行单元测试</h5><p>如果您像我一样，您会使用 IDE 执行以下工作：</p>
<ul>
<li>编写单元测试。</li>
<li>编写单元测试所测试的实现内容。</li>
<li>运行初始测试（使用 IDE 的原生 JUnit 支持）。</li>
</ul>
<p>JUnit 5 提供了一个名为 <code>JUnitPlatform</code> 的类，它允许您在 Eclipse 中运行 JUnit 5 测试。</p>
<p><strong>Eclipse 中的 JUnit 5</strong>：Eclipse 目前能理解 JUnit 4，但尚未提供对 JUnit 5 的原生支持。幸运的是，这对大部分单元测试而言都不是什么大问题！除非您需要使用 JUnit 4 一些更复杂的特性，否则要编写单元测试来全面检查您的应用程序代码，<code>JUnitPlatform</code> 类就足够了。</p>
<p>要在 Eclipse 中运行测试，需要确保您的计算机上拥有示例应用程序。为此，最轻松的方法是从 GitHub 克隆 HelloJUnit5 应用程序，然后将它导入 Eclipse 中。（因为本教程的视频展示了如何这么做，所以这里将跳过细节，仅提供操作步骤。）</p>
<p>确保您克隆了 GitHub 存储库，然后将代码导入 Eclipse 中作为新的 Maven 项目。</p>
<p>将该项目导入 Eclipse 中后，打开 <strong>Project Explorer</strong> 视图并展开 <code>src/main/test</code> 节点，直至看到 <code>JUnit5AppTest</code>。要以 JUnit 测试的形式运行它，可以右键单击它，选择 <strong>Run As &gt; JUnit Test</strong>。</p>
<h5 id="实现-App-类，直到单元测试通过检查"><a href="#实现-App-类，直到单元测试通过检查" class="headerlink" title="实现 App 类，直到单元测试通过检查"></a>实现 App 类，直到单元测试通过检查</h5><p><code>App</code> 的单一 <code>add()</code> 方法提供的功能很容易理解，而且在设计上非常简单。我不希望复杂应用程序的业务逻辑阻碍您对 JUnit Jupiter 的学习。</p>
<p>单元测试通过后，您就大功告成了！记住，如果遇到困难，可以在 <code>com.makotojava.learn.hellojunit5.solution</code> 包中查找解决方案。</p>
<h4 id="第-1-部分小结"><a href="#第-1-部分小结" class="headerlink" title="第 1 部分小结"></a>第 1 部分小结</h4><p>在 JUnit 5 教程的前半部分中，我介绍了 JUnit 5 的架构和组件，并详细介绍了 JUnit Jupiter API。我们逐个介绍了 JUnit 5 中最常用的注解、断言和前置条件，而且通过一个快速练习演示了如何在 Eclipse、Maven 和 Gradle 中运行测试。</p>
<p>在<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part2-vintage-jupiter-extension-model/index.html">第 2 部分</a>中，您将了解 JUnit 5 的一些高级特性：</p>
<ul>
<li>JUnit Jupiter 扩展模型</li>
<li>方法参数注入</li>
<li>参数化测试</li>
</ul>
<p>那么您接下来会怎么做？</p>
<h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">injune</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://youngyjmaze.github.io/2020/05/26/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">http://youngyjmaze.github.io/2020/05/26/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://youngyjmaze.github.io">injune'zone</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/05/26/CGLIB/"><i class="fas fa-angle-left">&nbsp;</i><span>CGLIB</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/05/26/JAVA%20%E6%B3%9B%E5%9E%8B/"><span>JAVA泛型</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2021 By injune</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/haru02.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":50,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>