<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords"><meta name="author" content="youngyj,undefined"><meta name="copyright" content="youngyj"><title>【Hexo】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">youngyj</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/YoungYJMaze" target="_blank">GitHub<i class="icon-dot bg-color6"></i></a><a class="links-button button-hover" href="mailto:q2235133943@gmail.com" target="_blank">E-Mail<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">22</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Hexo</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2021/10/18/JAVA%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 <code>::</code>，然后跟方法名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/MethodReferences.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callable</span> </span>&#123; <span class="comment">// [1]</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Describe</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123; <span class="comment">// [2]</span></span><br><span class="line">    System.out.println(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferences</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123; <span class="comment">// [3]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Description</span> </span>&#123;</span><br><span class="line">    String about;</span><br><span class="line">    Description(String desc) &#123; about = desc; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(String msg)</span> </span>&#123; <span class="comment">// [4]</span></span><br><span class="line">      System.out.println(about + <span class="string">&quot; &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assist</span><span class="params">(String msg)</span> </span>&#123; <span class="comment">// [5]</span></span><br><span class="line">      System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Describe d = <span class="keyword">new</span> Describe();</span><br><span class="line">    Callable c = d::show; <span class="comment">// [6]</span></span><br><span class="line">    c.call(<span class="string">&quot;call()&quot;</span>); <span class="comment">// [7]</span></span><br><span class="line"></span><br><span class="line">    c = MethodReferences::hello; <span class="comment">// [8]</span></span><br><span class="line">    c.call(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    c = <span class="keyword">new</span> Description(<span class="string">&quot;valuable&quot;</span>)::help; <span class="comment">// [9]</span></span><br><span class="line">    c.call(<span class="string">&quot;information&quot;</span>);</span><br><span class="line"></span><br><span class="line">    c = Helper::assist; <span class="comment">// [10]</span></span><br><span class="line">    c.call(<span class="string">&quot;Help!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call()</span><br><span class="line">Hello, Bob</span><br><span class="line">valuable information</span><br><span class="line">Help!</span><br></pre></td></tr></table></figure>

<p><strong>[1]</strong> 我们从单一方法接口开始（同样，你很快就会了解到这一点的重要性）。</p>
<p><strong>[2]</strong> <code>show()</code> 的签名（参数类型和返回类型）符合 <strong>Callable</strong> 的 <code>call()</code> 的签名。</p>
<p><strong>[3]</strong> <code>hello()</code> 也符合 <code>call()</code> 的签名。</p>
<p><strong>[4]</strong> <code>help()</code> 也符合，它是静态内部类中的非静态方法。</p>
<p><strong>[5]</strong> <code>assist()</code> 是静态内部类中的静态方法。</p>
<p><strong>[6]</strong> 我们将 <strong>Describe</strong> 对象的方法引用赋值给 <strong>Callable</strong> ，它没有 <code>show()</code> 方法，而是 <code>call()</code> 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 <strong>Callable</strong> 的 <code>call()</code> 方法的签名。</p>
<p><strong>[7]</strong> 我们现在可以通过调用 <code>call()</code> 来调用 <code>show()</code>，因为 Java 将 <code>call()</code> 映射到 <code>show()</code>。</p>
<p><strong>[8]</strong> 这是一个<strong>静态</strong>方法引用。</p>
<p><strong>[9]</strong> 这是 <strong>[6]</strong> 的另一个版本：对已实例化对象的方法的引用，有时称为<em>绑定方法引用</em>。</p>
<p><strong>[10]</strong> 最后，获取静态内部类中静态方法的引用与 <strong>[8]</strong> 中通过外部类引用相似。</p>
<p>上例只是简短的介绍，我们很快就能看到方法引用的所有不同形式。</p>
<h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><p><strong>Runnable</strong> 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 <code>run()</code> 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 <strong>Runnable</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/RunnableMethodReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法引用与 Runnable 接口的结合使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Go</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Go::go()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableMethodReference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Anonymous&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(</span><br><span class="line">      () -&gt; System.out.println(<span class="string">&quot;lambda&quot;</span>)</span><br><span class="line">    ).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(Go::go).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Anonymous</span><br><span class="line">lambda</span><br><span class="line">Go::go()</span><br></pre></td></tr></table></figure>

<p><strong>Thread</strong> 对象将 <strong>Runnable</strong> 作为其构造函数参数，并具有会调用 <code>run()</code> 的方法 <code>start()</code>。 <strong>注意</strong>，只有<strong>匿名内部类</strong>才需要具有名为 <code>run()</code> 的方法。</p>
<h2 id="未绑定的方法引用"><a href="#未绑定的方法引用" class="headerlink" title="未绑定的方法引用"></a>未绑定的方法引用</h2><p>未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用时，我们必须先提供对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/UnboundMethodReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有方法引用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;X::f()&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MakeString</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TransformX</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">transform</span><span class="params">(X x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundMethodReference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MakeString ms = X::f; // [1]</span></span><br><span class="line">    TransformX sp = X::f;</span><br><span class="line">    X x = <span class="keyword">new</span> X();</span><br><span class="line">    System.out.println(sp.transform(x)); <span class="comment">// [2]</span></span><br><span class="line">    System.out.println(x.f()); <span class="comment">// 同等效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X::f()</span><br><span class="line">X::f()</span><br></pre></td></tr></table></figure>

<p>截止目前，我们看到了与对应接口签名相同的方法引用。 在 **[1]**，我们尝试把 <code>X</code> 的 <code>f()</code> 方法引用赋值给 <strong>MakeString</strong>。结果即使 <code>make()</code> 与 <code>f()</code> 具有相同的签名，编译也会报“invalid method reference”（无效方法引用）错误。 这是因为实际上还有另一个隐藏的参数：我们的老朋友 <code>this</code>。 你不能在没有 <code>X</code> 对象的前提下调用 <code>f()</code>。 因此，<code>X :: f</code> 表示未绑定的方法引用，因为它尚未“绑定”到对象。</p>
<p>要解决这个问题，我们需要一个 <code>X</code> 对象，所以我们的接口实际上需要一个额外的参数，如上例中的 <strong>TransformX</strong>。 如果将 <code>X :: f</code> 赋值给 <strong>TransformX</strong>，在 Java 中是允许的。我们必须做第二个心理调整——使用未绑定的引用时，函数式方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。 原因是：你需要一个对象来调用方法。</p>
<p><strong>[2]</strong> 的结果有点像脑筋急转弯。我拿到未绑定的方法引用，并且调用它的<code>transform()</code>方法，将一个X类的对象传递给它，最后使得 <code>x.f()</code> 以某种方式被调用。Java知道它必须拿到第一个参数，该参数实际就是<code>this</code>，然后调用方法作用在它之上。</p>
<p>如果你的方法有更多个参数，就以第一个参数接受<code>this</code>的模式来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/MultiUnbound.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未绑定的方法与多参数的结合运用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">This</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">three</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, String s)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">four</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, String s, <span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call2</span><span class="params">(This athis, <span class="keyword">int</span> i, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ThreeArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call3</span><span class="params">(This athis, <span class="keyword">int</span> i, <span class="keyword">double</span> d, String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FourArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call4</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    This athis, <span class="keyword">int</span> i, <span class="keyword">double</span> d, String s, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiUnbound</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TwoArgs twoargs = This::two;</span><br><span class="line">    ThreeArgs threeargs = This::three;</span><br><span class="line">    FourArgs fourargs = This::four;</span><br><span class="line">    This athis = <span class="keyword">new</span> This();</span><br><span class="line">    twoargs.call2(athis, <span class="number">11</span>, <span class="number">3.14</span>);</span><br><span class="line">    threeargs.call3(athis, <span class="number">11</span>, <span class="number">3.14</span>, <span class="string">&quot;Three&quot;</span>);</span><br><span class="line">    fourargs.call4(athis, <span class="number">11</span>, <span class="number">3.14</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要指出的是，我将类命名为 <strong>This</strong>，并将函数式方法的第一个参数命名为 <strong>athis</strong>，但你在生产级代码中应该使用其他名字，以防止混淆。</p>
<h2 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h2><p>你还可以捕获构造函数的引用，然后通过引用调用该构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/CtorReference.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age = -<span class="number">1</span>; <span class="comment">// For &quot;unknown&quot;</span></span><br><span class="line">  Dog() &#123; name = <span class="string">&quot;stray&quot;</span>; &#125;</span><br><span class="line">  Dog(String nm) &#123; name = nm; &#125;</span><br><span class="line">  Dog(String nm, <span class="keyword">int</span> yrs) &#123; name = nm; age = yrs; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MakeNoArgs</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Make1Arg</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">(String nm)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Make2Args</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">(String nm, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CtorReference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MakeNoArgs mna = Dog::<span class="keyword">new</span>; <span class="comment">// [1]</span></span><br><span class="line">    Make1Arg m1a = Dog::<span class="keyword">new</span>;   <span class="comment">// [2]</span></span><br><span class="line">    Make2Args m2a = Dog::<span class="keyword">new</span>;  <span class="comment">// [3]</span></span><br><span class="line"></span><br><span class="line">    Dog dn = mna.make();</span><br><span class="line">    Dog d1 = m1a.make(<span class="string">&quot;Comet&quot;</span>);</span><br><span class="line">    Dog d2 = m2a.make(<span class="string">&quot;Ralph&quot;</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Dog</strong> 有三个构造函数，函数式接口内的 <code>make()</code> 方法反映了构造函数参数列表（ <code>make()</code> 方法名称可以不同）。</p>
<p><strong>注意</strong>我们如何对 <strong>[1]<strong>，</strong>[2]</strong> 和 <strong>[3]</strong> 中的每一个使用 <code>Dog :: new</code>。 这三个构造函数只有一个相同名称：<code>:: new</code>，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。</p>
<p>编译器知道调用函数式方法（本例中为 <code>make()</code>）就相当于调用构造函数。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>方法引用和 Lambda 表达式都必须被赋值，同时赋值需要类型信息才能使编译器保证类型的正确性。尤其是Lambda 表达式，它引入了新的要求。 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; x.toString()</span><br></pre></td></tr></table></figure>

<p>我们清楚这里返回类型必须是 <strong>String</strong>，但 <code>x</code> 是什么类型呢？</p>
<p>Lambda 表达式包含类型推导（编译器会自动推导出类型信息，避免了程序员显式地声明）。编译器必须能够以某种方式推导出 <code>x</code> 的类型。</p>
<p>下面是第二个代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure>

<p>现在 <code>x</code> 和 <code>y</code> 可以是任何支持 <code>+</code> 运算符连接的数据类型，可以是两个不同的数值类型或者是 一个 <strong>String</strong> 加任意一种可自动转换为 <strong>String</strong> 的数据类型（这包括了大多数类型）。 但是，当 Lambda 表达式被赋值时，编译器必须确定 <code>x</code> 和 <code>y</code> 的确切类型以生成正确的代码。</p>
<p>该问题也适用于方法引用。 假设你要传递 <code>System.out :: println</code> 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？</p>
<p>为了解决这个问题，Java 8 引入了 <code>java.util.function</code> 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。</p>
<p>在编写接口时，可以使用 <code>@FunctionalInterface</code> 注解强制执行此“函数式方法”模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/FunctionalAnnotation.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">goodbye</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FunctionalNoAnn</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">goodbye</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@FunctionalInterface</span></span><br><span class="line"><span class="comment">interface NotFunctional &#123;</span></span><br><span class="line"><span class="comment">  String goodbye(String arg);</span></span><br><span class="line"><span class="comment">  String hello(String arg);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">产生错误信息:</span></span><br><span class="line"><span class="comment">NotFunctional is not a functional interface</span></span><br><span class="line"><span class="comment">multiple non-overriding abstract methods</span></span><br><span class="line"><span class="comment">found in interface NotFunctional</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalAnnotation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">goodbye</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Goodbye, &quot;</span> + arg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FunctionalAnnotation fa =</span><br><span class="line">      <span class="keyword">new</span> FunctionalAnnotation();</span><br><span class="line">    Functional f = fa::goodbye;</span><br><span class="line">    FunctionalNoAnn fna = fa::goodbye;</span><br><span class="line">    <span class="comment">// Functional fac = fa; // Incompatible</span></span><br><span class="line">    Functional fl = a -&gt; <span class="string">&quot;Goodbye, &quot;</span> + a;</span><br><span class="line">    FunctionalNoAnn fnal = a -&gt; <span class="string">&quot;Goodbye, &quot;</span> + a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@FunctionalInterface</code> 注解是可选的;</p>
<p> Java 在 <code>main()</code> 中把 <strong>Functional</strong> 和 <strong>FunctionalNoAnn</strong> 都当作函数式接口。 在 <code>NotFunctional</code> 的定义中可看到<code>@FunctionalInterface</code> 的作用：接口中如果有多个方法则会产生编译期错误。</p>
<p>仔细观察在定义 <code>f</code> 和 <code>fna</code> 时发生了什么。 <code>Functional</code> 和 <code>FunctionalNoAnn</code> 定义接口，然而被赋值的只是方法 <code>goodbye()</code>。首先，这只是一个方法而不是类；其次，它甚至都不是实现了该接口的类中的方法。这是添加到Java 8中的一点小魔法：如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会在后台把方法引用或 Lambda 表达式包装进实现目标接口的类的实例中。</p>
<p>尽管 <code>FunctionalAnnotation</code> 确实适合 <code>Functional</code> 模型，但 Java不允许我们像<code>fac</code>定义中的那样，将 <code>FunctionalAnnotation</code> 直接赋值给 <code>Functional</code>，因为 <code>FunctionalAnnotation</code> 并没有显式地去实现 <code>Functional</code> 接口。唯一的惊喜是，Java 8 允许我们将函数赋值给接口，这样的语法更加简单漂亮。</p>
<p><code>java.util.function</code> 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。主要因为基本类型的存在，导致预定义的接口数量有少许增加。 如果你了解命名模式，顾名思义就能知道特定接口的作用。</p>
<p>以下是基本命名准则：</p>
<ol>
<li>如果只处理对象而非基本类型，名称则为 <code>Function</code>，<code>Consumer</code>，<code>Predicate</code> 等。参数类型通过泛型添加。</li>
<li>如果接收的参数是基本类型，则由名称的第一部分表示，如 <code>LongConsumer</code>，<code>DoubleFunction</code>，<code>IntPredicate</code> 等，但返回基本类型的 <code>Supplier</code> 接口例外。</li>
<li>如果返回值为基本类型，则用 <code>To</code> 表示，如 <code>ToLongFunction &lt;T&gt;</code> 和 <code>IntToLongFunction</code>。</li>
<li>如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 <code>UnaryOperator</code>，两个参数使用 <code>BinaryOperator</code>。</li>
<li>如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。</li>
<li>如果接收的两个参数类型不同，则名称中有一个 <code>Bi</code>。</li>
</ol>
<p>下表描述了 <code>java.util.function</code> 中的目标类型（包括例外情况）：</p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>函数式方法名</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>无参数； 无返回值</td>
<td><strong>Runnable</strong> (java.lang) <code>run()</code></td>
<td><strong>Runnable</strong></td>
</tr>
<tr>
<td>无参数； 返回类型任意</td>
<td><strong>Supplier</strong> <code>get()</code> <code>getAs类型()</code></td>
<td><strong>Supplier<code>&lt;T&gt;</code> BooleanSupplier IntSupplier LongSupplier DoubleSupplier</strong></td>
</tr>
<tr>
<td>无参数； 返回类型任意</td>
<td><strong>Callable</strong> (java.util.concurrent) <code>call()</code></td>
<td><strong>Callable<code>&lt;V&gt;</code></strong></td>
</tr>
<tr>
<td>1 参数； 无返回值</td>
<td><strong>Consumer</strong> <code>accept()</code></td>
<td><strong><code>Consumer&lt;T&gt;</code> IntConsumer LongConsumer DoubleConsumer</strong></td>
</tr>
<tr>
<td>2 参数 <strong>Consumer</strong></td>
<td><strong>BiConsumer</strong> <code>accept()</code></td>
<td><strong><code>BiConsumer&lt;T,U&gt;</code></strong></td>
</tr>
<tr>
<td>2 参数 <strong>Consumer</strong>； 1 引用； 1 基本类型</td>
<td><strong>Obj类型Consumer</strong> <code>accept()</code></td>
<td><strong><code>ObjIntConsumer&lt;T&gt;</code> <code>ObjLongConsumer&lt;T&gt;</code> <code>ObjDoubleConsumer&lt;T&gt;</code></strong></td>
</tr>
<tr>
<td>1 参数； 返回类型不同</td>
<td><strong>Function</strong> <code>apply()</code> <strong>To类型</strong> 和 <strong>类型To类型</strong> <code>applyAs类型()</code></td>
<td><strong>Function<code>&lt;T,R&gt;</code> IntFunction<code>&lt;R&gt;</code> <code>LongFunction&lt;R&gt;</code> DoubleFunction<code>&lt;R&gt;</code> ToIntFunction<code>&lt;T&gt;</code> <code>ToLongFunction&lt;T&gt;</code> <code>ToDoubleFunction&lt;T&gt;</code> IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction</strong></td>
</tr>
<tr>
<td>1 参数； 返回类型相同</td>
<td><strong>UnaryOperator</strong> <code>apply()</code></td>
<td><strong><code>UnaryOperator&lt;T&gt;</code> IntUnaryOperator LongUnaryOperator DoubleUnaryOperator</strong></td>
</tr>
<tr>
<td>2 参数类型相同； 返回类型相同</td>
<td><strong>BinaryOperator</strong> <code>apply()</code></td>
<td><strong><code>BinaryOperator&lt;T&gt;</code> IntBinaryOperator LongBinaryOperator DoubleBinaryOperator</strong></td>
</tr>
<tr>
<td>2 参数类型相同; 返回整型</td>
<td>Comparator (java.util) <code>compare()</code></td>
<td><strong><code>Comparator&lt;T&gt;</code></strong></td>
</tr>
<tr>
<td>2 参数； 返回布尔型</td>
<td><strong>Predicate</strong> <code>test()</code></td>
<td><strong><code>Predicate&lt;T&gt;</code> <code>BiPredicate&lt;T,U&gt;</code> IntPredicate LongPredicate DoublePredicate</strong></td>
</tr>
<tr>
<td>参数基本类型； 返回基本类型</td>
<td><strong>类型To类型Function</strong> <code>applyAs类型()</code></td>
<td><strong>IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction</strong></td>
</tr>
<tr>
<td>2 参数类型不同</td>
<td><strong>Bi操作</strong> (不同方法名)</td>
<td><strong><code>BiFunction&lt;T,U,R&gt;</code> <code>BiConsumer&lt;T,U&gt;</code> <code>BiPredicate&lt;T,U&gt;</code> <code>ToIntBiFunction&lt;T,U&gt;</code> <code>ToLongBiFunction&lt;T,U&gt;</code> <code>ToDoubleBiFunction&lt;T&gt;</code></strong></td>
</tr>
</tbody></table>
<p>此表仅提供些常规方案。通过上表，你应该或多或少能自行推导出你所需要的函数式接口。</p>
<p>可以看出，在创建 <code>java.util.function</code> 时，设计者们做出了一些选择。</p>
<p>例如，为什么没有 <code>IntComparator</code>，<code>LongComparator</code> 和 <code>DoubleComparator</code> 呢？有 <code>BooleanSupplier</code> 却没有其他表示 <strong>Boolean</strong> 的接口；有通用的 <code>BiConsumer</code> 却没有用于 <strong>int</strong>，<strong>long</strong> 和 <strong>double</strong> 的 <code>BiConsumers</code> 变体（我理解他们为什么放弃这些接口）。这到底是疏忽还是有人认为其他组合使用得很少呢（他们是如何得出这个结论的）？</p>
<p>你还可以看到基本类型给 Java 添加了多少复杂性。基于效率方面的考虑（问题之后有所缓解），该语言的第一版中就包含了基本类型。现在，在语言的生命周期中，我们仍然会受到语言设计选择不佳的影响。</p>
<p>下面枚举了基于 Lambda 表达式的所有不同 <strong>Function</strong> 变体的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/FunctionVariants.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  Foo f;</span><br><span class="line">  Bar(Foo f) &#123; <span class="keyword">this</span>.f = f; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaz</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  IBaz(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.i = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LBaz</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> l;</span><br><span class="line">  LBaz(<span class="keyword">long</span> l) &#123;</span><br><span class="line">    <span class="keyword">this</span>.l = l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBaz</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  DBaz(<span class="keyword">double</span> d) &#123;</span><br><span class="line">    <span class="keyword">this</span>.d = d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionVariants</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Function&lt;Foo,Bar&gt; f1 = f -&gt; <span class="keyword">new</span> Bar(f);</span><br><span class="line">  <span class="keyword">static</span> IntFunction&lt;IBaz&gt; f2 = i -&gt; <span class="keyword">new</span> IBaz(i);</span><br><span class="line">  <span class="keyword">static</span> LongFunction&lt;LBaz&gt; f3 = l -&gt; <span class="keyword">new</span> LBaz(l);</span><br><span class="line">  <span class="keyword">static</span> DoubleFunction&lt;DBaz&gt; f4 = d -&gt; <span class="keyword">new</span> DBaz(d);</span><br><span class="line">  <span class="keyword">static</span> ToIntFunction&lt;IBaz&gt; f5 = ib -&gt; ib.i;</span><br><span class="line">  <span class="keyword">static</span> ToLongFunction&lt;LBaz&gt; f6 = lb -&gt; lb.l;</span><br><span class="line">  <span class="keyword">static</span> ToDoubleFunction&lt;DBaz&gt; f7 = db -&gt; db.d;</span><br><span class="line">  <span class="keyword">static</span> IntToLongFunction f8 = i -&gt; i;</span><br><span class="line">  <span class="keyword">static</span> IntToDoubleFunction f9 = i -&gt; i;</span><br><span class="line">  <span class="keyword">static</span> LongToIntFunction f10 = l -&gt; (<span class="keyword">int</span>)l;</span><br><span class="line">  <span class="keyword">static</span> LongToDoubleFunction f11 = l -&gt; l;</span><br><span class="line">  <span class="keyword">static</span> DoubleToIntFunction f12 = d -&gt; (<span class="keyword">int</span>)d;</span><br><span class="line">  <span class="keyword">static</span> DoubleToLongFunction f13 = d -&gt; (<span class="keyword">long</span>)d;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bar b = f1.apply(<span class="keyword">new</span> Foo());</span><br><span class="line">    IBaz ib = f2.apply(<span class="number">11</span>);</span><br><span class="line">    LBaz lb = f3.apply(<span class="number">11</span>);</span><br><span class="line">    DBaz db = f4.apply(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">int</span> i = f5.applyAsInt(ib);</span><br><span class="line">    <span class="keyword">long</span> l = f6.applyAsLong(lb);</span><br><span class="line">    <span class="keyword">double</span> d = f7.applyAsDouble(db);</span><br><span class="line">    l = f8.applyAsLong(<span class="number">12</span>);</span><br><span class="line">    d = f9.applyAsDouble(<span class="number">12</span>);</span><br><span class="line">    i = f10.applyAsInt(<span class="number">12</span>);</span><br><span class="line">    d = f11.applyAsDouble(<span class="number">12</span>);</span><br><span class="line">    i = f12.applyAsInt(<span class="number">13.0</span>);</span><br><span class="line">    l = f13.applyAsLong(<span class="number">13.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些 Lambda 表达式尝试生成适合函数签名的最简代码。 在某些情况下，有必要进行强制类型转换，否则编译器会报截断错误。</p>
<p>主方法中的每个测试都显示了 <code>Function</code> 接口中不同类型的 <code>apply()</code> 方法。 每个都产生一个与其关联的 Lambda 表达式的调用。</p>
<p>方法引用有自己的小魔法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/ functional/MethodConversion.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">In1</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">In2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodConversion</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(In1 i1, In2 i2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">someOtherName</span><span class="params">(In1 i1, In2 i2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;someOtherName()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BiConsumer&lt;In1,In2&gt; bic;</span><br><span class="line"></span><br><span class="line">    bic = MethodConversion::accept;</span><br><span class="line">    bic.accept(<span class="keyword">new</span> In1(), <span class="keyword">new</span> In2());</span><br><span class="line"></span><br><span class="line">    bic = MethodConversion::someOtherName;</span><br><span class="line">    <span class="comment">// bic.someOtherName(new In1(), new In2()); // Nope</span></span><br><span class="line">    bic.accept(<span class="keyword">new</span> In1(), <span class="keyword">new</span> In2());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accept()</span><br><span class="line">someOtherName()</span><br></pre></td></tr></table></figure>

<p>查看 <code>BiConsumer</code> 的文档，你会看到 <code>accept()</code> 方法。 实际上，如果我们将方法命名为 <code>accept()</code>，它就可以作为方法引用。 但是我们也可用不同的名称，比如 <code>someOtherName()</code>。只要参数类型、返回类型与 <code>BiConsumer</code> 的 <code>accept()</code> 相同即可。</p>
<p>因此，在使用函数接口时，名称无关紧要——只要参数类型和返回类型相同。 Java 会将你的方法映射到接口方法。 要调用方法，可以调用接口的函数式方法名（在本例中为 <code>accept()</code>），而不是你的方法名。</p>
<p>现在我们来看看，将方法引用应用于基于类的函数式接口（即那些不包含基本类型的函数式接口）。下面的例子中，我创建了适合函数式方法签名的最简单的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/ClassFunctionals.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFunctionals</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> AA <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AA(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">(AA aa1, AA aa2)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">(AA aa)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">(AA aa, BB bb)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> CC <span class="title">f5</span><span class="params">(AA aa)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> CC(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> CC <span class="title">f6</span><span class="params">(AA aa, BB bb)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> CC(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">f7</span><span class="params">(AA aa)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">f8</span><span class="params">(AA aa, BB bb)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> AA <span class="title">f9</span><span class="params">(AA aa)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AA(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> AA <span class="title">f10</span><span class="params">(AA aa1, AA aa2)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AA(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Supplier&lt;AA&gt; s = ClassFunctionals::f1;</span><br><span class="line">    s.get();</span><br><span class="line">    Comparator&lt;AA&gt; c = ClassFunctionals::f2;</span><br><span class="line">    c.compare(<span class="keyword">new</span> AA(), <span class="keyword">new</span> AA());</span><br><span class="line">    Consumer&lt;AA&gt; cons = ClassFunctionals::f3;</span><br><span class="line">    cons.accept(<span class="keyword">new</span> AA());</span><br><span class="line">    BiConsumer&lt;AA,BB&gt; bicons = ClassFunctionals::f4;</span><br><span class="line">    bicons.accept(<span class="keyword">new</span> AA(), <span class="keyword">new</span> BB());</span><br><span class="line">    Function&lt;AA,CC&gt; f = ClassFunctionals::f5;</span><br><span class="line">    CC cc = f.apply(<span class="keyword">new</span> AA());</span><br><span class="line">    BiFunction&lt;AA,BB,CC&gt; bif = ClassFunctionals::f6;</span><br><span class="line">    cc = bif.apply(<span class="keyword">new</span> AA(), <span class="keyword">new</span> BB());</span><br><span class="line">    Predicate&lt;AA&gt; p = ClassFunctionals::f7;</span><br><span class="line">    <span class="keyword">boolean</span> result = p.test(<span class="keyword">new</span> AA());</span><br><span class="line">    BiPredicate&lt;AA,BB&gt; bip = ClassFunctionals::f8;</span><br><span class="line">    result = bip.test(<span class="keyword">new</span> AA(), <span class="keyword">new</span> BB());</span><br><span class="line">    UnaryOperator&lt;AA&gt; uo = ClassFunctionals::f9;</span><br><span class="line">    AA aa = uo.apply(<span class="keyword">new</span> AA());</span><br><span class="line">    BinaryOperator&lt;AA&gt; bo = ClassFunctionals::f10;</span><br><span class="line">    aa = bo.apply(<span class="keyword">new</span> AA(), <span class="keyword">new</span> AA());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请<strong>注意</strong>，每个方法名称都是随意的（如 <code>f1()</code>，<code>f2()</code>等）。正如你刚才看到的，一旦将方法引用赋值给函数接口，我们就可以调用与该接口关联的函数方法。 在此示例中为 <code>get()</code>、<code>compare()</code>、<code>accept()</code>、<code>apply()</code> 和 <code>test()</code>。</p>
<h3 id="多参数函数式接口"><a href="#多参数函数式接口" class="headerlink" title="多参数函数式接口"></a>多参数函数式接口</h3><p><code>java.util.functional</code> 中的接口是有限的。比如有 <code>BiFunction</code>，但也仅此而已。 如果需要三参数函数的接口怎么办？ 其实这些接口非常简单，很容易查看 Java 库源代码并自行创建。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/TriFunction.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">V</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u, V v)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单测试，验证它是否有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/TriFunctionTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriFunctionTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> l, <span class="keyword">double</span> d)</span> </span>&#123; <span class="keyword">return</span> <span class="number">99</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TriFunction&lt;Integer, Long, Double, Integer&gt; tf =</span><br><span class="line">      TriFunctionTest::f;</span><br><span class="line">    tf = (i, l, d) -&gt; <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们同时测试了方法引用和 Lambda 表达式。</p>
<h3 id="缺少基本类型的函数"><a href="#缺少基本类型的函数" class="headerlink" title="缺少基本类型的函数"></a>缺少基本类型的函数</h3><p>让我们重温一下 <code>BiConsumer</code>，看看我们如何创建缺少的针对 <strong>int</strong>，<strong>long</strong> 和 <strong>double</strong> 的各种排列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/BiConsumerPermutations.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiConsumerPermutations</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> BiConsumer&lt;Integer, Double&gt; bicid = (i, d) -&gt;</span><br><span class="line">    System.out.format(<span class="string">&quot;%d, %f%n&quot;</span>, i, d);</span><br><span class="line">  <span class="keyword">static</span> BiConsumer&lt;Double, Integer&gt; bicdi = (d, i) -&gt;</span><br><span class="line">    System.out.format(<span class="string">&quot;%d, %f%n&quot;</span>, i, d);</span><br><span class="line">  <span class="keyword">static</span> BiConsumer&lt;Integer, Long&gt; bicil = (i, l) -&gt;</span><br><span class="line">    System.out.format(<span class="string">&quot;%d, %d%n&quot;</span>, i, l);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    bicid.accept(<span class="number">47</span>, <span class="number">11.34</span>);</span><br><span class="line">    bicdi.accept(<span class="number">22.45</span>, <span class="number">92</span>);</span><br><span class="line">    bicil.accept(<span class="number">1</span>, <span class="number">11L</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">47, 11.340000</span><br><span class="line">92, 22.450000</span><br><span class="line">1, 11</span><br></pre></td></tr></table></figure>

<p>这里使用 <code>System.out.format()</code> 来显示。它类似于 <code>System.out.println()</code> 但提供了更多的显示选项。 这里，<code>%f</code> 表示我将 <code>n</code> 作为浮点值给出，<code>%d</code> 表示 <code>n</code> 是一个整数值。 这其中可以包含空格，输入 <code>%n</code> 会换行 — 当然使用传统的 <code>\n</code> 也能换行，但 <code>%n</code> 是自动跨平台的，这是使用 <code>format()</code> 的另一个原因。</p>
<p>上例简单使用了包装类型，装箱和拆箱负责它与基本类型之间的来回转换。 又比如，我们可以将包装类型和<code>Function</code>一起使用，而不去用各种针对基本类型的预定义接口。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/FunctionWithWrapped.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionWithWrapped</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer, Double&gt; fid = i -&gt; (<span class="keyword">double</span>)i;</span><br><span class="line">    IntToDoubleFunction fid2 = i -&gt; i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有强制转换，则会收到错误消息：“Integer cannot be converted to Double”（<strong>Integer</strong> 无法转换为 <strong>Double</strong>），而使用 <strong>IntToDoubleFunction</strong> 就没有此类问题。 <strong>IntToDoubleFunction</strong> 接口的源代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntToDoubleFunction</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">applyAsDouble</span><span class="params">(<span class="keyword">int</span> value)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们可以简单地写 <code>Function &lt;Integer，Double&gt;</code> 并产生正常的结果，所以用基本类型的唯一原因是可以避免传递参数和返回结果过程中的自动装箱和自动拆箱，进而提升性能。</p>
<p>似乎是考虑到使用频率，某些函数类型并没有预定义。</p>
<p>当然，如果因为缺少针对基本类型的函数式接口造成了性能问题，你可以轻松编写自己的接口（ 参考 Java 源代码）——尽管这里出现性能瓶颈的可能性不大。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>这个名字可能听起来令人生畏，但是：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Higher-order_function">高阶函数</a>（Higher-order Function）只是一个消费或产生函数的函数。</p>
<p>我们先来看看如何产生一个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/ProduceFunction.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span></span><br><span class="line"><span class="class"><span class="title">FuncSS</span> <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;&#125; <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceFunction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> FuncSS <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s -&gt; s.toLowerCase(); <span class="comment">// [2]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FuncSS f = produce();</span><br><span class="line">    System.out.println(f.apply(<span class="string">&quot;YELLING&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yelling</span><br></pre></td></tr></table></figure>

<p>这里，<code>produce()</code> 是高阶函数。</p>
<p><strong>[1]</strong> 使用继承，可以轻松地为专用接口创建别名。</p>
<p><strong>[2]</strong> 使用 Lambda 表达式，可以轻松地在方法中创建和返回一个函数。</p>
<p>要消费一个函数，消费函数需要在参数列表正确地描述函数类型。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/ConsumeFunction.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeFunction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Two <span class="title">consume</span><span class="params">(Function&lt;One,Two&gt; onetwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> onetwo.apply(<span class="keyword">new</span> One());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Two two = consume(one -&gt; <span class="keyword">new</span> Two());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当基于消费函数生成新函数时，事情就变得相当有趣了。代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/TransformFunction.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">O</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformFunction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Function&lt;I,O&gt; <span class="title">transform</span><span class="params">(Function&lt;I,O&gt; in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> in.andThen(o -&gt; &#123;</span><br><span class="line">      System.out.println(o);</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Function&lt;I,O&gt; f2 = transform(i -&gt; &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> O();</span><br><span class="line">    &#125;);</span><br><span class="line">    O o = f2.apply(<span class="keyword">new</span> I());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I</span><br><span class="line">O</span><br></pre></td></tr></table></figure>

<p>在这里，<code>transform()</code> 生成一个与传入的函数具有相同签名的函数，但是你可以生成任何你想要的类型。</p>
<p>这里使用到了 <code>Function</code> 接口中名为 <code>andThen()</code> 的默认方法，该方法专门用于操作函数。 顾名思义，在调用 <code>in</code> 函数之后调用 <code>andThen()</code>（还有个 <code>compose()</code> 方法，它在 <code>in</code> 函数之前应用新函数）。 要附加一个 <code>andThen()</code> 函数，我们只需将该函数作为参数传递。 <code>transform()</code> 产生的是一个新函数，它将 <code>in</code> 的动作与 <code>andThen()</code> 参数的动作结合起来。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在上一节的 <code>ProduceFunction.java</code> 中，我们从方法中返回 Lambda 函数。 虽然过程简单，但是有些问题必须再回过头来探讨一下。</p>
<p><strong>闭包</strong>（Closure）一词总结了这些问题。 它非常重要，利用闭包可以轻松生成函数。</p>
<p>考虑一个更复杂的 Lambda，它使用函数作用域之外的变量。 返回该函数会发生什么？ 也就是说，当你调用函数时，它对那些 “外部 ”变量引用了什么? 如果语言不能自动解决，那问题将变得非常棘手。 能够解决这个问题的语言被称为<strong>支持闭包</strong>，或者叫作在词法上限定范围( 也使用术语<em>变量捕获</em> )。Java 8 提供了有限但合理的闭包支持，我们将用一些简单的例子来研究它。</p>
<p>首先，下列方法返回一个函数，该函数访问对象字段和方法参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure1.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，仔细考虑一下，<code>i</code> 的这种用法并非是个大难题，因为对象很可能在你调用 <code>makeFun()</code> 之后就存在了——实际上，垃圾收集器几乎肯定会保留以这种方式被绑定到现存函数的对象。当然，如果你对同一个对象多次调用 <code>makeFun()</code> ，你最终会得到多个函数，它们共享 <code>i</code> 的存储空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/SharedStorage.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedStorage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Closure1 c1 = <span class="keyword">new</span> Closure1();</span><br><span class="line">    IntSupplier f1 = c1.makeFun(<span class="number">0</span>);</span><br><span class="line">    IntSupplier f2 = c1.makeFun(<span class="number">0</span>);</span><br><span class="line">    IntSupplier f3 = c1.makeFun(<span class="number">0</span>);</span><br><span class="line">    System.out.println(f1.getAsInt());</span><br><span class="line">    System.out.println(f2.getAsInt());</span><br><span class="line">    System.out.println(f3.getAsInt());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>每次调用 <code>getAsInt()</code> 都会增加 <code>i</code>，表明存储是共享的。</p>
<p>如果 <code>i</code> 是 <code>makeFun()</code> 的局部变量怎么办？ 在正常情况下，当 <code>makeFun()</code> 完成时 <code>i</code> 就消失。 但它仍可以编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure2</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由 <code>makeFun()</code> 返回的 <code>IntSupplier</code> “关住了” <code>i</code> 和 <code>x</code>，因此即使<code>makeFun()</code>已执行完毕，当你调用返回的函数时<code>i</code> 和 <code>x</code>仍然有效，而不是像正常情况下那样在 <code>makeFun()</code> 执行后 <code>i</code> 和<code>x</code>就消失了。 但请注意，我没有像 <code>Closure1.java</code> 那样递增 <code>i</code>，因为会产生编译时错误。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure3.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure3</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// x++ 和 i++ 都会报错：</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; x++ + i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x</code> 和 <code>i</code> 的操作都犯了同样的错误：被 Lambda 表达式引用的局部变量必须是 <code>final</code> 或者是等同 <code>final</code> 效果的。</p>
<p>如果使用 <code>final</code> 修饰 <code>x</code>和 <code>i</code>，就不能再递增它们的值了。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure4.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure4</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为什么在 <code>Closure2.java</code> 中， <code>x</code> 和 <code>i</code> 非 <code>final</code> 却可以运行呢？</p>
<p>这就叫做<strong>等同 final 效果</strong>（Effectively Final）。这个术语是在 Java 8 才开始出现的，表示虽然没有明确地声明变量是 <code>final</code> 的，但是因变量值没被改变过而实际有了 <code>final</code> 同等的效果。 如果局部变量的初始值永远不会改变，那么它实际上就是 <code>final</code> 的。</p>
<p>如果 <code>x</code> 和 <code>i</code> 的值在方法中的其他位置发生改变（但不在返回的函数内部），则编译器仍将视其为错误。每个递增操作则会分别产生错误消息。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure5.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;无法编译成功&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure5</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>等同 final 效果</strong>意味着可以在变量声明前加上 <strong>final</strong> 关键字而不用更改任何其余代码。 实际上它就是具备 <code>final</code> 效果的，只是没有明确说明。</p>
<p>通过在闭包中使用 <code>final</code> 关键字提前修饰变量 <code>x</code> 和 <code>i</code> ， 我们解决了 <code>Closure5.java</code> 中的问题。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure6.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure6</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> iFinal = i;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> xFinal = x;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; xFinal + iFinal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中 <code>iFinal</code> 和 <code>xFinal</code> 的值在赋值后并没有改变过，因此在这里使用 <code>final</code> 是多余的。</p>
<p>如果函数式方法中使用的外部局部变量是引用，而不是基本类型的话，会是什么情况呢？我们可以把<code>int</code>类型改为<code>Integer</code>类型研究一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure7.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;无法编译成功&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure7</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="number">0</span>;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器非常聪明地识别到变量 <code>i</code> 的值被更改过。 因为包装类型可能被特殊处理过了，所以我们尝试下 <strong>List</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure8.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure8</span> </span>&#123;</span><br><span class="line">  Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; ai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ai.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> () -&gt; ai;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Closure8 c7 = <span class="keyword">new</span> Closure8();</span><br><span class="line">    List&lt;Integer&gt;</span><br><span class="line">      l1 = c7.makeFun().get(),</span><br><span class="line">      l2 = c7.makeFun().get();</span><br><span class="line">    System.out.println(l1);</span><br><span class="line">    System.out.println(l2);</span><br><span class="line">    l1.add(<span class="number">42</span>);</span><br><span class="line">    l2.add(<span class="number">96</span>);</span><br><span class="line">    System.out.println(l1);</span><br><span class="line">    System.out.println(l2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1]</span><br><span class="line">[1]</span><br><span class="line">[1, 42]</span><br><span class="line">[1, 96]</span><br></pre></td></tr></table></figure>

<p>可以看到，这次一切正常。我们改变了 <strong>List</strong> 的内容却没产生编译时错误。通过观察本例的输出结果，我们发现这看起来非常安全。这是因为每次调用 <code>makeFun()</code> 时，其实都会创建并返回一个全新而非共享的 <code>ArrayList</code>。也就是说，每个闭包都有自己独立的 <code>ArrayList</code>，它们之间互不干扰。</p>
<p>请<strong>注意</strong>我已经声明 <code>ai</code> 是 <code>final</code> 的了。尽管在这个例子中你可以去掉 <code>final</code> 并得到相同的结果（试试吧！）。 应用于对象引用的 <code>final</code> 关键字仅表示不会重新赋值引用。 它并不代表你不能修改对象本身。</p>
<p>下面我们来看看 <code>Closure7.java</code> 和 <code>Closure8.java</code> 之间的区别。我们看到：在 <code>Closure7.java</code> 中变量 <code>i</code> 有过重新赋值。 也许这就是触发<strong>等同 final 效果</strong>错误消息的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Closure9.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;无法编译成功&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure9</span> </span>&#123;</span><br><span class="line">  Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123;</span><br><span class="line">    List&lt;Integer&gt; ai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ai = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// Reassignment</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; ai;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例，重新赋值引用会触发错误消息。如果只修改指向的对象则没问题，只要没有其他人获得对该对象的引用（这意味着你有多个实体可以修改对象，此时事情会变得非常混乱），基本上就是安全的[^6]。</p>
<p>让我们回顾一下 <code>Closure1.java</code>。那么现在问题来了：为什么变量 <code>i</code> 被修改编译器却没有报错呢。 它既不是 <code>final</code> 的，也不是<strong>等同 final 效果</strong>的。因为 <code>i</code> 是外围类的成员，所以这样做肯定是安全的（除非你正在创建共享可变内存的多个函数）。是的，你可以辩称在这种情况下不会发生变量捕获（Variable Capture）。但可以肯定的是，<code>Closure3.java</code> 的错误消息是专门针对局部变量的。因此，规则并非只是“在 Lambda 之外定义的任何变量必须是 <code>final</code> 的或<strong>等同 final 效果</strong>那么简单。相反，你必须考虑捕获的变量是否是<strong>等同 final 效果</strong>的。 如果它是对象中的字段，那么它拥有独立的生存周期，并且不需要任何特殊的捕获，以便稍后在调用 Lambda 时存在。</p>
<h3 id="作为闭包的内部类"><a href="#作为闭包的内部类" class="headerlink" title="作为闭包的内部类"></a>作为闭包的内部类</h3><p>我们可以使用匿名内部类重写之前的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/AnonymousClosure.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousClosure</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 同样规则的应用:</span></span><br><span class="line">    <span class="comment">// i++; // 非等同 final 效果</span></span><br><span class="line">    <span class="comment">// x++; // 同上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x + i; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上只要有内部类，就会有闭包（Java 8 只是简化了闭包操作）。在 Java 8 之前，变量 <code>x</code> 和 <code>i</code> 必须被明确声明为 <code>final</code>。在 Java 8 中，内部类的规则放宽，包括<strong>等同 final 效果</strong>。</p>
<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。在前面的 <code>TransformFunction.java</code> 类中，有一个使用 <code>andThen()</code> 的函数组合示例。一些 <code>java.util.function</code> 接口中包含支持函数组合的方法 [^7]。</p>
<table>
<thead>
<tr>
<th>组合方法</th>
<th>支持接口</th>
</tr>
</thead>
<tbody><tr>
<td><code>andThen(argument)</code> 根据参数执行原始操作</td>
<td><strong>Function BiFunction Consumer BiConsumer IntConsumer LongConsumer DoubleConsumer UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator BinaryOperator</strong></td>
</tr>
<tr>
<td><code>compose(argument)</code> 根据参数执行原始操作</td>
<td><strong>Function UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator</strong></td>
</tr>
<tr>
<td><code>and(argument)</code> 短路<strong>逻辑与</strong>原始谓词和参数谓词</td>
<td><strong>Predicate BiPredicate IntPredicate LongPredicate DoublePredicate</strong></td>
</tr>
<tr>
<td><code>or(argument)</code> 短路<strong>逻辑或</strong>原始谓词和参数谓词</td>
<td><strong>Predicate BiPredicate IntPredicate LongPredicate DoublePredicate</strong></td>
</tr>
<tr>
<td><code>negate()</code> 该谓词的<strong>逻辑否</strong>谓词</td>
<td><strong>Predicate BiPredicate IntPredicate LongPredicate DoublePredicate</strong></td>
</tr>
</tbody></table>
<p>下例使用了 <code>Function</code> 里的 <code>compose()</code>和 <code>andThen()</code>。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/FunctionComposition.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionComposition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Function&lt;String, String&gt;</span><br><span class="line">    f1 = s -&gt; &#123;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">      <span class="keyword">return</span> s.replace(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    f2 = s -&gt; s.substring(<span class="number">3</span>),</span><br><span class="line">    f3 = s -&gt; s.toLowerCase(),</span><br><span class="line">    f4 = f1.compose(f2).andThen(f3);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">      f4.apply(<span class="string">&quot;GO AFTER ALL AMBULANCES&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFTER ALL AMBULANCES</span><br><span class="line">_fter _ll _mbul_nces</span><br></pre></td></tr></table></figure>

<p>这里我们重点看正在创建的新函数 <code>f4</code>。它调用 <code>apply()</code> 的方式与常规几乎无异。</p>
<p>当 <code>f1</code> 获得字符串时，它已经被<code>f2</code> 剥离了前三个字符。这是因为 <code>compose（f2）</code> 表示 <code>f2</code> 的调用发生在 <code>f1</code> 之前。</p>
<p>下例是 <code>Predicate</code> 的逻辑运算演示.代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/PredicateComposition.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateComposition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Predicate&lt;String&gt;</span><br><span class="line">    p1 = s -&gt; s.contains(<span class="string">&quot;bar&quot;</span>),</span><br><span class="line">    p2 = s -&gt; s.length() &lt; <span class="number">5</span>,</span><br><span class="line">    p3 = s -&gt; s.contains(<span class="string">&quot;foo&quot;</span>),</span><br><span class="line">    p4 = p1.negate().and(p2).or(p3);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;foobar&quot;</span>, <span class="string">&quot;foobaz&quot;</span>, <span class="string">&quot;fongopuckey&quot;</span>)</span><br><span class="line">      .filter(p4)</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foobar</span><br><span class="line">foobaz</span><br></pre></td></tr></table></figure>

<p><code>p4</code> 获取到了所有谓词并组合成一个更复杂的谓词。解读：如果字符串中不包含 <code>bar</code> 且长度小于 5，或者它包含 <code>foo</code> ，则结果为 <code>true</code>。</p>
<p>正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了下一章的内容。首先，我创建了一个字符串对象的流，然后将每个对象传递给 <code>filter()</code> 操作。 <code>filter()</code> 使用 <code>p4</code> 的谓词来确定对象的去留。最后我们使用 <code>forEach()</code> 将 <code>println</code> 方法引用应用在每个留存的对象上。</p>
<p>从输出结果我们可以看到 <code>p4</code> 的工作流程：任何带有 <code>&quot;foo&quot;</code> 的字符串都得以保留，即使它的长度大于 5。 <code>&quot;fongopuckey&quot;</code> 因长度超出且不包含 <code>foo</code> 而被丢弃。</p>
<h2 id="柯里化和部分求值"><a href="#柯里化和部分求值" class="headerlink" title="柯里化和部分求值"></a>柯里化和部分求值</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Currying">柯里化</a>（Currying）的名称来自于其发明者之一 <em>Haskell Curry</em>。他可能是计算机领域唯一姓氏和名字都命名过重要概念的人（另外就是 Haskell 编程语言）。 柯里化意为：将一个多参数的函数，转换为一系列单参数函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/CurryingAndPartials.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurryingAndPartials</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 未柯里化:</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> String <span class="title">uncurried</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 柯里化的函数:</span></span><br><span class="line">      Function&lt;String, Function&lt;String, String&gt;&gt; sum =</span><br><span class="line">         a -&gt; b -&gt; a + b; <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">      System.out.println(uncurried(<span class="string">&quot;Hi &quot;</span>, <span class="string">&quot;Ho&quot;</span>));</span><br><span class="line"></span><br><span class="line">      Function&lt;String, String&gt;</span><br><span class="line">        hi = sum.apply(<span class="string">&quot;Hi &quot;</span>); <span class="comment">// [2]</span></span><br><span class="line">      System.out.println(hi.apply(<span class="string">&quot;Ho&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 部分应用:</span></span><br><span class="line">      Function&lt;String, String&gt; sumHi =</span><br><span class="line">        sum.apply(<span class="string">&quot;Hup &quot;</span>);</span><br><span class="line">      System.out.println(sumHi.apply(<span class="string">&quot;Ho&quot;</span>));</span><br><span class="line">      System.out.println(sumHi.apply(<span class="string">&quot;Hey&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hi Ho</span><br><span class="line">Hi Ho</span><br><span class="line">Hup Ho</span><br><span class="line">Hup Hey</span><br></pre></td></tr></table></figure>

<p><strong>[1]</strong> 这一连串的箭头很巧妙。<em>注意</em>，在函数接口声明中，第二个参数是另一个函数。</p>
<p><strong>[2]</strong> 柯里化的目的是能够通过提供一个参数来创建一个新函数，所以现在有了一个“带参函数”和剩下的 “自由函数”（free argumnet） 。实际上，你从一个双参数函数开始，最后得到一个单参数函数。</p>
<p>我们可以通过添加级别来柯里化一个三参数函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// functional/Curry3Args.java</span><br><span class="line"></span><br><span class="line">import java.util.function.*;</span><br><span class="line"></span><br><span class="line">public class Curry3Args &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Function&lt;String,</span><br><span class="line">        Function&lt;String,</span><br><span class="line">          Function&lt;String, String&gt;&gt;&gt; sum =</span><br><span class="line">            a -&gt; b -&gt; c -&gt; a + b + c;</span><br><span class="line">      Function&lt;String,</span><br><span class="line">        Function&lt;String, String&gt;&gt; hi =</span><br><span class="line">          sum.apply(&quot;Hi &quot;);</span><br><span class="line">      Function&lt;String, String&gt; ho =</span><br><span class="line">        hi.apply(&quot;Ho &quot;);</span><br><span class="line">      System.out.println(ho.apply(&quot;Hup&quot;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi Ho Hup</span><br></pre></td></tr></table></figure>

<p>对于每个级别的箭头级联（Arrow-cascading），你都要在类型声明中包裹另一层 <strong>Function</strong>。</p>
<p>处理基本类型和装箱时，请使用适当的函数式接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// functional/CurriedIntAdd.java</span><br><span class="line"></span><br><span class="line">import java.util.function.*;</span><br><span class="line"></span><br><span class="line">public class CurriedIntAdd &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    IntFunction&lt;IntUnaryOperator&gt;</span><br><span class="line">      curriedIntAdd = a -&gt; b -&gt; a + b;</span><br><span class="line">    IntUnaryOperator add4 = curriedIntAdd.apply(4);</span><br><span class="line">    System.out.println(add4.applyAsInt(5));</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<p>可以在互联网上找到更多的柯里化示例。通常它们是用 Java 之外的语言实现的，但如果理解了柯里化的基本概念，你可以很轻松地用 Java 实现它们。</p>
<h2 id="纯函数式编程"><a href="#纯函数式编程" class="headerlink" title="纯函数式编程"></a>纯函数式编程</h2><p>即使没有函数式支持，像 C 这样的基础语言，也可以按照一定的原则编写纯函数式程序。Java 8 让函数式编程更简单，不过我们要确保一切是 <code>final</code> 的，同时你的所有方法和函数没有副作用。因为 Java 在本质上并非是不可变语言，所以编译器对我们犯的错误将无能为力。</p>
<p>这种情况下，我们可以借助第三方工具，但使用 Scala 或 Clojure 这样的语言可能更简单。因为它们从一开始就是为保持不变性而设计的。你可以采用这些语言来编写你的 Java 项目的一部分。如果必须要用纯函数式编写，则可以用 Scala（需要遵循一些规则） 或 Clojure （遵循的规则更少）。虽然 Java 支持<a target="_blank" rel="noopener" href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book/24-Concurrent-Programming.md">并发编程</a>，但如果这是你项目的核心部分，你应该考虑在项目部分功能中使用 <code>Scala</code> 或 <code>Clojure</code> 之类的语言。</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>Lambda 表达式和方法引用并没有将 Java 转换成函数式语言，而是提供了对函数式编程的支持。这对 Java 来说是一个巨大的改进。因为这允许你编写更简洁明了，易于理解的代码。在下一章中，你会看到它们在流式编程中的应用。相信你会像我一样，喜欢上流式编程。</p>
<p>这些特性满足了很多羡慕Clojure、Scala 这类更函数化语言的程序员，并且阻止了Java程序员转向那些更函数化的语言（就算不能阻止，起码提供了更好的选择）。</p>
<p>但是，Lambdas 和方法引用远非完美，我们永远要为 Java 设计者早期的草率决定付出代价。特别是没有泛型 Lambda，所以 Lambda 在 Java 中并非一等公民。虽然我不否认 Java 8 的巨大改进，但这意味着和许多 Java 特性一样，它终究还是会让人感觉沮丧和鸡肋。</p>
<p>当你遇到学习困难时，请记住通过 IDE（NetBeans、IntelliJ Idea 和 Eclipse）获得帮助，因为 IDE 可以智能提示你何时使用 Lambda 表达式或方法引用，甚至有时还能为你优化代码。</p>
</div></div><a class="button-hover more" href="/2021/10/18/JAVA%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h1 id="0818"><a href="#0818" class="headerlink" title="0818"></a>0818</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>人们倾向于将术语 <em>JUnit 5</em> 和 <em>JUnit Jupiter</em> 当作同义词使用。在大部分情况下，这种互换使用没有什么问题。但是，一定要认识到这两个术语是不同的。<em>JUnit Jupiter</em> 是使用 JUnit 5 编写测试内容的 API。<em>JUnit 5</em> 是一个项目名称（和版本），其 3 个主要模块关注不同的方面：JUnit Jupiter、JUnit Platform 和 JUnit Vintage。</p>
<p>当我提及 JUnit Jupiter 时，指的是编写单元测试的 API；提及 JUnit 5 时，指的是整个项目。</p>
<h4 id="JUnit-5-概述"><a href="#JUnit-5-概述" class="headerlink" title="JUnit 5 概述"></a>JUnit 5 概述</h4><p>以前的 JUnit 版本都是整体式的。除了在 4.4 版中包含 Hamcrest JAR，JUnit 基本来讲就是一个很大的 JAR 文件。测试内容编写者 — 像您我这样的开发人员 — 和工具供应商都使用它的 API，但后者使用很多内部 JUnit API。</p>
<p>大量使用内部 API 给 JUnit 的维护者造成了一些麻烦，并且留给他们推动该技术发展的选择余地不多。来自 <a target="_blank" rel="noopener" href="http://junit.org/junit5/docs/current/user-guide/#api-evolution"><em>JUnit 5 用户指南</em></a>：</p>
<blockquote>
<p>“在 JUnit 4 中，只有外部扩展编写者和工具构建者才使用最初作为内部结构而添加的许多功能。这让更改 JUnit 4 变得特别困难，有时甚至根本不可能。”</p>
</blockquote>
<p>JUnit Lambda（现在称为 JUnit 5）团队决定将 JUnit 重新设计为两个明确且不同的关注区域：</p>
<ul>
<li>一个是编写测试内容的 API。</li>
<li>一个是发现和运行这些测试的 API。</li>
</ul>
<p>这些关注区域现在已整合到 JUnit 5 的架构中，并且它们是明确分离的。图 1 演示了新架构（图像来自 <a target="_blank" rel="noopener" href="https://blog.codefx.org/design/architecture/junit-5-architecture/">Nicolai Parlog</a>）：</p>
<h5 id="图-1-JUnit-5-的架构"><a href="#图-1-JUnit-5-的架构" class="headerlink" title="图 1. JUnit 5 的架构"></a>图 1. JUnit 5 的架构</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-1.png" alt="JUnit 5 架构示意图。"></p>
<p>如果仔细查看图 1，就会发现 JUnit 5 的架构有多么强大。好了，让我们<em>仔细</em>看看这个架构。右上角的方框表明，对 JUnit 5 而言，JUnit Jupiter API 只是<em>另一个 API</em>！因为 JUnit Jupiter 的组件遵循新的架构，所以它们可应用 JUnit 5，但您可以轻松定义不同的测试框架。只要一个框架实现了 <code>TestEngine</code> 接口，就可以将它插入任何支持 <code>junit-platform-engine</code> 和 <code>junit-platform-launcher</code> API 的工具中！</p>
<p>我仍然认为 JUnit Jupiter 非常特殊（毕竟我即将用一整篇教程来介绍它），但 JUnit 5 团队完成的工作确实具有开创性。我只是想指出这一点。我们继续看看图 1，直到我们完全达成一致。</p>
<h4 id="使用-JUnit-Jupiter-编写测试内容"><a href="#使用-JUnit-Jupiter-编写测试内容" class="headerlink" title="使用 JUnit Jupiter 编写测试内容"></a>使用 JUnit Jupiter 编写测试内容</h4><p>就测试编写者而言，任何符合 JUnit 规范的测试框架（包括 JUnit Jupiter）都包含两个组件：</p>
<ul>
<li>我们为其编写测试的 API。</li>
<li>理解这个特定 API 的 JUnit <code>TestEngine</code> 实现。</li>
</ul>
<p>对于本教程，前者是 JUnit Jupiter API，后者是 JUnit Jupiter Test Engine。我将介绍这二者。</p>
<h5 id="JUnit-Jupiter-API"><a href="#JUnit-Jupiter-API" class="headerlink" title="JUnit Jupiter API"></a>JUnit Jupiter API</h5><p>作为开发人员，您将使用 JUnit Jupiter API 创建单元测试来测试您的应用程序代码。使用该 API 的基本特性 — 注解、断言等 — 是本部分教程的主要关注点。</p>
<p>JUnit Jupiter API 的设计让您可通过插入各种生命周期回调来扩展它的功能。您将在第 2 部分中了解如何使用这些回调完成有趣的工作，比如运行参数化测试，将参数传递给测试方法，等等。</p>
<h5 id="JUnit-Jupiter-Test-Engine"><a href="#JUnit-Jupiter-Test-Engine" class="headerlink" title="JUnit Jupiter Test Engine"></a>JUnit Jupiter Test Engine</h5><p>您将使用 JUnit Jupiter Test Engine 发现和执行 JUnit Jupiter 单元测试。该测试引擎实现了 JUnit Platform 中包含的 <code>TestEngine</code> 接口。可将 <code>TestEngine</code> 看作单元测试与用于启动它们的工具（比如 IDE）之间的桥梁。</p>
<h4 id="使用-JUnit-Platform-运行测试"><a href="#使用-JUnit-Platform-运行测试" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h4><p>在 JUnit 术语中，运行单元测试的过程分为两部分：</p>
<ul>
<li><em>发现</em>测试和创建<em>测试计划</em>。</li>
<li><em>启动</em>测试计划，以 (1) 执行测试和 (2) 向用户报告结果。</li>
</ul>
<h4 id="用于发现测试的-API"><a href="#用于发现测试的-API" class="headerlink" title="用于发现测试的 API"></a>用于发现测试的 API</h4><p>用于发现测试和创建测试计划的 API 包含在 JUnit Platform 中，由一个 <code>TestEngine</code> 实现。该测试框架将测试发现功能封装到其 <code>TestEngine</code> 实现中。JUnit Platform 负责使用 IDE 和构建工具（比如 Gradle 和 Maven）发起测试发现流程。</p>
<p>测试发现的目的是创建测试计划，该计划中包含一个<em>测试规范</em>。测试规范包含以下组件：</p>
<ul>
<li><p>选择器</p>
<p>，比如：</p>
<ul>
<li>要扫描哪个包来寻找测试类</li>
<li>特定的类名称</li>
<li>特定的方法</li>
<li>类路径根文件夹</li>
</ul>
</li>
<li><p>过滤器</p>
<p>，比如：</p>
<ul>
<li>类名称模式（比如 “.*Test”）</li>
<li>标签（将在第 2 部分中讨论）</li>
<li>特定的测试引擎（比如 “junit-jupiter”）</li>
</ul>
</li>
</ul>
<p>测试计划是根据测试规范所发现的所有测试类、这些类中的测试方法、测试引擎等的分层视图。测试计划准备就绪后，就可以执行了。</p>
<h4 id="用于执行测试的-API"><a href="#用于执行测试的-API" class="headerlink" title="用于执行测试的 API"></a>用于执行测试的 API</h4><p>用于执行测试的 API 包含在 JUnit Platform 中，由一个或多个 <code>TestEngine</code> 实现。测试框架将测试执行功能封装在它们的 <code>TestEngine</code> 实现中，但 JUnit Platform 负责发起测试执行流程。通过 IDE 和构建工具（比如 Gradle 和 Maven）发起测试执行工作。</p>
<p>一个名为 <code>Launcher</code> 的 JUnit Platform 组件负责执行在测试发现期间创建的测试计划。某个流程 — 假设是您的 IDE — 通过 JUnit Platform（具体来讲是 <code>junit-platform-launcher</code> API）发起测试执行流程。这时，JUnit Platform 将测试计划连同 <code>TestExecutionListener</code> 一起传递给 <code>Launcher</code>。<code>TestExecutionListener</code> 将报告测试执行结果，从而在您的 IDE 中显示该结果。</p>
<p>测试执行流程的目的是向用户准确报告在测试运行时发生了哪些事件。这包括测试成功和失败报告，以及伴随失败而生成的消息，帮助用户理解所发生的事件。</p>
<h4 id="后向兼容性：JUnit-Vintage"><a href="#后向兼容性：JUnit-Vintage" class="headerlink" title="后向兼容性：JUnit Vintage"></a>后向兼容性：JUnit Vintage</h4><p>许多组织对 JUnit 3 和 4 进行了大力投资，因此无法承担向 JUnit 5 的大规模转换。了解到这一点后，JUnit 5 团队提供了 <code>junit-vintage-engine</code> 和 <code>junit-jupiter-migration-support</code> 组件来帮助企业进行迁移。</p>
<p>对 JUnit Platform 而言，JUnit Vintage 只是另一个测试框架，包含自己的 <code>TestEngine</code> 和 API（具体来讲是 JUnit 4 API）。</p>
<p>图 2 显示了各种 JUnit 5 包之间的依赖关系。</p>
<h5 id="图-2-JUnit-5-包关系图"><a href="#图-2-JUnit-5-包关系图" class="headerlink" title="图 2. JUnit 5 包关系图"></a>图 2. JUnit 5 包关系图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-2.png" alt="JUnit 5 包示意图。"></p>
<h4 id="opentest4j-的用途"><a href="#opentest4j-的用途" class="headerlink" title="opentest4j 的用途"></a>opentest4j 的用途</h4><p>支持 JUnit 的测试框架在如何处理测试执行期间抛出的异常方面有所不同。JVM 上的测试没有统一标准，这是 JUnit 团队一直要面对的问题。除了 <code>java.lang.AssertionError</code>，测试框架还必须定义自己的异常分层结构，或者将自身与 JUnit 支持的异常结合起来（或者在某些情况下同时采取两种方法）。</p>
<p><strong>支持 opentest4j</strong>：要加入 Open Test Alliance for the JVM，或者提供反馈来帮助该联盟推进工作，请访问 <a target="_blank" rel="noopener" href="https://github.com/ota4j-team/opentest4j">opentest4j</a> Github 存储库并单击 <em>CONTRIBUTING.md</em> 链接。</p>
<p>为了解决一致性问题，JUnit 团队提议建立一个开源项目，该项目目前称为 Open Test Alliance for the JVM（JVM 开放测试联盟）。该联盟在此阶段仅是一个提案，它仅定义了初步的异常分层结构。但是，JUnit 5 使用 <code>opentest4j</code> 异常。（可在图 2 中看到这一点；请注意从 <code>junit-jupiter-api</code> 和 <code>junit-platform-engine</code> 包到 <code>opentest4j</code> 包的依赖线。）</p>
<p>现在您已基本了解各种 JUnit 5 组件如何结合在一起，是时候使用 JUnit Jupiter API 编写一些测试了！</p>
<h3 id="使用-JUnit-Jupiter-编写测试"><a href="#使用-JUnit-Jupiter-编写测试" class="headerlink" title="使用 JUnit Jupiter 编写测试"></a>使用 JUnit Jupiter 编写测试</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>从 JUnit 4 开始，注解 (annotation) 就成为测试框架的核心特性，这一趋势在 JUnit 5 中得以延续。我无法介绍 JUnit 5 的所有注解，本节仅简要介绍最常用的注解。</p>
<p>首先，我将比较 JUnit 4 中与 JUnit 5 中的注解。JUnit 5 团队更改了一些注解的名称，让它们更直观，同时保持功能不变。如果您正在使用 JUnit 4，下表将帮助您适应这些更改。</p>
<h5 id="表-1-JUnit-4-与-JUnit-5-中的注解比较"><a href="#表-1-JUnit-4-与-JUnit-5-中的注解比较" class="headerlink" title="表 1. JUnit 4 与 JUnit 5 中的注解比较"></a>表 1. JUnit 4 与 JUnit 5 中的注解比较</h5><table>
<thead>
<tr>
<th>JUnit 5</th>
<th>JUnit 4</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>@Test</td>
<td>被注解的方法是一个测试方法。与 JUnit 4 相同。</td>
</tr>
<tr>
<td>@BeforeAll</td>
<td>@BeforeClass</td>
<td>被注解的（静态）方法将在当前类中的所有 @Test 方法前执行一次。</td>
</tr>
<tr>
<td>@BeforeEach</td>
<td>@Before</td>
<td>被注解的方法将在当前类中的每个 @Test 方法前执行。</td>
</tr>
<tr>
<td>@AfterEach</td>
<td>@After</td>
<td>被注解的方法将在当前类中的每个 @Test 方法后执行。</td>
</tr>
<tr>
<td>@AfterAll</td>
<td>@AfterClass</td>
<td>被注解的（静态）方法将在当前类中的所有 @Test 方法后执行一次。</td>
</tr>
<tr>
<td>@Disabled</td>
<td>@Ignore</td>
<td>被注解的方法不会执行（将被跳过），但会报告为已执行。</td>
</tr>
</tbody></table>
<h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>接下来看看一些使用这些注解的示例。尽管一些注解已在 JUnit 5 中重命名，但如果您使用过 JUnit 4，应熟悉它们的功能。清单 1 中的代码来自 <code>JUnit5AppTest.java</code>，可在 <a target="_blank" rel="noopener" href="https://github.com/makotogo/HelloJUnit5">HelloJUnit5</a> 示例应用程序中找到。</p>
<h5 id="清单-1-基本注解"><a href="#清单-1-基本注解" class="headerlink" title="清单 1. 基本注解"></a>清单 1. 基本注解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing using JUnit 5&quot;)``public class JUnit5AppTest &#123;`` ` ` ``private static final Logger log = LoggerFactory.getLogger(JUnit5AppTest.class);`` ` ` ``private App classUnderTest;`` ` ` ``@BeforeAll`` ``public static void init() &#123;``  ``// Do something before ANY test is run in this class`` ``&#125;`` ` ` ``@AfterAll`` ``public static void done() &#123;``  ``// Do something after ALL tests in this class are run`` ``&#125;`` ` ` ``@BeforeEach`` ``public void setUp() throws Exception &#123;``  ``classUnderTest = new App();`` ``&#125;`` ` ` ``@AfterEach`` ``public void tearDown() throws Exception &#123;``  ``classUnderTest = null;`` ``&#125;`` ` ` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void aTest() &#123;``  ``log.info(&quot;As written, this test will always pass!&quot;);``  ``assertEquals(4, (2 + 2));`` ``&#125;`` ` ` ``@Test`` ``@Disabled`` ``@DisplayName(&quot;A disabled test&quot;)`` ``void testNotRun() &#123;``  ``log.info(&quot;This test will not run (it is disabled, silly).&quot;);`` ``&#125;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>看看上面突出显示行中的注解：</p>
<ul>
<li>第 1 行：<code>@RunWith</code> 连同它的参数 <code>JUnitPlatform.class</code>（一个基于 JUnit 4 且理解 JUnit Platform 的 <code>Runner</code>）让您可以在 Eclipse 内运行 JUnit Jupiter 单元测试。Eclipse 尚未原生支持 JUnit 5。未来，Eclipse 将提供原生的 JUnit 5 支持，那时我们不再需要此注解。</li>
<li>第 2 行：<code>@DisplayName</code> 告诉 JUnit 在报告测试结果时显示 <code>String</code> “Testing using JUnit 5”，而不是测试类的名称。</li>
<li>第 9 行：<code>@BeforeAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之前</em>运行 <code>init()</code> 方法<strong>一次</strong>。</li>
<li>第 14 行：<code>@AfterAll</code> 告诉 JUnit 在运行这个类中的所有 <code>@Test</code> 方法<em>之后</em>运行 <code>done()</code> 方法<strong>一次</strong>。</li>
<li>第 19 行：<code>@BeforeEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之前</em>运行 <code>setUp()</code> 方法。</li>
<li>第 24 行：<code>@AfterEach</code> 告诉 JUnit 在此类中的<strong>每个</strong><code>@Test</code> 方法<em>之后</em>运行 <code>tearDown()</code> 方法。</li>
<li>第 29 行：<code>@Test</code> 告诉 JUnit，<code>aTest()</code> 方法是一个 JUnit Jupiter 测试方法。</li>
<li>第 37 行：<code>@Disabled</code> 告诉 JUnit 不运行此 <code>@Test</code> 方法，因为它已被禁用。</li>
</ul>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p><em>断言 (assertion)</em> 是 <code>org.junit.jupiter.api.Assertions</code> 类上的众多静态方法之一。断言用于测试一个条件，该条件必须计算为 <code>true</code>，测试才能继续执行。</p>
<p>如果断言失败，测试会在断言所在的代码行上停止，并生成断言失败报告。如果断言成功，测试会继续执行下一行代码。</p>
<p>表 2 中列出的所有 JUnit Jupiter 断言方法都接受一个可选的 <code>message</code> 参数（作为最后一个参数），以显示断言是否失败，而不是显示标准的缺省消息。</p>
<h5 id="表-2-JUnit-Jupiter-中的断言"><a href="#表-2-JUnit-Jupiter-中的断言" class="headerlink" title="表 2. JUnit Jupiter 中的断言"></a>表 2. JUnit Jupiter 中的断言</h5><table>
<thead>
<tr>
<th>断言方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>assertEquals(expected, actual)</code></td>
<td>如果 <em>expected</em> 不等于 <em>actual</em>，则断言失败。</td>
</tr>
<tr>
<td><code>assertFalse(booleanExpression)</code></td>
<td>如果 <em>booleanExpression</em> 不是 <code>false</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertNull(actual)</code></td>
<td>如果 <em>actual</em> 不是 <code>null</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertNotNull(actual)</code></td>
<td>如果 <em>actual</em> 是 <code>null</code>，则断言失败。</td>
</tr>
<tr>
<td><code>assertTrue(booleanExpression)</code></td>
<td>如果 <em>booleanExpression</em> 不是 <code>true</code>，则断言失败。</td>
</tr>
</tbody></table>
<p>清单 2 给出了一个使用这些断言的示例，该示例来自 HelloJUnit5 示例应用程序。</p>
<h5 id="清单-2-示例应用程序中的-JUnit-Jupiter-断言"><a href="#清单-2-示例应用程序中的-JUnit-Jupiter-断言" class="headerlink" title="清单 2. 示例应用程序中的 JUnit Jupiter 断言"></a>清单 2. 示例应用程序中的 JUnit Jupiter 断言</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertEquals;``import static org.junit.jupiter.api.Assertions.assertFalse;``import static org.junit.jupiter.api.Assertions.assertNotNull;``import static org.junit.jupiter.api.Assertions.assertNull;``import static org.junit.jupiter.api.Assertions.assertTrue;``.``.`` ``@Test`` ``@DisplayName(&quot;Dummy test&quot;)`` ``void dummyTest() &#123;``  ``int expected = 4;``  ``int actual = 2 + 2;``  ``assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;);``  ``//``  ``Object nullValue = null;``  ``assertFalse(nullValue != null);``  ``assertNull(nullValue);``  ``assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;);``  ``assertTrue(nullValue == null);``  ``.``  ``.`` ``&#125;</span><br></pre></td></tr></table></figure>

<p>看看上面突出显示行中的断言：</p>
<ul>
<li>第 13 行：<code>assertEquals</code>：如果第一个参数值 (4) 不等于第二个参数值 (2+2)，则断言失败。在报告断言失败时使用用户提供的消息（该方法的第 3 个参数）。</li>
<li>第 16 行：<code>assertFalse</code>：表达式 <code>nullValue != null</code> 必须为 <code>false</code>，否则断言失败。</li>
<li>第 17 行：<code>assertNull</code>：<code>nullValue</code> 参数必须为 <code>null</code>，否则断言失败。</li>
<li>第 18 行：<code>assertNotNull</code>：<code>String</code> 文字值 “A String” 不得为 <code>null</code>，否则断言失败并报告消息 “INCONCEIVABLE!”（而不是缺省的 “Assertion failed” 消息）。</li>
<li>第 19 行：<code>assertTrue</code>：如果表达式 <code>nullValue == null</code> 不等于 <code>true</code>，则断言失败。</li>
</ul>
<p>除了支持这些标准断言，JUnit Jupiter AP 还提供了多个新断言。下面介绍其中的两个。</p>
<h5 id="方法-assertAll"><a href="#方法-assertAll" class="headerlink" title="方法 @assertAll()"></a>方法 @assertAll()</h5><p>清单 3 中的 <code>@assertAll()</code> 方法给出了清单 2 中看到的相同断言，但包装在一个新的断言方法中：</p>
<h5 id="清单-3-assertAll"><a href="#清单-3-assertAll" class="headerlink" title="清单 3. assertAll()"></a>清单 3. assertAll()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertAll;``.``.``@Test``@DisplayName(&quot;Dummy test&quot;)``void dummyTest() &#123;`` ``int expected = 4;`` ``int actual = 2 + 2;`` ``Object nullValue = null;`` ``.`` ``.`` ``assertAll(``   ``&quot;Assert All of these&quot;,``   ``() -&gt; assertEquals(expected, actual, &quot;INCONCEIVABLE!&quot;),``   ``() -&gt; assertFalse(nullValue != null),``   ``() -&gt; assertNull(nullValue),``   ``() -&gt; assertNotNull(&quot;A String&quot;, &quot;INCONCEIVABLE!&quot;),``   ``() -&gt; assertTrue(nullValue == null));``&#125;</span><br></pre></td></tr></table></figure>

<p><code>assertAll()</code> 的有趣之处在于，它包含的<em>所有</em>断言都会执行，即使一个或多个断言失败也是如此。与此相反，在清单 2 中的代码中，如果<em>任何</em>断言失败，测试就会在该位置失败，意味着不会执行任何其他断言。</p>
<h5 id="方法-assertThrows"><a href="#方法-assertThrows" class="headerlink" title="方法 @assertThrows()"></a>方法 @assertThrows()</h5><p>在某些条件下，接受测试的类应抛出异常。JUnit 4 通过 <code>expected =</code> 方法参数或一个 <code>@Rule</code> 提供此能力。与此相反，JUnit Jupiter 通过 <code>Assertions</code> 类提供此能力，使它与其他断言更加一致。</p>
<p>我们将所预期的异常视为可以进行断言的另一个条件，因此 <code>Assertions</code> 包含处理此条件的方法。清单 4 引入了新的 <code>assertThrows()</code> 断言方法。</p>
<h5 id="清单-4-assertThrows"><a href="#清单-4-assertThrows" class="headerlink" title="清单 4. assertThrows()"></a>清单 4. assertThrows()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.assertThrows;``import static org.junit.jupiter.api.Assertions.assertEquals;``.``.``@Test()``@DisplayName(&quot;Empty argument&quot;)``public void testAdd_ZeroOperands_EmptyArgument() &#123;`` ``long[] numbersToSum = &#123;&#125;;`` ``assertThrows(IllegalArgumentException.class, () -&gt; classUnderTest.add(numbersToSum));``&#125;</span><br></pre></td></tr></table></figure>

<p>请注意第 9 行：如果对 <code>classUnderTest.add()</code> 的调用没有抛出 <code>IllegalArgumentException</code>，则断言失败。</p>
<h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>前置条件 (Assumption) 与断言类似，但前置条件必须为 true，否则测试将<em>中止</em>。与此相反，当断言失败时，则将测试视为已<em>失败</em>。测试方法只应在某些条件 —<em>前置条件</em>下执行时，前置条件很有用。</p>
<p><em>前置条件</em>是 <code>org.junit.jupiter.api.Assumptions</code> 类的静态方法。要理解前置条件的价值，只需一个简单的示例。</p>
<p>假如您只想在星期五运行一个特定的单元测试（我假设您有自己的理由）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test``@DisplayName(&quot;This test is only run on Fridays&quot;)``public void testAdd_OnlyOnFriday() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumeTrue(ldt.getDayOfWeek().getValue() == 5);`` ``// Remainder of test (only executed if assumption holds)...``&#125;</span><br></pre></td></tr></table></figure>

<p>在此情况下，如果条件不成立（第 5 行），就不会执行 lambda 表达式的内容。</p>
<h5 id="使用断言还是前置条件"><a href="#使用断言还是前置条件" class="headerlink" title="使用断言还是前置条件"></a>使用断言还是前置条件</h5><p>二者的区别可能很细微，所以可使用这条经验法则：使用断言<em>检查一个测试方法的结果</em>。使用前置条件<em>确定是否运行测试方法</em>。不会将已中止的测试报告为失败，意味着这种失败不会中断构建工作。</p>
<p>请注意第 5 行：如果该条件不成立，则跳过该测试。在此情况下，该测试不是在星期五 (5) 运行的。这不会影响项目的 “绿色” 部分，而且不会导致构建失败；会跳过 <code>assumeTrue()</code> 后的测试方法中的所有代码。</p>
<p>如果在前置条件成立时仅应执行测试方法的一<em>部分</em>，可以使用 <code>assumingThat()</code> 方法编写上述条件，该方法使用 lambda 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test``@DisplayName(&quot;This test is only run on Fridays (with lambda)&quot;)``public void testAdd_OnlyOnFriday_WithLambda() &#123;`` ``LocalDateTime ldt = LocalDateTime.now();`` ``assumingThat(ldt.getDayOfWeek().getValue() == 5,``   ``() -&gt; &#123;``    ``// Execute this if assumption holds...``   ``&#125;);`` ``// Execute this regardless``&#125;</span><br></pre></td></tr></table></figure>

<p>注意，无论 <code>assumingThat()</code> 中的前置条件成立与否，都会执行 lambda 表达式后的所有代码。</p>
<h4 id="嵌套单元测试，实现清晰的结构"><a href="#嵌套单元测试，实现清晰的结构" class="headerlink" title="嵌套单元测试，实现清晰的结构"></a>嵌套单元测试，实现清晰的结构</h4><p>在继续介绍下节内容之前，我想介绍在 JUnit 5 中编写单元测试的最后一个特性。</p>
<p>JUnit Jupiter API 允许您创建嵌套的类，以保持测试代码更清晰，这有助于让测试结果更易读。通过在主类中创建嵌套的测试类，可以创建更多的名称空间，这提供了两个主要优势：</p>
<ul>
<li>每个单元测试可以拥有自己的测试前和测试后生命周期。这让您能使用特殊条件创建要测试的类，从而测试极端情况。</li>
<li>单元测试方法的名称变得更简单。在 JUnit 4 中，所有测试方法都以对等形式存在，不允许重复的方法名（所以您最终会得到类似 <code>testMethodButOnlyUnderThisOrThatCondition_2()</code> 的方法名）。从 JUnit Jupiter 开始，只有嵌套类中的方法必须具有唯一的名称。清单 6 展示了这一优势。</li>
</ul>
<h5 id="清单-5-传递一个空或-null-数组引用"><a href="#清单-5-传递一个空或-null-数组引用" class="headerlink" title="清单 5. 传递一个空或 null 数组引用"></a>清单 5. 传递一个空或 null 数组引用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnitPlatform.class)``@DisplayName(&quot;Testing JUnit 5&quot;)``public class JUnit5AppTest &#123;``.``.        `` ``@Nested`` ``@DisplayName(&quot;When zero operands&quot;)`` ``class JUnit5AppZeroOperandsTest &#123;`` ` ` ``// @Test methods go here...`` ` ` ``&#125;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>请注意第 6 行，其中的 <code>JUnit5AppZeroOperandsTest</code> 类可以拥有测试方法。任何测试的结果都会在父类 <code>JUnit5AppTest</code> 中以嵌套的形式显示。</p>
<h4 id="使用-JUnit-Platform-运行测试-1"><a href="#使用-JUnit-Platform-运行测试-1" class="headerlink" title="使用 JUnit Platform 运行测试"></a>使用 JUnit Platform 运行测试</h4><p>能编写单元测试很不错，但如果不能运行它们，就没有什么意义了。本节展示如何在 Eclipse 中运行 JUnit 测试，首先使用 Maven，然后从命令行使用 Gradle。</p>
<p>下面的视频展示了如何从 GitHub 克隆示例应用程序代码，并在 Eclipse 中运行测试。在该视频中，我还展示了如何从命令行以及 Eclipse 内使用 Maven 和 Gradle 运行单元测试。Eclipse 对 Maven 和 Gradle 都提供了很好的支持。</p>
<p><strong>应用 3 种工具运行单元测试</strong></p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/intro-to-java-junit.png" alt="应用 3种工具运行单元测试"></p>
<p>下面将提供一些简要的说明，但该视频提供了更多细节。观看该视频，了解如何：</p>
<ul>
<li>从 GitHub 克隆 HelloJUnit5 示例应用程序。</li>
<li>将应用程序导入 Eclipse 中。</li>
<li>从 Eclipse 内的 HelloJUnit5 应用程序运行一个 JUnit 测试。</li>
<li>使用 Maven 从命令行运行 HelloJUnit5 单元测试。</li>
<li>使用 Gradle 从命令行运行 HelloJUnit5 单元测试。</li>
</ul>
<h5 id="克隆-HelloJUnit5-示例应用程序"><a href="#克隆-HelloJUnit5-示例应用程序" class="headerlink" title="克隆 HelloJUnit5 示例应用程序"></a>克隆 HelloJUnit5 示例应用程序</h5><p>要理解教程的剩余部分，您需要从 GitHub 克隆示例应用程序。为此，可打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您希望放入代码的目录，然后输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/makotogo/HelloJUnit5</span><br></pre></td></tr></table></figure>

<p>现在您的机器上已拥有该代码，可以在 Eclipse IDE 内运行 JUnit 测试了。接下来介绍如何运行测试。</p>
<h5 id="在-Eclipse-IDE-中运行单元测试"><a href="#在-Eclipse-IDE-中运行单元测试" class="headerlink" title="在 Eclipse IDE 中运行单元测试"></a>在 Eclipse IDE 中运行单元测试</h5><p>如果您已跟随该视频进行操作，应该已将代码导入 Eclipse 中。现在，在 Eclipse 中打开 <strong>Project Explorer</strong> 视图，展开 HelloJUnit5 项目，直至看到 <code>src/test/java</code> 路径下的 <code>JUnit5AppTest</code> 类。</p>
<p>打开 <code>JUnit5AppTest.java</code> 并验证 <code>class</code> 定义前的下面这个注解（以下代码的第 3 行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.``.``@RunWith(JUnitPlatform.class)``public class JUnit5AppTest &#123;``.``.``&#125;</span><br></pre></td></tr></table></figure>

<p>现在右键单击 <code>JUnit5AppTest</code> 并选择 <strong>Run As &gt; JUnit Test</strong>。单元测试运行时，JUnit 视图将会出现。您现在已准备好完成本教程的练习。</p>
<h5 id="使用-Maven-运行单元测试"><a href="#使用-Maven-运行单元测试" class="headerlink" title="使用 Maven 运行单元测试"></a>使用 Maven 运行单元测试</h5><p>打开一个终端窗口 (Mac) 或命令提示 (Windows)，导航到您将 HelloJUnit5 应用程序克隆到的目录，然后输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>

<p>这会启动 Maven 构建并运行单元测试。您的输出应类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean test``[INFO] Scanning for projects...``[INFO]                                     ``[INFO] ------------------------------------------------------------------------``[INFO] Building HelloJUnit5 1.0.2``[INFO] ------------------------------------------------------------------------``[INFO] ``[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ HelloJUnit5 ---``[INFO] Deleting /Users/sperry/home/development/projects/learn/HelloJUnit5/target``[INFO] ``[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/main/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:compile (default-compile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/classes``[INFO] ``[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ HelloJUnit5 ---``[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.``[INFO] skip non existing resourceDirectory /Users/sperry/home/development/projects/learn/HelloJUnit5/src/test/resources``[INFO] ``[INFO] --- maven-compiler-plugin:3.6.1:testCompile (default-testCompile) @ HelloJUnit5 ---``[INFO] Changes detected - recompiling the module!``[INFO] Compiling 2 source files to /Users/sperry/home/development/projects/learn/HelloJUnit5/target/test-classes``[INFO] ``[INFO] --- maven-surefire-plugin:2.19:test (default-test) @ HelloJUnit5 ---` `-------------------------------------------------------`` ``T E S T S``-------------------------------------------------------``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Running com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Nov 28, 2017 6:04:49 PM org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder buildRunner``WARNING: Ignoring test class using JUnitPlatform runner: com.makotojava.learn.hellojunit5.solution.JUnit5AppTest``Tests run: 1, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 0.038 sec - in com.makotojava.learn.hellojunit5.solution.JUnit5AppTest` `Results :` `Tests run: 1, Failures: 0, Errors: 0, Skipped: 1` `[INFO] ------------------------------------------------------------------------``[INFO] BUILD SUCCESS``[INFO] ------------------------------------------------------------------------``[INFO] Total time: 3.741 s``[INFO] Finished at: 2017-11-28T18:04:50-06:00``[INFO] Final Memory: 21M/255M``[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h5 id="Running-unit-tests-with-Gradle"><a href="#Running-unit-tests-with-Gradle" class="headerlink" title="Running unit tests with Gradle"></a>Running unit tests with Gradle</h5><p>Open a terminal window (Mac) or command prompt (Windows), navigate to the directory where you cloned the HelloJUnit5 application, and enter this command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle clean test</span><br></pre></td></tr></table></figure>

<p>The output should look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gradle clean test``Starting a Gradle Daemon (subsequent builds will be faster)``:clean``:compileJava``:processResources NO-SOURCE``:classes``:compileTestJava``:processTestResources NO-SOURCE``:testClasses``:junitPlatformTest``ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.` `Test run finished after 10097 ms``[     7 containers found   ]``[     5 containers skipped  ]``[     2 containers started  ]``[     0 containers aborted  ]``[     2 containers successful ]``[     0 containers failed   ]``[    10 tests found      ]``[    10 tests skipped     ]``[     0 tests started     ]``[     0 tests aborted     ]``[     0 tests successful   ]``[     0 tests failed     ]` `:test SKIPPED` `BUILD SUCCESSFUL` `Total time: 21.014 secs</span><br></pre></td></tr></table></figure>

<h4 id="测试练习"><a href="#测试练习" class="headerlink" title="测试练习"></a>测试练习</h4><p>现在您已了解 JUnit Jupiter，查看了代码示例，并观看了视频（希望您已跟随视频进行操作）。非常棒，但没有什么比动手编写代码更有用了！在第 1 部分的最后一节，您将完成以下任务：</p>
<ul>
<li>编写 JUnit Jupiter API 单元测试。</li>
<li>运行单元测试。</li>
<li>实现 <code>App</code> 类，让您的单元测试通过检查。</li>
</ul>
<p>采用真正的测试驱动开发 (TDD) 方式，首先编写单元测试，运行它们，并会观察到它们全部失败了。然后编写实现，直到单元测试通过，这时您就大功告成了。</p>
<p>注意，<code>JUnit5AppTest</code> 类仅提供了两个现成的测试方法。首次运行该类时，二者都是 “绿色” 的。要完成这些练习，您需要添加剩余的代码，包括用于告诉 JUnit 运行哪些测试方法的注解。记住，如果没有正确配备一个类或方法，JUnit 将跳过它。</p>
<p>如果遇到困难，请查阅 <code>com.makotojava.learn.hellojunit5.solution</code> 包来寻找解决方案。</p>
<p>1</p>
<h5 id="编写-JUnit-Jupiter-单元测试"><a href="#编写-JUnit-Jupiter-单元测试" class="headerlink" title="编写 JUnit Jupiter 单元测试"></a>编写 JUnit Jupiter 单元测试</h5><p>首先从 <code>JUnit5AppTest.java</code> 开始。打开此文件并按照 Javadoc 注解中的指示操作。</p>
<p><strong>提示</strong>：使用 Eclipse 中的 Javadoc 视图读取测试指令。要打开 Javadoc 视图，可以转到 <strong>Window &gt; Show View &gt; Javadoc</strong>。您应该看到 Javadoc 视图。根据您设置工作区的方式，该窗口可能出现在任意多个位置。在我的工作区中，该窗口与图 3 中的屏幕截图类似，出现在 IDE 右侧的编辑器窗口下方：</p>
<h5 id="图-3-Javadoc-视图"><a href="#图-3-Javadoc-视图" class="headerlink" title="图 3. Javadoc 视图"></a>图 3. Javadoc 视图</h5><p><img src="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/Figure-3.png" alt="Javadoc 视图的屏幕截图。"></p>
<p>编辑器窗口中显示了具有原始 HTML 标记的 Javadoc 注解，但在 Javadoc 窗口中，已将其格式化，因此更易于阅读。</p>
<h5 id="在-Eclipse-中运行单元测试"><a href="#在-Eclipse-中运行单元测试" class="headerlink" title="在 Eclipse 中运行单元测试"></a>在 Eclipse 中运行单元测试</h5><p>如果您像我一样，您会使用 IDE 执行以下工作：</p>
<ul>
<li>编写单元测试。</li>
<li>编写单元测试所测试的实现内容。</li>
<li>运行初始测试（使用 IDE 的原生 JUnit 支持）。</li>
</ul>
<p>JUnit 5 提供了一个名为 <code>JUnitPlatform</code> 的类，它允许您在 Eclipse 中运行 JUnit 5 测试。</p>
<p><strong>Eclipse 中的 JUnit 5</strong>：Eclipse 目前能理解 JUnit 4，但尚未提供对 JUnit 5 的原生支持。幸运的是，这对大部分单元测试而言都不是什么大问题！除非您需要使用 JUnit 4 一些更复杂的特性，否则要编写单元测试来全面检查您的应用程序代码，<code>JUnitPlatform</code> 类就足够了。</p>
<p>要在 Eclipse 中运行测试，需要确保您的计算机上拥有示例应用程序。为此，最轻松的方法是从 GitHub 克隆 HelloJUnit5 应用程序，然后将它导入 Eclipse 中。（因为本教程的视频展示了如何这么做，所以这里将跳过细节，仅提供操作步骤。）</p>
<p>确保您克隆了 GitHub 存储库，然后将代码导入 Eclipse 中作为新的 Maven 项目。</p>
<p>将该项目导入 Eclipse 中后，打开 <strong>Project Explorer</strong> 视图并展开 <code>src/main/test</code> 节点，直至看到 <code>JUnit5AppTest</code>。要以 JUnit 测试的形式运行它，可以右键单击它，选择 <strong>Run As &gt; JUnit Test</strong>。</p>
<h5 id="实现-App-类，直到单元测试通过检查"><a href="#实现-App-类，直到单元测试通过检查" class="headerlink" title="实现 App 类，直到单元测试通过检查"></a>实现 App 类，直到单元测试通过检查</h5><p><code>App</code> 的单一 <code>add()</code> 方法提供的功能很容易理解，而且在设计上非常简单。我不希望复杂应用程序的业务逻辑阻碍您对 JUnit Jupiter 的学习。</p>
<p>单元测试通过后，您就大功告成了！记住，如果遇到困难，可以在 <code>com.makotojava.learn.hellojunit5.solution</code> 包中查找解决方案。</p>
<h4 id="第-1-部分小结"><a href="#第-1-部分小结" class="headerlink" title="第 1 部分小结"></a>第 1 部分小结</h4><p>在 JUnit 5 教程的前半部分中，我介绍了 JUnit 5 的架构和组件，并详细介绍了 JUnit Jupiter API。我们逐个介绍了 JUnit 5 中最常用的注解、断言和前置条件，而且通过一个快速练习演示了如何在 Eclipse、Maven 和 Gradle 中运行测试。</p>
<p>在<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part2-vintage-jupiter-extension-model/index.html">第 2 部分</a>中，您将了解 JUnit 5 的一些高级特性：</p>
<ul>
<li>JUnit Jupiter 扩展模型</li>
<li>方法参数注入</li>
<li>参数化测试</li>
</ul>
<p>那么您接下来会怎么做？</p>
<h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3></div></div><a class="button-hover more" href="/2021/10/18/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/JavaAssist/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><p>Javassist是用来处理java字节码的类库。字节码保存在二进制文件中称为类文件。每个类文件夹包括一个java类或接口。</p>
<p>Javasssist.CtClass这个类是一个类文件的抽象表示。一个CtClass(compile-time class编译时类)对象处理一个类文件。下面是个简单的例子：</p>
<pre><code>ClassPool pool = ClassPool.getDefault();
CtClass cc = pool.get(&quot;test.Rectangle&quot;);
cc.setSuperclass(pool.get(&quot;test.Point&quot;));
cc.writeFile();
</code></pre>
</div></div><a class="button-hover more" href="/2021/10/18/JavaAssist/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/JAVA%20%E6%B3%9B%E5%9E%8B/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h2 id="JAVA-泛型"><a href="#JAVA-泛型" class="headerlink" title="JAVA 泛型"></a>JAVA 泛型</h2><p>一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。</p>
<p>因此，与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，<code>T</code> 就是类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericHolder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">this</span>.a = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Automobile&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;Automobile&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Automobile()); <span class="comment">// 此处有类型校验</span></span><br><span class="line">        Automobile a = h3.get();  <span class="comment">// 无需类型转换</span></span><br><span class="line">        <span class="comment">//- h3.set(&quot;Not an Automobile&quot;); // 报错</span></span><br><span class="line">        <span class="comment">//- h3.set(1);  // 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>GenericHolder</code> 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 <code>main()</code> 中那样使用。然后，你就只能在 <code>GenericHolder</code> 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 <code>get()</code> 取值时，直接就是正确的类型。</p>
<p>这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p>
<p>你可能注意到 <code>h3</code> 的定义非常繁复。在 <code>=</code> 左边有 <code>GenericHolder&lt;Automobile&gt;</code>, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Diamond.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bob</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diamond</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;Bob&gt; h3 = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        h3.set(<span class="keyword">new</span> Bob());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在 <code>h3</code> 的定义处，<code>=</code> 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。</p>
<h2 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h2><p>有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。</p>
<p>这个概念称为<em>元组</em>，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 <em>数据传输对象</em> 或 <em>信使</em> ）。</p>
<p>通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple2.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B a2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple2</span><span class="params">(A a, B b)</span> </span>&#123; a1 = a; a2 = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a1 + <span class="string">&quot;, &quot;</span> + a2; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + rep() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。</p>
<p>初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。<code>a1</code> 和 <code>a2</code> 应该声明为 <strong>private</strong>，然后提供 <code>getFirst()</code> 和 <code>getSecond()</code> 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 <code>a1</code> 和 <code>a2</code> 然后对它们执行任何操作，但无法对 <code>a1</code> 和 <code>a2</code> 重新赋值。例子中的 <code>final</code> 可以实现同样的效果，并且更为简洁明了。</p>
<p>另一种设计思路是允许元组的用户给 <code>a1</code> 和 <code>a2</code> 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 <code>Tuple2</code> 对象。</p>
<p>我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Tuple3.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C a3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple3</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">        a3 = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple4.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple3</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> D a4;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple4</span><span class="params">(A a, B b, C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c);</span><br><span class="line">        a4 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onjava/Tuple5.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple5</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Tuple4</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> E a5;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple5</span><span class="params">(A a, B b, C c, D d, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b, c, d);</span><br><span class="line">        a5 = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.rep() + <span class="string">&quot;, &quot;</span> + a5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示需要，再定义两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Amphibian.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/Vehicle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/TupleTest.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple2&lt;String, Integer&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 47 自动装箱为 Integer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple3&lt;Amphibian, String, Integer&gt; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple4&lt;Vehicle, Amphibian, String, Integer&gt; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple4&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Tuple5&lt;Vehicle, Amphibian, String, Integer, Double&gt; <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple5&lt;&gt;(<span class="keyword">new</span> Vehicle(), <span class="keyword">new</span> Amphibian(), <span class="string">&quot;hi&quot;</span>, <span class="number">47</span>, <span class="number">11.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tuple2&lt;String, Integer&gt; ttsi = f();</span><br><span class="line">        System.out.println(ttsi);</span><br><span class="line">        <span class="comment">// ttsi.a1 = &quot;there&quot;; // 编译错误，因为 final 不能重新赋值</span></span><br><span class="line">        System.out.println(g());</span><br><span class="line">        System.out.println(h());</span><br><span class="line">        System.out.println(k());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> (hi, 47)</span></span><br><span class="line"><span class="comment"> (Amphibian@1540e19d, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)</span></span><br><span class="line"><span class="comment"> (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。</p>
<p>通过 <code>ttsi.a1 = &quot;there&quot;</code> 语句的报错，我们可以看出，<strong>final</strong> 声明确实可以确保 <strong>public</strong> 字段在对象被构造出来之后就不能重新赋值了。</p>
<p>在上面的程序中，<code>new</code> 表达式有些啰嗦。本章稍后会介绍，如何利用 <em>泛型方法</em> 简化它们。</p>
<p>接下来我们看一个稍微复杂一点的例子：堆栈。在 <a target="_blank" rel="noopener" href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book/book/12-Collections.md">集合</a> 一章中，我们用 <code>LinkedList</code> 实现了 <code>onjava.Stack</code> 类。在那个例子中，<code>LinkedList</code> 本身已经具备了创建堆栈所需的方法。<code>Stack</code> 是通过两个泛型类 <code>Stack&lt;T&gt;</code> 和 <code>LinkedList&lt;T&gt;</code> 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p>
<p>这次我们不用 <code>LinkedList</code> 来实现自己的内部链式存储机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/LinkedStack.java</span></span><br><span class="line"><span class="comment">// 用链式结构实现的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node() &#123; item = <span class="keyword">null</span>; next = <span class="keyword">null</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;&gt;();  <span class="comment">// 栈顶</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; lss = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">&quot;Phasers on stun!&quot;</span>.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            lss.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = lss.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stun!</span><br><span class="line">on</span><br><span class="line">Phasers</span><br></pre></td></tr></table></figure>

<p>内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数。</p>
<p>这个例子使用了一个 <em>末端标识</em> (end sentinel) 来判断栈何时为空。这个末端标识是在构造 <code>LinkedStack</code> 时创建的。然后，每次调用 <code>push()</code> 就会创建一个 <code>Node&lt;T&gt;</code> 对象，并将其链接到前一个 <code>Node&lt;T&gt;</code> 对象。当你调用 <code>pop()</code> 方法时，总是返回 <code>top.item</code>，然后丢弃当前 <code>top</code> 所指向的 <code>Node&lt;T&gt;</code>，并将 <code>top</code> 指向下一个 <code>Node&lt;T&gt;</code>，除非到达末端标识，这时就不能再移动 <code>top</code> 了。如果已经到达末端，程序还继续调用 <code>pop()</code> 方法，它只能得到 <code>null</code>，说明栈已经空了。</p>
<h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/RandomList.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(rand.nextInt(size()));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs = <span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        Arrays.stream(<span class="string">&quot;The quick brown fox jumped over the lazy brown dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)).forEach(rs::add);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">11</span>).forEach(i -&gt; </span><br><span class="line">            System.out.print(rs.select() + <span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brown over fox quick quick dog brown The brown lazy brown</span><br></pre></td></tr></table></figure>

<p><code>RandomList</code> 继承了 <code>ArrayList</code> 的所有方法。本例中只添加了 <code>select()</code> 这个方法。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口。例如 <em>生成器</em>，这是一种专门负责创建对象的类。实际上，这是 <em>工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。</p>
<p>一般而言，一个生成器只定义一个方法，用于创建对象。例如 <code>java.util.function</code> 类库中的 <code>Supplier</code> 就是一个生成器，调用其 <code>get()</code> 获取对象。<code>get()</code> 是泛型方法，返回值为类型参数 <code>T</code>。</p>
<p>为了演示 <code>Supplier</code>，我们需要定义几个类。下面是个咖啡相关的继承体系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/Coffee.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName() + <span class="string">&quot; &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Latte.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Mocha.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Cappuccino.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Americano.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// generics/coffee/Breve.java</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Breve</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以编写一个类，实现 <code>Supplier&lt;Coffee&gt;</code> 接口，它能够随机生成不同类型的 <code>Coffee</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/coffee/CoffeeSupplier.java</span></span><br><span class="line"><span class="comment">// &#123;java generics.coffee.CoffeeSupplier&#125;</span></span><br><span class="line"><span class="keyword">package</span> generics.coffee;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeSupplier</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Coffee</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] types = &#123; Latte.class, Mocha.class, </span><br><span class="line">        Cappuccino.class, Americano.class, Breve.class &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// For iteration:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeSupplier</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123; size = sz; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = size;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count &gt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeSupplier.<span class="keyword">this</span>.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> CoffeeSupplier())</span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br><span class="line">        <span class="keyword">for</span> (Coffee c : <span class="keyword">new</span> CoffeeSupplier(<span class="number">5</span>)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Americano 0</span><br><span class="line">Latte 1</span><br><span class="line">Americano 2</span><br><span class="line">Mocha 3</span><br><span class="line">Mocha 4</span><br><span class="line">Breve 5</span><br><span class="line">Americano 6</span><br><span class="line">Latte 7</span><br><span class="line">Cappuccino 8</span><br><span class="line">Cappuccino 9</span><br></pre></td></tr></table></figure>

<p>参数化的 <code>Supplier</code> 接口确保 <code>get()</code> 返回值是参数的类型。<code>CoffeeSupplier</code> 同时还实现了 <code>Iterable</code> 接口，所以能用于 <em>for-in</em> 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。</p>
<p>下面是另一个实现 <code>Supplier&lt;T&gt;</code> 接口的例子，它负责生成 Fibonacci 数列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/Fibonacci.java</span></span><br><span class="line"><span class="comment">// Generate a Fibonacci sequence</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> Fibonacci())</span><br><span class="line">              .limit(<span class="number">18</span>)</span><br><span class="line">              .map(n -&gt; n + <span class="string">&quot; &quot;</span>)</span><br><span class="line">              .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584</span><br></pre></td></tr></table></figure>

<p>虽然我们在 <code>Fibonacci</code> 类的里里外外使用的都是 <code>int</code> 类型，但是其参数类型却是 <code>Integer</code>。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 <code>Fibonacci</code> 类对 <code>int</code> 的使用，我们已经看到了这种效果。</p>
<p>如果还想更进一步，编写一个实现了 <code>Iterable</code> 的 <code>Fibnoacci</code> 生成器。我们的一个选择是重写这个类，令其实现 <code>Iterable</code> 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 <em>适配器</em> (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。</p>
<p>有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/IterableFibonacci.java</span></span><br><span class="line"><span class="comment">// Adapt the Fibonacci class to make it Iterable</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableFibonacci</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IterableFibonacci</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; n = count; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> IterableFibonacci.<span class="keyword">this</span>.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="keyword">new</span> IterableFibonacci(<span class="number">18</span>))</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584</span><br></pre></td></tr></table></figure>

<p>在 <em>for-in</em> 语句中使用 <code>IterableFibonacci</code>，必须在构造函数中提供一个边界值，这样 <code>hasNext()</code> 才知道何时返回 <strong>false</strong>，结束循环。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。</p>
<p>泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。</p>
<p>如果方法是 <strong>static</strong> 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。</p>
<p>要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericMethods.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethods gm = <span class="keyword">new</span> GenericMethods();</span><br><span class="line">        gm.f(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">        gm.f(<span class="number">1.0F</span>);</span><br><span class="line">        gm.f(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.String</span></span><br><span class="line"><span class="comment">java.lang.Integer</span></span><br><span class="line"><span class="comment">java.lang.Double</span></span><br><span class="line"><span class="comment">java.lang.Float</span></span><br><span class="line"><span class="comment">java.lang.Character</span></span><br><span class="line"><span class="comment">GenericMethods</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>尽管可以同时对类及其方法进行参数化，但这里未将 <strong>GenericMethods</strong> 类参数化。只有方法 <code>f()</code> 具有类型参数，该参数由方法返回类型之前的参数列表指示。</p>
<p>对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 <em>类型参数推断</em>。因此，对 <code>f()</code> 的调用看起来像普通的方法调用，并且 <code>f()</code> 看起来像被重载了无数次一样。它甚至会接受 <strong>GenericMethods</strong> 类型的参数。</p>
<p>如果使用基本类型调用 <code>f()</code> ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。</p>
<h3 id="变长参数和泛型方法"><a href="#变长参数和泛型方法" class="headerlink" title="变长参数和泛型方法"></a>变长参数和泛型方法</h3><p>泛型方法和变长参数列表可以很好地共存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/GenericVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(</span><br><span class="line">                <span class="string">&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;</span>.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A]</span></span><br><span class="line"><span class="comment">[A, B, C]</span></span><br><span class="line"><span class="comment">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,</span></span><br><span class="line"><span class="comment">S, T, U, V, W, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>此处显示的 <code>makeList()</code> 方法产生的功能与标准库的 <code>java.util.Arrays.asList()</code> 方法相同。</p>
<p><code>@SafeVarargs</code> 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。</p>
<h3 id="一个泛型的-Supplier"><a href="#一个泛型的-Supplier" class="headerlink" title="一个泛型的 Supplier"></a>一个泛型的 Supplier</h3><p>这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/BasicSupplier.java</span></span><br><span class="line"><span class="comment">// Supplier from a class with a no-arg constructor</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplier</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicSupplier</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Assumes type is a public class:</span></span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Produce a default Supplier from a type token:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Supplier&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicSupplier&lt;&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此类提供了产生以下对象的基本实现：</p>
<ol>
<li>是 <strong>public</strong> 的。 因为 <strong>BasicSupplier</strong> 在单独的包中，所以相关的类必须具有 <strong>public</strong> 权限，而不仅仅是包级访问权限。</li>
<li>具有无参构造方法。要创建一个这样的 <strong>BasicSupplier</strong> 对象，请调用 <code>create()</code> 方法，并将要生成类型的类型令牌传递给它。通用的 <code>create()</code> 方法提供了 <code>BasicSupplier.create(MyType.class)</code> 这种较简洁的语法来代替较笨拙的 <code>new BasicSupplier &lt;MyType&gt;(MyType.class)</code>。</li>
</ol>
<p>例如，这是一个具有无参构造方法的简单类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics/CountedObject.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CountedObject &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CountedObject</strong> 类可以跟踪自身创建了多少个实例，并通过 <code>toString()</code> 报告这些实例的数量。 <strong>BasicSupplier</strong> 可以轻松地为 <strong>CountedObject</strong> 创建 <strong>Supplier</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// generics/BasicSupplierDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.BasicSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(</span><br><span class="line">                BasicSupplier.create(CountedObject.class))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">CountedObject 0</span></span><br><span class="line"><span class="comment">CountedObject 1</span></span><br><span class="line"><span class="comment">CountedObject 2</span></span><br><span class="line"><span class="comment">CountedObject 3</span></span><br><span class="line"><span class="comment">CountedObject 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>泛型方法减少了产生 <strong>Supplier</strong> 对象所需的代码量。 Java 泛型强制传递 <strong>Class</strong> 对象，以便在 <code>create()</code> 方法中将其用于类型推断。</p>
</div></div><a class="button-hover more" href="/2021/10/18/JAVA%20%E6%B3%9B%E5%9E%8B/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/CGLIB/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h1 id="什么是CGLIB"><a href="#什么是CGLIB" class="headerlink" title="什么是CGLIB"></a>什么是CGLIB</h1><p>CGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a></p>
<h1 id="为什么使用CGLIB"><a href="#为什么使用CGLIB" class="headerlink" title="为什么使用CGLIB"></a>为什么使用CGLIB</h1><p>CGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。关于Java动态代理，可以参者这里<a target="_blank" rel="noopener" href="http://blog.csdn.net/danchu/article/details/70146985">Java动态代理分析</a></p>
<h1 id="CGLIB组成结构"><a href="#CGLIB组成结构" class="headerlink" title="CGLIB组成结构"></a>CGLIB组成结构</h1><p><img src="http://jnb.ociweb.com/jnb/jnbNov2005_files/jnbNov2005-1.PNG" alt="image"></p>
<p>CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类。除了CGLIB库外，脚本语言（如Groovy何BeanShell）也使用ASM生成字节码。ASM使用类似SAX的解析器来实现高性能。我们不鼓励直接使用ASM，因为它需要对Java字节码的格式足够的了解</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>说了这么多，可能大家还是不知道CGLIB是干什么用的。下面我们将使用一个简单的例子来演示如何使用CGLIB对一个方法进行拦截。<br>首先，我们需要在工程的POM文件中引入cglib的dependency，这里我们使用的是2.2.2版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;12345</span><br></pre></td></tr></table></figure>

<p>依赖包下载后，我们就可以干活了，按照国际惯例，写个hello world</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before method run...&quot;</span>);</span><br><span class="line">                Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;after method run...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        SampleClass sample = (SampleClass) enhancer.create();</span><br><span class="line">        sample.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在mian函数中，我们通过一个Enhancer和一个MethodInterceptor来实现对方法的拦截，运行程序后输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method run...</span><br><span class="line">hello world</span><br><span class="line">after method run...123</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们引入了Enhancer和MethodInterceptor，可能有些读者还不太了解。别急，我们后面将会一一进行介绍。就目前而言，一个使用CGLIB的小demo就完成了</p>
<h1 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h1><p>目前网络上对CGLIB的介绍资料比较少，造成对cglib的学习困难。这里我将对cglib中的常用类进行一个介绍。为了避免解释的不清楚，我将为每个类都配有一个demo，用来做进一步的说明。首先就从Enhancer开始吧。</p>
<h2 id="Enhancer"><a href="#Enhancer" class="headerlink" title="Enhancer"></a>Enhancer</h2><p>Enhancer可能是CGLIB中最常用的一个类，和Java1.3动态代理中引入的Proxy类差不多(如果对Proxy不懂，可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/danchu/article/details/70146985">这里</a>)。和Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。基于同样的道理，Enhancer也不能对fianl类进行代理操作。这也是Hibernate为什么不能持久化final class的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们将以这个类作为主要的测试类，来测试调用各种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFixedValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello cglib&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    System.out.println(proxy.test(<span class="keyword">null</span>)); <span class="comment">//拦截test，输出Hello cglib</span></span><br><span class="line">    System.out.println(proxy.toString()); </span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    System.out.println(proxy.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello cglib</span><br><span class="line">Hello cglib</span><br><span class="line">class com.zeus.cglib.SampleClass$$EnhancerByCGLIB$$e3ea9b7</span><br><span class="line"></span><br><span class="line">java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number</span><br><span class="line"></span><br><span class="line">    at com.zeus.cglib.SampleClass$$EnhancerByCGLIB$$e3ea9b7.hashCode(&lt;generated&gt;)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>上述代码中，FixedValue用来对所有拦截的方法返回相同的值，从输出我们可以看出来，Enhancer对非final方法test()、toString()、hashCode()进行了拦截，没有对getClass进行拦截。由于hashCode()方法需要返回一个Number，但是我们返回的是一个String，这解释了上面的程序中为什么会抛出异常。</p>
<p>Enhancer.setSuperclass用来设置父类型，从toString方法可以看出，使用CGLIB生成的类为被代理类的一个子类，形如：SampleClass$$EnhancerByCGLIB$$e3ea9b7</p>
<p>Enhancer.create(Object…)方法是用来创建增强对象的，其提供了很多不同参数的方法用来匹配被增强类的不同构造方法。（虽然类的构造放法只是Java字节码层面的函数，但是Enhancer却不能对其进行操作。Enhancer同样不能操作static或者final类）。我们也可以先使用Enhancer.createClass()来创建字节码(.class)，然后用字节码动态的生成增强后的对象。</p>
<p>可以使用一个InvocationHandler(如果对InvocationHandler不懂，可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/danchu/article/details/70146985">这里</a>)作为回调，使用invoke方法来替换直接访问类的方法，但是你必须注意死循环。因为invoke中调用的任何原代理类方法，均会重新代理到invoke方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInvocationHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;hello cglib&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Do not know what to do&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;hello cglib&quot;</span>, proxy.test(<span class="keyword">null</span>));</span><br><span class="line">    Assert.assertNotEquals(<span class="string">&quot;Hello cglib&quot;</span>, proxy.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免这种死循环，我们可以使用MethodInterceptor，MethodInterceptor的例子在前面的hello world中已经介绍过了，这里就不浪费时间了。</p>
<p>有些时候我们可能只想对特定的方法进行拦截，对其他的方法直接放行，不做任何操作，使用Enhancer处理这种需求同样很简单,只需要一个CallbackFilter即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallbackFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    CallbackHelper callbackHelper = <span class="keyword">new</span> CallbackHelper(SampleClass.class, <span class="keyword">new</span> Class[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">getCallback</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.getDeclaringClass() != Object.class &amp;&amp; method.getReturnType() == String.class)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Hello cglib&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> NoOp.INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallbackFilter(callbackHelper);</span><br><span class="line">    enhancer.setCallbacks(callbackHelper.getCallbacks());</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, proxy.test(<span class="keyword">null</span>));</span><br><span class="line">    Assert.assertNotEquals(<span class="string">&quot;Hello cglib&quot;</span>,proxy.toString());</span><br><span class="line">    System.out.println(proxy.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ImmutableBean"><a href="#ImmutableBean" class="headerlink" title="ImmutableBean"></a>ImmutableBean</h2><p>通过名字就可以知道，不可变的Bean。ImmutableBean允许创建一个原来对象的包装类，这个包装类是不可变的，任何改变底层对象的包装类操作都会抛出IllegalStateException。但是我们可以通过直接操作底层对象来改变包装类对象。这有点类似于Guava中的不可变视图</p>
<p>为了对ImmutableBean进行测试，这里需要再引入一个bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleBean</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写测试类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected = IllegalStateException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImmutableBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    SampleBean bean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    SampleBean immutableBean = (SampleBean) ImmutableBean.create(bean); <span class="comment">//创建不可变类</span></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello world&quot;</span>,immutableBean.getValue()); </span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world, again&quot;</span>); <span class="comment">//可以通过底层对象来进行修改</span></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello world, again&quot;</span>, immutableBean.getValue());</span><br><span class="line">    immutableBean.setValue(<span class="string">&quot;Hello cglib&quot;</span>); <span class="comment">//直接修改将throw exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bean-generator"><a href="#Bean-generator" class="headerlink" title="Bean generator"></a>Bean generator</h2><p>cglib提供的一个操作bean的工具，使用它能够在运行时动态的创建一个bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanGenerator</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanGenerator beanGenerator = <span class="keyword">new</span> BeanGenerator();</span><br><span class="line">    beanGenerator.addProperty(<span class="string">&quot;value&quot;</span>,String.class);</span><br><span class="line">    Object myBean = beanGenerator.create();</span><br><span class="line">    Method setter = myBean.getClass().getMethod(<span class="string">&quot;setValue&quot;</span>,String.class);</span><br><span class="line">    setter.invoke(myBean,<span class="string">&quot;Hello cglib&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Method getter = myBean.getClass().getMethod(<span class="string">&quot;getValue&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Hello cglib&quot;</span>,getter.invoke(myBean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用cglib动态的创建了一个和SampleBean相同的Bean对象，包含一个属性value以及getter、setter方法</p>
<h2 id="Bean-Copier"><a href="#Bean-Copier" class="headerlink" title="Bean Copier"></a>Bean Copier</h2><p>cglib提供的能够从一个bean复制到另一个bean中，而且其还提供了一个转换器，用来在转换的时候对bean的属性进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSampleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanCopier</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanCopier copier = BeanCopier.create(SampleBean.class, OtherSampleBean.class, <span class="keyword">false</span>);<span class="comment">//设置为true，则使用converter</span></span><br><span class="line">    SampleBean myBean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    myBean.setValue(<span class="string">&quot;Hello cglib&quot;</span>);</span><br><span class="line">    OtherSampleBean otherBean = <span class="keyword">new</span> OtherSampleBean();</span><br><span class="line">    copier.copy(myBean, otherBean, <span class="keyword">null</span>); <span class="comment">//设置为true，则传入converter指明怎么进行转换</span></span><br><span class="line">   assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, otherBean.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BulkBean"><a href="#BulkBean" class="headerlink" title="BulkBean"></a>BulkBean</h2><p>相比于BeanCopier，BulkBean将copy的动作拆分为getPropertyValues和setPropertyValues两个方法，允许自定义处理属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBulkBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BulkBean bulkBean = BulkBean.create(SampleBean.class,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">&quot;getValue&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">&quot;setValue&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">    SampleBean bean = <span class="keyword">new</span> SampleBean();</span><br><span class="line">    bean.setValue(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    Object[] propertyValues = bulkBean.getPropertyValues(bean);</span><br><span class="line">    assertEquals(<span class="number">1</span>, bulkBean.getPropertyValues(bean).length);</span><br><span class="line">    assertEquals(<span class="string">&quot;Hello world&quot;</span>, bulkBean.getPropertyValues(bean)[<span class="number">0</span>]);</span><br><span class="line">    bulkBean.setPropertyValues(bean,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;Hello cglib&quot;</span>&#125;);</span><br><span class="line">    assertEquals(<span class="string">&quot;Hello cglib&quot;</span>, bean.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注意：<br>\1. 避免每次进行BulkBean.create创建对象，一般将其声明为static的<br>\2. 应用场景：针对特定属性的get,set操作，一般适用通过xml配置注入和注出的属性，运行时才确定处理的Source,Target类，只需要关注属性名即可。</p>
<h2 id="BeanMap"><a href="#BeanMap" class="headerlink" title="BeanMap"></a>BeanMap</h2><p>BeanMap类实现了Java Map，将一个bean对象中的所有属性转换为一个String-to-Obejct的Java Map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    BeanGenerator generator = <span class="keyword">new</span> BeanGenerator();</span><br><span class="line">    generator.addProperty(<span class="string">&quot;username&quot;</span>,String.class);</span><br><span class="line">    generator.addProperty(<span class="string">&quot;password&quot;</span>,String.class);</span><br><span class="line">    Object bean = generator.create();</span><br><span class="line">    Method setUserName = bean.getClass().getMethod(<span class="string">&quot;setUsername&quot;</span>, String.class);</span><br><span class="line">    Method setPassword = bean.getClass().getMethod(<span class="string">&quot;setPassword&quot;</span>, String.class);</span><br><span class="line">    setUserName.invoke(bean, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    setPassword.invoke(bean,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    BeanMap map = BeanMap.create(bean);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;admin&quot;</span>, map.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;password&quot;</span>, map.get(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用BeanGenerator生成了一个含有两个属性的Java Bean，对其进行赋值操作后，生成了一个BeanMap对象，通过获取值来进行验证</p>
<h2 id="keyFactory"><a href="#keyFactory" class="headerlink" title="keyFactory"></a>keyFactory</h2><p>keyFactory类用来动态生成接口的实例，接口需要只包含一个newInstance方法，返回一个Object。keyFactory为构造出来的实例动态生成了Object.equals和Object.hashCode方法，能够确保相同的参数构造出的实例为单例的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SampleKeyFactory &#123;</span><br><span class="line">    Object newInstance(String first, int second);</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure>

<p>我们首先构造一个满足条件的接口，然后进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testKeyFactory() throws Exception&#123;</span><br><span class="line">    SampleKeyFactory keyFactory = (SampleKeyFactory) KeyFactory.create(SampleKeyFactory.class);</span><br><span class="line">    Object key = keyFactory.newInstance(&quot;foo&quot;, 42);</span><br><span class="line">    Object key1 = keyFactory.newInstance(&quot;foo&quot;, 42);</span><br><span class="line">    Assert.assertEquals(key,key1);//测试参数相同，结果是否相等</span><br><span class="line">&#125;1234567</span><br></pre></td></tr></table></figure>

<h2 id="Mixin-混合"><a href="#Mixin-混合" class="headerlink" title="Mixin(混合)"></a>Mixin(混合)</h2><p>Mixin能够让我们将多个对象整合到一个对象中去，前提是这些对象必须是接口的实现。可能这样说比较晦涩，以代码为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class MixinInterfaceTest &#123;</span><br><span class="line">    interface Interface1&#123;</span><br><span class="line">        String first();</span><br><span class="line">    &#125;</span><br><span class="line">    interface Interface2&#123;</span><br><span class="line">        String second();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Class1 implements Interface1&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String first() &#123;</span><br><span class="line">            return &quot;first&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Class2 implements Interface2&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String second() &#123;</span><br><span class="line">            return &quot;second&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface MixinInterface extends Interface1, Interface2&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMixin() throws Exception&#123;</span><br><span class="line">        Mixin mixin = Mixin.create(new Class[]&#123;Interface1.class, Interface2.class,</span><br><span class="line">                        MixinInterface.class&#125;, new Object[]&#123;new Class1(),new Class2()&#125;);</span><br><span class="line">        MixinInterface mixinDelegate = (MixinInterface) mixin;</span><br><span class="line">        assertEquals(&quot;first&quot;, mixinDelegate.first());</span><br><span class="line">        assertEquals(&quot;second&quot;, mixinDelegate.second());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011121314151617181920212223242526272829303132333435</span><br></pre></td></tr></table></figure>

<p>Mixin类比较尴尬，因为他要求Minix的类（例如MixinInterface）实现一些接口。既然被Minix的类已经实现了相应的接口，那么我就直接可以通过纯Java的方式实现，没有必要使用Minix类。</p>
<h2 id="String-switcher"><a href="#String-switcher" class="headerlink" title="String switcher"></a>String switcher</h2><p>用来模拟一个String到int类型的Map类型。如果在Java7以后的版本中，类似一个switch语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testStringSwitcher() throws Exception&#123;</span><br><span class="line">    String[] strings = new String[]&#123;&quot;one&quot;, &quot;two&quot;&#125;;</span><br><span class="line">    int[] values = new int[]&#123;10,20&#125;;</span><br><span class="line">    StringSwitcher stringSwitcher = StringSwitcher.create(strings,values,true);</span><br><span class="line">    assertEquals(10, stringSwitcher.intValue(&quot;one&quot;));</span><br><span class="line">    assertEquals(20, stringSwitcher.intValue(&quot;two&quot;));</span><br><span class="line">    assertEquals(-1, stringSwitcher.intValue(&quot;three&quot;));</span><br><span class="line">&#125;123456789</span><br></pre></td></tr></table></figure>

<h2 id="Interface-Maker"><a href="#Interface-Maker" class="headerlink" title="Interface Maker"></a>Interface Maker</h2><p>正如名字所言，Interface Maker用来创建一个新的Interface</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testInterfaceMarker() throws Exception&#123;</span><br><span class="line">    Signature signature = new Signature(&quot;foo&quot;, Type.DOUBLE_TYPE, new Type[]&#123;Type.INT_TYPE&#125;);</span><br><span class="line">    InterfaceMaker interfaceMaker = new InterfaceMaker();</span><br><span class="line">    interfaceMaker.add(signature, new Type[0]);</span><br><span class="line">    Class iface = interfaceMaker.create();</span><br><span class="line">    assertEquals(1, iface.getMethods().length);</span><br><span class="line">    assertEquals(&quot;foo&quot;, iface.getMethods()[0].getName());</span><br><span class="line">    assertEquals(double.class, iface.getMethods()[0].getReturnType());</span><br><span class="line">&#125;12345678910</span><br></pre></td></tr></table></figure>

<p>上述的Interface Maker创建的接口中只含有一个方法，签名为double foo(int)。Interface Maker与上面介绍的其他类不同，它依赖ASM中的Type类型。由于接口仅仅只用做在编译时期进行类型检查，因此在一个运行的应用中动态的创建接口没有什么作用。但是InterfaceMaker可以用来自动生成代码，为以后的开发做准备。</p>
<h2 id="Method-delegate"><a href="#Method-delegate" class="headerlink" title="Method delegate"></a>Method delegate</h2><p>MethodDelegate主要用来对方法进行代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface BeanDelegate&#123;</span><br><span class="line">    String getValueFromDelegate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testMethodDelegate()  throws Exception&#123;</span><br><span class="line">    SampleBean bean = new SampleBean();</span><br><span class="line">    bean.setValue(&quot;Hello cglib&quot;);</span><br><span class="line">    BeanDelegate delegate = (BeanDelegate) MethodDelegate.create(bean,&quot;getValue&quot;, BeanDelegate.class);</span><br><span class="line">    assertEquals(&quot;Hello cglib&quot;, delegate.getValueFromDelegate());</span><br><span class="line">&#125;1234567891011</span><br></pre></td></tr></table></figure>

<p>关于Method.create的参数说明：<br>\1. 第二个参数为即将被代理的方法<br>\2. 第一个参数必须是一个无参数构造的bean。因此MethodDelegate.create并不是你想象的那么有用<br>\3. 第三个参数为只含有一个方法的接口。当这个接口中的方法被调用的时候，将会调用第一个参数所指向bean的第二个参数方法</p>
<p>缺点：<br>\1. 为每一个代理类创建了一个新的类，这样可能会占用大量的永久代堆内存<br>\2. 你不能代理需要参数的方法<br>\3. 如果你定义的接口中的方法需要参数，那么代理将不会工作，并且也不会抛出异常；如果你的接口中方法需要其他的返回类型，那么将抛出IllegalArgumentException</p>
<h2 id="MulticastDelegate"><a href="#MulticastDelegate" class="headerlink" title="MulticastDelegate"></a>MulticastDelegate</h2><ol>
<li>多重代理和方法代理差不多，都是将代理类方法的调用委托给被代理类。使用前提是需要一个接口，以及一个类实现了该接口</li>
<li>通过这种interface的继承关系，我们能够将接口上方法的调用分散给各个实现类上面去。</li>
<li>多重代理的缺点是接口只能含有一个方法，如果被代理的方法拥有返回值，那么调用代理类的返回值为最后一个添加的被代理类的方法返回值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface DelegatationProvider &#123;</span><br><span class="line">    void setValue(String value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleMulticastBean implements DelegatationProvider &#123;</span><br><span class="line">    private String value;</span><br><span class="line">    @Override</span><br><span class="line">    public void setValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testMulticastDelegate() throws Exception&#123;</span><br><span class="line">    MulticastDelegate multicastDelegate = MulticastDelegate.create(DelegatationProvider.class);</span><br><span class="line">    SimpleMulticastBean first = new SimpleMulticastBean();</span><br><span class="line">    SimpleMulticastBean second = new SimpleMulticastBean();</span><br><span class="line">    multicastDelegate = multicastDelegate.add(first);</span><br><span class="line">    multicastDelegate  = multicastDelegate.add(second);</span><br><span class="line"></span><br><span class="line">    DelegatationProvider provider = (DelegatationProvider) multicastDelegate;</span><br><span class="line">    provider.setValue(&quot;Hello world&quot;);</span><br><span class="line"></span><br><span class="line">    assertEquals(&quot;Hello world&quot;, first.getValue());</span><br><span class="line">    assertEquals(&quot;Hello world&quot;, second.getValue());</span><br><span class="line">&#125;123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure>

<h2 id="Constructor-delegate"><a href="#Constructor-delegate" class="headerlink" title="Constructor delegate"></a>Constructor delegate</h2><p>为了对构造函数进行代理，我们需要一个接口，这个接口只含有一个Object newInstance(…)方法，用来调用相应的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface SampleBeanConstructorDelegate&#123;</span><br><span class="line">    Object newInstance(String value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对构造函数进行代理</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testConstructorDelegate() throws Exception&#123;</span><br><span class="line">    SampleBeanConstructorDelegate constructorDelegate = (SampleBeanConstructorDelegate) ConstructorDelegate.create(</span><br><span class="line">            SampleBean.class, SampleBeanConstructorDelegate.class);</span><br><span class="line">    SampleBean bean = (SampleBean) constructorDelegate.newInstance(&quot;Hello world&quot;);</span><br><span class="line">    assertTrue(SampleBean.class.isAssignableFrom(bean.getClass()));</span><br><span class="line">    System.out.println(bean.getValue());</span><br><span class="line">&#125;12345678910111213141516</span><br></pre></td></tr></table></figure>

<h2 id="Parallel-Sorter-并行排序器"><a href="#Parallel-Sorter-并行排序器" class="headerlink" title="Parallel Sorter(并行排序器)"></a>Parallel Sorter(并行排序器)</h2><p>能够对多个数组同时进行排序，目前实现的算法有归并排序和快速排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testParallelSorter() throws Exception&#123;</span><br><span class="line">    Integer[][] value = &#123;</span><br><span class="line">            &#123;4, 3, 9, 0&#125;,</span><br><span class="line">            &#123;2, 1, 6, 0&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ParallelSorter.create(value).mergeSort(0);</span><br><span class="line">    for(Integer[] row : value)&#123;</span><br><span class="line">        int former = -1;</span><br><span class="line">        for(int val : row)&#123;</span><br><span class="line">            assertTrue(former &lt; val);</span><br><span class="line">            former = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;123456789101112131415</span><br></pre></td></tr></table></figure>

<h2 id="FastClass"><a href="#FastClass" class="headerlink" title="FastClass"></a>FastClass</h2><p>顾明思义，FastClass就是对Class对象进行特定的处理，比如通过数组保存method引用，因此FastClass引出了一个index下标的新概念，比如getIndex(String name, Class[] parameterTypes)就是以前的获取method的方法。通过数组存储method,constructor等class信息，从而将原先的反射调用，转化为class.index的直接调用，从而体现所谓的FastClass。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFastClass() throws Exception&#123;</span><br><span class="line">    FastClass fastClass = FastClass.create(SampleBean.class);</span><br><span class="line">    FastMethod fastMethod = fastClass.getMethod(&quot;getValue&quot;,new Class[0]);</span><br><span class="line">    SampleBean bean = new SampleBean();</span><br><span class="line">    bean.setValue(&quot;Hello world&quot;);</span><br><span class="line">    assertEquals(&quot;Hello world&quot;,fastMethod.invoke(bean, new Object[0]));</span><br><span class="line">&#125;12345678</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。</p>
<h1 id="CGLIB和Java动态代理的区别"><a href="#CGLIB和Java动态代理的区别" class="headerlink" title="CGLIB和Java动态代理的区别"></a>CGLIB和Java动态代理的区别</h1><ol>
<li>Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；</li>
<li>Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效</li>
<li>3.</li>
</ol>
<p>CGLIB相关的文章：<br>- <a target="_blank" rel="noopener" href="http://jnb.ociweb.com/jnb/jnbNov2005.html">http://jnb.ociweb.com/jnb/jnbNov2005.html</a><br>- <a target="_blank" rel="noopener" href="http://www.iteye.com/topic/799827">http://www.iteye.com/topic/799827</a><br>- <a target="_blank" rel="noopener" href="http://mydailyjava.blogspot.kr/2013/11/cglib-missing-manual.html">http://mydailyjava.blogspot.kr/2013/11/cglib-missing-manual.html</a></p>
</div></div><a class="button-hover more" href="/2021/10/18/CGLIB/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E7%B1%BB/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h1 id="内部类和嵌套类"><a href="#内部类和嵌套类" class="headerlink" title="内部类和嵌套类"></a>内部类和嵌套类</h1><h2 id="内部类方法和作用域"><a href="#内部类方法和作用域" class="headerlink" title="内部类方法和作用域"></a>内部类方法和作用域</h2><p>可以在一个方法里面或者在任意的作用域内定义内部类。</p>
<p>这么做有两个理由：</p>
<ol>
<li>如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。</li>
<li>你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</li>
</ol>
<p>在后面的例子中，先前的代码将被修改，以用来实现：</p>
<ol>
<li>一个定义在方法中的类。</li>
<li>一个定义在作用域内的类，此作用域在方法的内部。</li>
<li>一个实现了接口的匿名类。</li>
<li>一个匿名类，它扩展了没有默认构造器的类。</li>
<li>一个匿名类，它执行字段初始化。</li>
<li>一个匿名类，它通过实例初始化实现构造（匿名内部类不可能有构造器）。</li>
</ol>
<p>第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel5.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a method</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">          </span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 p = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PDestination</strong> 类是 <code>destination()</code> 方法的一部分，而不是 <strong>Parcel5</strong> 的一部分。所以，在 <code>destination()</code> 之外不能访问 <strong>PDestination</strong>，注意出现在 <strong>return</strong> 语句中的向上转型-返回的是 <strong>Destination</strong> 的引用，它是 <strong>PDestination</strong> 的基类。当然，在 <code>destination()</code> 中定义了内部类 <strong>PDestination</strong>，并不意味着一旦 <code>destination()</code> 方法执行完毕，<strong>PDestination</strong> 就不可用了。</p>
<p>第二个例子展示了如何在任意的作用域内嵌入一个内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel6.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a scope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span> </span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">&quot;slip&quot;</span>);</span><br><span class="line">            String s = ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Can&#x27;t use it here! Out of scope:</span></span><br><span class="line">        <span class="comment">//- TrackingSlip ts = new TrackingSlip(&quot;x&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span> </span>&#123; internalTracking(<span class="keyword">true</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel6 p = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TrackingSlip</strong> 类被嵌入在 <strong>if</strong> 语句的作用域内，这并不是说该类的创建是有条件的，<strong>它其实与别的类一起编译过了</strong>。然而，在定义 <strong>Trackingslip</strong> 的作用域之外，它是不可用的，除此之外，它与普通的类一样。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>下面的例子看起来有点奇怪：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel7.java</span></span><br><span class="line"><span class="comment">// Returning an instance of an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123; <span class="comment">// Insert class definition</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">          </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">        &#125;; <span class="comment">// Semicolon required</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7 p = <span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>contents()</code> 方法将返回值的生成与表示这个返回值的类的定义结合在一起！另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个 <strong>Contents</strong> 对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义。”</p>
<p>这种奇怪的语法指的是：“创建一个继承自 <strong>Contents</strong> 的匿名类的对象。”通过 <strong>new</strong> 表达式返回的引用被自动向上转型为对 <strong>Contents</strong> 的引用。上述匿名内部类的语法是下述形式的简化形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel7b.java</span></span><br><span class="line"><span class="comment">// Expanded version of Parcel7.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyContents();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7b p = <span class="keyword">new</span> Parcel7b();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个匿名内部类中，使用了默认的构造器来生成 <strong>Contents</strong>。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel8.java</span></span><br><span class="line"><span class="comment">// Calling the base-class constructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Base constructor call:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123; <span class="comment">// [1]</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// [2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel8 p = <span class="keyword">new</span> Parcel8();</span><br><span class="line">        Wrapping w = p.wrapping(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>[1] 将合适的参数传递给基类的构造器。</p>
</li>
<li><p>[2] 在匿名内部类末尾的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的地方使用的分号是一致的。</p>
<p>尽管 <strong>Wrapping</strong> 只是一个具有具体实现的普通类，但它还是被导出类当作公共“接口”来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Wrapping.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; i = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/AnonymousConstructor.java</span></span><br><span class="line"><span class="comment">// Creating a constructor for an anonymous inner class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    Base(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor, i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(i) &#123;</span><br><span class="line">            &#123; System.out.println(</span><br><span class="line">                    <span class="string">&quot;Inside instance initializer&quot;</span>); &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;In anonymous f()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = getBase(<span class="number">47</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor, i = 47</span><br><span class="line">Inside instance initializer</span><br><span class="line">In anonymous f()</span><br></pre></td></tr></table></figure>

<p>在此例中，不要求变量一定是 <strong>final</strong> 的。因为被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。</p>
<p>下例是带实例初始化的”parcel”形式。注意 <code>destination()</code> 的参数必须是 <strong>final</strong> 的，因为它们是在匿名类内部使用的（译者注：即使不加 <strong>final</strong>, Java 8 的编译器也会为我们自动加上 <strong>final</strong>，以保证数据的一致性）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel10.java</span></span><br><span class="line"><span class="comment">// Using &quot;instance initialization&quot; to perform</span></span><br><span class="line"><span class="comment">// construction on an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination</span></span><br><span class="line"><span class="function">    <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            <span class="comment">// Instance initialization for each object:</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">                    System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel10 p = <span class="keyword">new</span> Parcel10();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Over budget!</span><br></pre></td></tr></table></figure>

<p>在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是 <strong>if</strong> 语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制-你不能重载实例初始化方法，所以你仅有一个这样的构造器。</p>
<p>匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 <strong>static</strong>，这通常称为嵌套类。想要理解 <strong>static</strong> 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p>
<ol>
<li>要创建嵌套类的对象，并不需要其外部类的对象。</li>
<li>不能从嵌套类的对象中访问非静态的外部类对象。</li>
</ol>
<p>嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 <strong>static</strong> 数据和 <strong>static</strong> 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel11.java</span></span><br><span class="line"><span class="comment">// Nested classes (static inner classes)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel11</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ParcelDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        <span class="comment">// Nested classes can contain other static elements:</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelContents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Contents c = contents();</span><br><span class="line">        Destination d = destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3><p>嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 <strong>public</strong> 和 <strong>static</strong> 的。因为类是 <strong>static</strong> 的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现其外部接口，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/ClassInInterface.java</span></span><br><span class="line"><span class="comment">// &#123;java ClassInInterface$Test&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Howdy!</span><br></pre></td></tr></table></figure>

<p>如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。</p>
<p>我曾在本书中建议过，在每个类中都写一个 <code>main()</code> 方法，用来测试这个类。这样做有一个缺点，那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/TestBed.java</span></span><br><span class="line"><span class="comment">// Putting test code in a nested class</span></span><br><span class="line"><span class="comment">// &#123;java TestBed$Tester&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;f()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            TestBed t = <span class="keyword">new</span> TestBed();</span><br><span class="line">            t.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f()</span><br></pre></td></tr></table></figure>

<h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外部类的所有成员，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiNestingAccess.java</span></span><br><span class="line"><span class="comment">// Nested classes can access all members of all</span></span><br><span class="line"><span class="comment">// levels of the classes they are nested within</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                g();</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiNestingAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MNA mna = <span class="keyword">new</span> MNA();</span><br><span class="line">        MNA.A mnaa = mna.n<span class="function">ew <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        MNA.A.B mnaab = mnaa.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        mnaab.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在 <strong>MNA.A.B</strong> 中，调用方法 <code>g()</code> 和 <code>f()</code> 不需要任何条件（即使它们被定义为 <strong>private</strong>）。这个例子同时展示了如何从不同的类里创建多层嵌套的内部类对象的基本语法。”<strong>.new</strong>“语法能产生正确的作用域，所以不必在调用构造器时限定类名。</p>
<h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>至此，我们已经看到了许多描述内部类的语法和语义，但是这并不能同答“为什么需要内部类”这个问题。那么，Java 设计者们为什么会如此费心地增加这项基本的语言特性呢？</p>
<p>一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部类的对象。所以可以认为内部类提供了某种进入其外部类的窗口。</p>
<p>内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外部类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外部类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：</p>
<blockquote>
<p>每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p>
</blockquote>
<p>如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。</p>
<p>为了看到更多的细节，让我们考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择；使用单一类，或者使用内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/mui/MultiInterfaces.java</span></span><br><span class="line"><span class="comment">// Two ways a class can implement multiple interfaces</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.mui.MultiInterfaces&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses.mui;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">makeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Anonymous inner class:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X x = <span class="keyword">new</span> X();</span><br><span class="line">        Y y = <span class="keyword">new</span> Y();</span><br><span class="line">        takesA(x);</span><br><span class="line">        takesA(y);</span><br><span class="line">        takesB(x);</span><br><span class="line">        takesB(y.makeB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这里假设在两种方式下的代码结构都确实有逻辑意义。然而遇到问题的时候，通常问题本身就能给出某些指引，告诉你是应该使用单一类，还是使用内部类。但如果没有任何其他限制，从实现的观点来看，前面的例子并没有什么区别，它们都能正常运作。</p>
<p>如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiImplementation.java</span></span><br><span class="line"><span class="comment">// For concrete or abstract classes, inner classes</span></span><br><span class="line"><span class="comment">// produce &quot;multiple implementation inheritance&quot;</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.MultiImplementation&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">makeE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> E() &#123;&#125;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiImplementation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesD</span><span class="params">(D d)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesE</span><span class="params">(E e)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Z z = <span class="keyword">new</span> Z();</span><br><span class="line">        takesD(z);</span><br><span class="line">        takesE(z.makeE());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：</p>
<ol>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立。</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。 稍后就会展示一个这样的例子。</li>
<li>创建内部类对象的时刻并不依赖于外部类对象的创建</li>
<li>内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。</li>
</ol>
<p>举个例子，如果 <strong>Sequence.java</strong> 不使用内部类，就必须声明”<strong>Sequence</strong> 是一个 <strong>Selector</strong>“，对于某个特定的 <strong>Sequence</strong> 只能有一个 <strong>Selector</strong>，然而使用内部类很容易就能拥有另一个方法 <code>reverseSelector()</code>，用它来生成一个反方向遍历序列的 <strong>Selector</strong>，只有内部类才有这种灵活性。</p>
<h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3><p>闭包（<strong>closure</strong>）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 <strong>private</strong> 成员。</p>
<p>在 Java 8 之前，内部类是实现闭包的唯一方式。在 Java 8 中，我们可以使用 lambda 表达式来实现闭包行为，并且语法更加优雅和简洁，你将会在 <a target="_blank" rel="noopener" href="https://github.com/YoungYJMaze/OnJava8/blob/master/docs/book">函数式编程 </a>这一章节中学习相关细节。尽管相对于内部类，你可能更喜欢使用 lambda 表达式实现闭包，但是你会看到并需要理解那些在 Java 8 之前通过内部类方式实现闭包的代码，因此仍然有必要来理解这种方式。</p>
<p>Java 最引人争议的问题之一就是，人们认为 Java 应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java 更小心仔细，所以没有在语言中包括指针。</p>
<p>通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。见下例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Callbacks.java</span></span><br><span class="line"><span class="comment">// Using inner classes for callbacks</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.Callbacks&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Very simple to just implement the interface:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span> </span>&#123; mi.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If your class must implement increment() in</span></span><br><span class="line"><span class="comment">// some other way, you must use an inner class:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise</span></span><br><span class="line">            <span class="comment">// you&#x27;ll get an infinite recursion:</span></span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; callbackReference.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee1 c1 = <span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2 = <span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2 =</span><br><span class="line">                <span class="keyword">new</span> Caller(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Other operation</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">Other operation</span><br><span class="line">2</span><br><span class="line">Other operation</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>这个例子进一步展示了外部类实现一个接口与内部类实现此接口之间的区别。就代码而言，<strong>Callee1</strong> 是更简单的解决方式。<strong>Callee2</strong> 继承自 <strong>MyIncrement</strong>，后者已经有了一个不同的 <code>increment()</code> 方法，并且与 <strong>Incrementable</strong> 接口期望的 <code>increment()</code> 方法完全不相关。所以如果 <strong>Callee2</strong> 继承了 <strong>MyIncrement</strong>，就不能为了 <strong>Incrementable</strong> 的用途而覆盖 <code>increment()</code> 方法，于是只能使用内部类独立地实现 <strong>Incrementable</strong>，还要注意，当创建了一个内部类时，并没有在外部类的接口中添加东西，也没有修改外部类的接口。</p>
<p>注意，在 <strong>Callee2</strong> 中除了 <code>getCallbackReference()</code> 以外，其他成员都是 <strong>private</strong> 的。要想建立与外部世界的任何连接，接口 <strong>Incrementable</strong> 都是必需的。在这里可以看到，<strong>interface</strong> 是如何允许接口与接口的实现完全独立的。 内部类 <strong>Closure</strong> 实现了 <strong>Incrementable</strong>，以提供一个返回 <strong>Callee2</strong> 的“钩子”（hook）-而且是一个安全的钩子。无论谁获得此 <strong>Incrementable</strong> 的引用，都只能调用 <code>increment()</code>，除此之外没有其他功能（不像指针那样，允许你做很多事情）。</p>
<p><strong>Caller</strong> 的构造器需要一个 <strong>Incrementable</strong> 的引用作为参数（虽然可以在任意时刻捕获回调引用），然后在以后的某个时刻，<strong>Caller</strong> 对象可以使用此引用回调 <strong>Callee</strong> 类。</p>
<p>回调的价值在于它的灵活性-可以在运行时动态地决定需要调用什么方法。例如，在图形界面实现 GUI 功能的时候，到处都用到回调。</p>
</div></div><a class="button-hover more" href="/2021/10/18/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E7%B1%BB/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h1 id="内部类和迭代器删除数组元素"><a href="#内部类和迭代器删除数组元素" class="headerlink" title="内部类和迭代器删除数组元素"></a>内部类和迭代器删除数组元素</h1><h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><p>因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外部类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/InheritInner.java</span></span><br><span class="line"><span class="comment">// Inheriting an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//- InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>InheritInner</strong> 只继承自内部类，而不是外部类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外部类对象的引用。此外，必须在构造器内使用如下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内部类的引用.super();</span><br></pre></td></tr></table></figure>

<p>这样才提供了必要的引用，然后程序才能编译通过。</p>
<h2 id="内部类的覆盖"><a href="#内部类的覆盖" class="headerlink" title="内部类的覆盖"></a>内部类的覆盖</h2><p>如果创建了一个内部类，然后继承其外部类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？这看起来似乎是个很有用的思想，但是“覆盖”内部类就好像它是外部类的一个方法，其实并不起什么作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg.java</span></span><br><span class="line"><span class="comment">// An inner class cannot be overridden like a method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Egg() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">        y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New Egg()</span><br><span class="line">Egg.Yolk()</span><br></pre></td></tr></table></figure>

<p>默认的无参构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了 <strong>BigEgg</strong> 的对象，那么所使用的应该是“覆盖后”的 <strong>Yolk</strong> 版本，但从输出中可以看到实际情况并不是这样的。</p>
<p>这个例子说明，当继承了某个外部类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg2.java</span></span><br><span class="line"><span class="comment">// Proper inheritance of an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Yolk y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    Egg2() &#123; System.out.println(<span class="string">&quot;New Egg2()&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span> </span>&#123; y = yy; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; y.f(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg2</span> <span class="keyword">extends</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg2</span>.<span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigEgg2</span><span class="params">()</span> </span>&#123; insertYolk(<span class="keyword">new</span> Yolk()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Egg2 e2 = <span class="keyword">new</span> BigEgg2();</span><br><span class="line">        e2.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Egg2.Yolk()</span><br><span class="line"><span class="function">New <span class="title">Egg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Egg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.Yolk.<span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>现在 <strong>BigEgg2.Yolk</strong> 通过 <strong>extends Egg2.Yolk</strong> 明确地继承了此内部类，并且覆盖了其中的方法。<code>insertYolk()</code> 方法允许 <strong>BigEgg2</strong> 将它自己的 <strong>Yolk</strong> 对象向上转型为 <strong>Egg2</strong> 中的引用 <strong>y</strong>。所以当 <code>g()</code> 调用 <code>y.f()</code> 时，覆盖后的新版的 <code>f()</code> 被执行。第二次调用 <code>Egg2.Yolk()</code>，结果是 <strong>BigEgg2.Yolk</strong> 的构造器调用了其基类的构造器。可以看到在调用 <code>g()</code> 的时候，新版的 <code>f()</code> 被调用了。</p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外部类的一部分；但是它可以访问当前代码块内的常量，以及此外部类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/LocalInnerClass.java</span></span><br><span class="line"><span class="comment">// Holds a sequence of Objects</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A local inner class:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">            LocalCounter() &#123;</span><br><span class="line">                <span class="comment">// Local inner class can have a constructor</span></span><br><span class="line">                System.out.println(<span class="string">&quot;LocalCounter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Repeat, but with an anonymous inner class:</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            <span class="comment">// Anonymous inner class cannot have a named</span></span><br><span class="line">            <span class="comment">// constructor, only an instance initializer:</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Counter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">        Counter</span><br><span class="line">                c1 = lic.getCounter(<span class="string">&quot;Local inner &quot;</span>),</span><br><span class="line">                c2 = lic.getCounter2(<span class="string">&quot;Anonymous inner &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c1.next());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c2.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalCounter()</span><br><span class="line">Counter()</span><br><span class="line">Local inner <span class="number">0</span></span><br><span class="line">Local inner <span class="number">1</span></span><br><span class="line">Local inner <span class="number">2</span></span><br><span class="line">Local inner <span class="number">3</span></span><br><span class="line">Local inner <span class="number">4</span></span><br><span class="line">Anonymous inner <span class="number">5</span></span><br><span class="line">Anonymous inner <span class="number">6</span></span><br><span class="line">Anonymous inner <span class="number">7</span></span><br><span class="line">Anonymous inner <span class="number">8</span></span><br><span class="line">Anonymous inner <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>Counter</strong> 返回的是序列中的下一个值。我们分别使用局部内部类和匿名内部类实现了这个功能，它们具有相同的行为和能力，既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。</p>
<p><strong>所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。</strong></p>
<h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>由于编译后每个类都会产生一个**.class** 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个”meta-class”，叫做 <strong>Class</strong> 对象）。</p>
<p>你可能猜到了，内部类也必须生成一个**.class** 文件以包含它们的 <strong>Class</strong> 对象信息。这些类文件的命名有严格的规则：外部类的名字，加上“**$<strong>“，再加上内部类的名字。例如，</strong>LocalInnerClass.java** 生成的 <strong>.class</strong> 文件包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter.class</span><br><span class="line">LocalInnerClass$1.class</span><br><span class="line">LocalInnerClass$LocalCounter.class</span><br><span class="line">LocalInnerClass.class</span><br></pre></td></tr></table></figure>

<p>如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外部类标识符与“**$**”的后面。</p>
<p>虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是 java 的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java 编译器会尽可能地转换它们。） </p>
<h2 id="java集合遍历删除的方法"><a href="#java集合遍历删除的方法" class="headerlink" title="java集合遍历删除的方法"></a>java集合遍历删除的方法</h2><p>一般地，我们有两种方式进行Java集合的遍历删除:</p>
<p>1、实现方式就是讲遍历与移除操作分离，即在遍历的过程中，将需要移除的数据存放在另外一个集合当中，遍历结束之后，统一移除。</p>
<p>2、使用Iterator遍历删除。</p>
<p>使用Iterator遍历删除的原因：</p>
<p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。<br>所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象， Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; famous = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    famous.add(<span class="string">&quot;liudehua&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;madehua&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;liushishi&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;tangwei&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : famous) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;madehua&quot;</span>)) &#123;</span><br><span class="line">            famous.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>运行出异常:</p>
<p>Exception in thread “main” java.util.ConcurrentModificationException</p>
<p>at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)</p>
<p>at java.util.AbstractList$Itr.next(AbstractList.java:343)</p>
<p>at com.bes.Test.main(Test.java:15)</p>
<p>Java新手最容易犯的错误，对JAVA集合进行遍历删除时务必要用迭代器。切记。</p>
<p>其实对于如上for循环，运行过程中还是转换成了如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it = famous.iterator();it.hasNext();)&#123;</span><br><span class="line">         String s = it.next();</span><br><span class="line">         <span class="keyword">if</span>(s.equals(<span class="string">&quot;madehua&quot;</span>))&#123;</span><br><span class="line">             famous.remove(s);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍然采用的是迭代器，但删除操作却用了错误的方法。如将famous.remove(s)改成it.remove()</p>
<p>为什么用了迭代码器就不能采用famous.remove(s)操作? 这种因为ArrayList与Iterator混合使用时会导致各自的状态出现不一样，最终出现异常。</p>
</div></div><a class="button-hover more" href="/2021/10/18/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><p>每个编译单元只能存在一个public类，(一个.java文件)，同时这个java文件的文件名必须和类确保一致，包括大小写，如果不存在public类，则文件命名没有特殊要求，其他的访问权限相关类似于方法和变量的访问权限。</p>
<p>除了内部类，其他类不可以是private 和protected的。只能是包访问权限和public之中的一种，</p>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>继承的时候，父类的构造方法最先被调用，然后调用子类的构造方法，如果父类的构造方法中含有参数，就需要通过super()方法显式的调用并且传递合适的参数才能完成构造。</p>
<h2 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipDelegation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> SpaceShipControls controls =</span><br><span class="line">    <span class="keyword">new</span> SpaceShipControls();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpaceShipDelegation</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Delegated methods:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.back(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.down(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.forward(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.left(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.right(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    controls.turboBoost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.up(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpaceShipDelegation protector =</span><br><span class="line">      <span class="keyword">new</span> SpaceShipDelegation(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所呈现的一样，我们在spaceshipdelegation类中创建了一个spaceshipcontrols的实例，并且通过这一实例来进行spaceshipcontrols的方法的调用，这个过程就被称为代理，代理是通过另一个类来实现其功能，而装饰器是在原类上进行功能的拓展。</p>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><p>final 修饰变量用来指代这一变量是不可修改的，如果一个基本类型同时又用final进行修饰，代表这一变量成为编译时常量，即该变量在编译时就已经有一个确定的值了，对于对象的引用来说，final虽然也意味着引用无法指向别处，但是引用所指向的值可以进行改变，我们还可以不给静态final变量赋值，<strong>但是这也意味着我们需要在构造器中为final的对象进行赋值，否则将会产生错误；</strong>（这样的情况又被称为空白final）</p>
<p>像如下这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poppet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  Poppet(<span class="keyword">int</span> ii) &#123; i = ii; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// Initialized final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> j; <span class="comment">// Blank final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Poppet p; <span class="comment">// Blank final reference</span></span><br><span class="line">  <span class="comment">// Blank finals MUST be initialized in the constructor:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">// Initialize blank final</span></span><br><span class="line">    p = <span class="keyword">new</span> Poppet(<span class="number">1</span>); <span class="comment">// Initialize blank final reference</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    j = x; <span class="comment">// Initialize blank final</span></span><br><span class="line">    p = <span class="keyword">new</span> Poppet(x); <span class="comment">// Initialize blank final reference</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> BlankFinal();</span><br><span class="line">    <span class="keyword">new</span> BlankFinal(<span class="number">47</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h5><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味着你无法在方法中更改参数引用所指向的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spin</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalArguments</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">with</span><span class="params">(<span class="keyword">final</span> Gizmo g)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//! g = new Gizmo(); // Illegal -- g is final</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">without</span><span class="params">(Gizmo g)</span> </span>&#123;</span><br><span class="line">    g = <span class="keyword">new</span> Gizmo(); <span class="comment">// OK -- g not final</span></span><br><span class="line">    g.spin();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// void f(final int i) &#123; i++; &#125; // Can&#x27;t change</span></span><br><span class="line">  <span class="comment">// You can only read from a final primitive:</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FinalArguments bf = <span class="keyword">new</span> FinalArguments();</span><br><span class="line">    bf.without(<span class="keyword">null</span>);</span><br><span class="line">    bf.with(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如代码中呈现的一样，final 指向的参数我们只能看，而不能对他做出任何的改变，对传入的参数仅仅能够读和返回，而不能做出改变。</p>
<h3 id="final-修饰方法"><a href="#final-修饰方法" class="headerlink" title="final 修饰方法"></a>final 修饰方法</h3><p>final修饰方法的原因有两个：第一个原因是把方法锁定，以防任何继承类修改它的含义，这是出于设计的考虑：想要确保在继承中使方法的行为保持不变，<strong>并且不会被覆盖。</strong></p>
<p>过去使用final方法的第二个原因是效率，在JAVA早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用，当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值。）并且以方法体中的实际代码的副本来替代方法调用，这将消除方法调用的开销。但是当代码段过长，程序代码过于膨胀，可能看不到内嵌带来的任何性能提高。<strong>在最近的java版本中，虚拟机可以探测到这些情况，并且优化去掉这些效率反而降低的额外内嵌调用</strong></p>
<p>！！！！所以现在用final修饰方法单纯是由于第一个原因！</p>
<h3 id="final-修饰类"><a href="#final-修饰类" class="headerlink" title="final 修饰类"></a>final 修饰类</h3><p>当将某个类整体定义为final时，就表明了你不打算继承该类，而且也不允许别人这样做，出于某种原因，你对该类的设计永远不需要做任何变动，或者出于安全的考虑，你不希望它有子类，</p>
<h3 id="继承与初始化"><a href="#继承与初始化" class="headerlink" title="继承与初始化"></a>继承与初始化</h3><p>static初始化的顺序按照定义类时的书写顺序依次初始化。</p>
<p>如以下这个程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: reusing/Beetle.java</span></span><br><span class="line"><span class="comment">// The full process of initialization.</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> j;</span><br><span class="line">  Insect() &#123;</span><br><span class="line">    print(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    j = <span class="number">39</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x1 =</span><br><span class="line">    printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printInit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    print(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> k = printInit(<span class="string">&quot;Beetle.k initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Beetle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;k = &quot;</span> + k);</span><br><span class="line">    print(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x2 =</span><br><span class="line">    printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">    Beetle b = <span class="keyword">new</span> Beetle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">static Insect.x1 initialized</span></span><br><span class="line"><span class="comment">static Beetle.x2 initialized</span></span><br><span class="line"><span class="comment">Beetle constructor</span></span><br><span class="line"><span class="comment">i = 9, j = 0</span></span><br><span class="line"><span class="comment">Beetle.k initialized</span></span><br><span class="line"><span class="comment">k = 47</span></span><br><span class="line"><span class="comment">j = 39</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在加载beetle的时候发现beetle具有一个基类insect 所以编译器继续加载了insect类，（不管是否有新建一个insect对象），加载完基类之后先加载根基类中的static，之后是下一个导出类，以此类推，这个过程结束完之后可以进行对象的创建了，即通过构造器进行对象的构建。</p>
</div></div><a class="button-hover more" href="/2021/10/18/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8Cenum/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h1 id="可变参数和enum"><a href="#可变参数和enum" class="headerlink" title="可变参数和enum"></a>可变参数和enum</h1><h2 id="JAVA的可变参数列表"><a href="#JAVA的可变参数列表" class="headerlink" title="JAVA的可变参数列表"></a>JAVA的可变参数列表</h2><p>如下面这段代码所呈现的一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object obj : args)</span><br><span class="line">      System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;</span><br><span class="line">      <span class="keyword">new</span> Integer(<span class="number">47</span>), <span class="keyword">new</span> Float(<span class="number">3.14</span>), <span class="keyword">new</span> Double(<span class="number">11.11</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span> &#125;);</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A()&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">47 3.14 11.11</span></span><br><span class="line"><span class="comment">one two three</span></span><br><span class="line"><span class="comment">A@1a46e30 A@3e25a5 A@19821f</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>第一段里我们插入了一个Object数组，但是其实可以以另外一种更加优雅的形式呈现：</p>
<p>类似于我们在python中经常使用到的*args,**kwargs来收集剩余的参数一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTrailingArguments</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> required, String... trailing)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;required: &quot;</span> + required + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : trailing)</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">    f(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">required: 1 one</span></span><br><span class="line"><span class="comment">required: 2 two three</span></span><br><span class="line"><span class="comment">required: 0</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时，在使用可变参数时，应注意，在如下情况发生时可能会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(Character c : args)</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(Integer i : args)</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Long... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">    f(<span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//! f(); // Won&#x27;t compile -- ambiguous</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">first a b c</span></span><br><span class="line"><span class="comment">second 1</span></span><br><span class="line"><span class="comment">second 2 1</span></span><br><span class="line"><span class="comment">second 0</span></span><br><span class="line"><span class="comment">third</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当上例的f()被直接调用时可能会出现错误。</p>
<p>只有给两个方法都添加一个非可变参数，才能解决这个二义性问题，</p>
<h2 id="enum关键字"><a href="#enum关键字" class="headerlink" title="enum关键字"></a>enum关键字</h2><p>可以定义如下的enum类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Spiciness</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span> </span>&#123; <span class="keyword">this</span>.degree = degree;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:    System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM: System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:     System.out.println(<span class="string">&quot;maybe too hot.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Burrito</span><br><span class="line">                plain = <span class="keyword">new</span> Burrito(Spiciness.NOT),</span><br><span class="line">                greenChile = <span class="keyword">new</span> Burrito(Spiciness.MEDIUM),</span><br><span class="line">                jalapeno = <span class="keyword">new</span> Burrito(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们可以发现Spiciness实际上被定义成了一个对象，所以在这里的switch绝不仅仅是对enum中类型序号的输入，更多的是输入了一个限定对象中的某些成员。</p>
<p>如果在需要传入Spiciness对象的位置仅仅传入int数值则会报错，必须传入Spiciness.***</p>
<p>以上也是enum类型经常使用的一种情况，即在switch语句中使用。</p>
</div></div><a class="button-hover more" href="/2021/10/18/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8Cenum/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/18/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time></div><div class="post-content"><div class="main-content content"><h2 id="接口与工厂"><a href="#接口与工厂" class="headerlink" title="接口与工厂"></a>接口与工厂</h2><p>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方法就是<code>工厂方法</code>设计模式，它与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象，理论上，通过这种方式，我们的代码将完全与接口的实现分离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  Implementation1() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation1 method1&quot;</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation1 method2&quot;</span>);&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  Implementation2() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation2 method1&quot;</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;print(<span class="string">&quot;Implementation2 method2&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Implementation2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span> </span>&#123;</span><br><span class="line">    Service s = fact.getService();</span><br><span class="line">    s.method1();</span><br><span class="line">    s.method2();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    serviceConsumer(<span class="keyword">new</span> Implementation1Factory());</span><br><span class="line">    <span class="comment">// Implementations are completely interchangeable:</span></span><br><span class="line">    serviceConsumer(<span class="keyword">new</span> Implementation2Factory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Implementation1 method1</span></span><br><span class="line"><span class="comment">Implementation1 method2</span></span><br><span class="line"><span class="comment">Implementation2 method1</span></span><br><span class="line"><span class="comment">Implementation2 method2</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p>如果没有使用工厂方法，代码就必须在某处指定将要创建的Service的确切类型，以便调用合适的构造器。</p>
<p>对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h3><p>一种典型的创建内部类的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">// Using inner classes looks just like</span></span><br><span class="line">  <span class="comment">// using any other class, within Parcel1:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">    Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">    Destination d = <span class="keyword">new</span> Destination(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>更加普遍的一种创建方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    Destination(String whereTo) &#123;</span><br><span class="line">      label = whereTo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">    Contents c = contents();</span><br><span class="line">    Destination d = to(dest);</span><br><span class="line">    System.out.println(d.readLabel());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel2 p = <span class="keyword">new</span> Parcel2();</span><br><span class="line">    p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    Parcel2 q = <span class="keyword">new</span> Parcel2();</span><br><span class="line">    <span class="comment">// Defining references to inner classes:</span></span><br><span class="line">    Parcel2.Contents c = q.contents();</span><br><span class="line">    Parcel2.Destination d = q.to(<span class="string">&quot;Borneo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>内部类被用来作为一种名字隐藏和组织代码的模式。但是它的更有用的作用是：</p>
<ul>
<li>当生成一个内部类的对象时，此对象与制造它的外围对象就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件，此外，内部类还拥有其外围类的所有元素的访问权：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; items = <span class="keyword">new</span> Object[size]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(next &lt; items.length)</span><br><span class="line">      items[next++] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i == items.length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> items[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(i &lt; items.length) i++; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      sequence.add(Integer.toString(i));</span><br><span class="line">    Selector selector = sequence.selector();</span><br><span class="line">    <span class="keyword">while</span>(!selector.end()) &#123;</span><br><span class="line">      System.out.print(selector.current() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      selector.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h3><p>如果你需要生成对外部类对象的引用，可以使用外部类的名字后面跟着this，这样产生的引用自动地具有正确的类型，<strong>这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">    DotThis.Inner dti = dt.inner();</span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DotThis.f()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时你需要创建某个内部类的对象，需要在new表达式中提供对其他外部类对象的引用，同时需要使用.new语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">    DotNew.Inner dni = dn.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>



<h2 id="内部类与上转型"><a href="#内部类与上转型" class="headerlink" title="内部类与上转型"></a>内部类与上转型</h2></div></div><a class="button-hover more" href="/2021/10/18/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By youngyj</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/haru02.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":50,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>