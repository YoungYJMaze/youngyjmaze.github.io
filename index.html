<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="injune的个人空间"><meta name="keywords"><meta name="author" content="injune,undefined"><meta name="copyright" content="injune"><title>injune的个人空间【injune'zone】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="injune'zone" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">injune</div><div class="author-info-description">injune的个人空间</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/YoungYJMaze" target="_blank">GitHub<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="mailto:q2235133943@gmail.com" target="_blank">E-Mail<i class="icon-dot bg-color1"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">24</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">35</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">injune'zone</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2021/10/25/yield/">yield</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-25</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/python/">python</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E8%BF%AD%E4%BB%A3/">迭代</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a></div></div><div class="post-content"><div class="main-content content"><p>yield 可以用来把函数当做一个迭代器使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line">def fab(max): </span><br><span class="line">    n, a, b = 0, 0, 1 </span><br><span class="line">    while n &lt; max: </span><br><span class="line">        yield b      # 使用 yield</span><br><span class="line">        # print b </span><br><span class="line">        a, b = b, a + b </span><br><span class="line">        n = n + 1</span><br><span class="line"> </span><br><span class="line">for n in fab(5): </span><br><span class="line">    print n</span><br></pre></td></tr></table></figure>
<p>打印斐波那契数列的函数中，每次yield 都相当于 return 一个b的新值，</p>
<p> yield也可以用于文件读取。如果直接对文件对象调用 read() 方法，会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 yield，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def read_file(fpath): </span><br><span class="line">    BLOCK_SIZE = 1024 </span><br><span class="line">    with open(fpath, &#x27;rb&#x27;) as f: </span><br><span class="line">        while True: </span><br><span class="line">            block = f.read(BLOCK_SIZE) </span><br><span class="line">            if block: </span><br><span class="line">                yield block </span><br><span class="line">            else: </span><br><span class="line">                return</span><br></pre></td></tr></table></figure>

<p>仅仅是简单的使用方法,之后再继续学习补充。</p>
</div></div><a class="button-hover more" href="/2021/10/25/yield/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/10/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/leetcode/">leetcode</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></div></div><div class="post-content"><div class="main-content content"><p>动态规划的三部曲：</p>
<ol>
<li>找到初始状态， 比如在背包问题中，初始状态就是背包中都为空，没有任何物品被选中。</li>
<li>找到状态的变量， 在找零钱中，总钱数或者说剩余钱数是目的状态，在背包问题中，选中的价值和重量都是变量，所以是一个二元的状态转移方程，也就是两个变量，我们一般使用二维 以表的形式展示</li>
<li>找到状态的转移， 一般可以归纳为取或者不取 ， 取当前位置的变量 造成状态转移， 不取当前位置的变量，保持上一个状态。</li>
</ol>
</div></div><a class="button-hover more" href="/2021/10/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">JAVA 垃圾回收</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/gc/">gc</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a></div></div><div class="post-content"><div class="main-content content"><h1 id="JAVA垃圾回收"><a href="#JAVA垃圾回收" class="headerlink" title="JAVA垃圾回收"></a>JAVA垃圾回收</h1><h2 id="垃圾回收的意义"><a href="#垃圾回收的意义" class="headerlink" title="垃圾回收的意义"></a>垃圾回收的意义</h2><p>如果不进行垃圾回收，内存迟早会被消耗空。<br>垃圾回收机制的引入可以有效的防止内存泄露、保证内存的有效使用，也减轻了 Java 程序员的对内存管理的工作量。</p>
<p>内存泄露：指该内存空间使用完毕后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有是也将其称为“对象游离”。</p>
<hr>
<h2 id="垃圾回收机制中的算法"><a href="#垃圾回收机制中的算法" class="headerlink" title="垃圾回收机制中的算法"></a>垃圾回收机制中的算法</h2><p>垃圾回收算法需要做的基本事情：</p>
<p>发现无用对象<br>回收被无用对象占用的内存空间，使该空间可被程序再次使用</p>
<h2 id="1-可达性检测算法"><a href="#1-可达性检测算法" class="headerlink" title="1. 可达性检测算法"></a>1. 可达性检测算法</h2><h3 id="1-1-引用计数法（Reference-Counting-Collector）"><a href="#1-1-引用计数法（Reference-Counting-Collector）" class="headerlink" title="1.1 引用计数法（Reference Counting Collector）"></a>1.1 引用计数法（Reference Counting Collector）</h3><p>引用计数是垃圾收集器中的早期策略。<br>此方法中，堆中的每个对象都会添加一个引用计数器。每当一个地方引用这个对象时，计数器值 +1；当引用失效时，计数器值 -1。任何时刻计数值为 0 的对象就是不可能再被使用的。</p>
<p>这种算法无法解决对象之间相互引用的情况。<br>比如对象有一个对子对象的引用，子对象反过来引用父对象，它们的引用计数永远不可能为 0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyObject object1 = new MyObject();</span><br><span class="line">        MyObject object2 = new MyObject();</span><br><span class="line">          </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">          </span><br><span class="line">        object1 = null;</span><br><span class="line">        object2 = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后面两句将 object1 和 object2 赋值为 null，也就是说 object1 和 object2 指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。</p>
<h3 id="1-2-根搜索算法（可达性分析算法）"><a href="#1-2-根搜索算法（可达性分析算法）" class="headerlink" title="1.2 根搜索算法（可达性分析算法）"></a>1.2 根搜索算法（可达性分析算法）</h3><p>由于引用计数法存在缺陷，所有现在一般使用根搜索算法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8878793-b776e959ecfd4c35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p>
<center>根搜索算法图解</center>

<p>根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。<br>如上图中的 ObjF、ObjD、ObjE通过 GC Root 是无法找到的，所以它们是无用节点。</p>
<p>Java 中可作为 GC Root 的对象：</p>
<p>虚拟机栈中引用的对象（本地变量表）<br>方法区中静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈中引用的对象（Native对象）<br>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/71189093">《JVM 内存模型概述》</a></p>
<p>小结：无论是引用计数法还是跟搜索法，都是为了找到可回收的对象（内存块）。</p>
<h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2.垃圾收集算法"></a>2.垃圾收集算法</h2><p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的就是进行垃圾的回收，有下面的几中算法：</p>
<h3 id="2-1-标记-清除（Mark-Sweep）算法"><a href="#2-1-标记-清除（Mark-Sweep）算法" class="headerlink" title="2.1 标记-清除（Mark-Sweep）算法"></a>2.1 标记-清除（Mark-Sweep）算法</h3><p>标记-清除算法分为两个阶段：</p>
<p>标记阶段：标记出需要被回收的对象。<br>清除阶段：回收被标记的可回收对象的内部空间。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8878793-6a9f7afe94d5c9ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p>
<center>标记-清除算法图</center>

<p>标记-清除算法实现较容易，不需要移动对象，但是存在较严重的问题：</p>
<ul>
<li><p>算法过程需要暂停整个应用，效率不高。</p>
</li>
<li><p>标记清除后会产生大量不连续的内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作</p>
</li>
</ul>
<h3 id="2-2-复制（Copying）算法"><a href="#2-2-复制（Copying）算法" class="headerlink" title="2.2 复制（Copying）算法"></a>2.2 复制（Copying）算法</h3><p>  为了解决标志-清除算法的缺陷，由此有了复制算法。<br>  复制算法将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8878793-f8843f83aad30e99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/749/format/webp" alt="img"></p>
<center>复制算法图</center>
小结：

<ul>
<li><p>优点：实现简单，不易产生内存碎片，每次只需要对半个区进行内存回收。</p>
</li>
<li><p>缺点：内存空间缩减为原来的一半；算法的效率和存活对象的数目有关，存活对象越多，效率越低。</p>
</li>
</ul>
<h3 id="2-3-标记-整理（Mark-Compact）算法"><a href="#2-3-标记-整理（Mark-Compact）算法" class="headerlink" title="2.3 标记-整理（Mark-Compact）算法"></a>2.3 标记-整理（Mark-Compact）算法</h3><p>  为了更充分利用内存空间，提出了标记-整理算法。<br>  此算法结合了“标记-清除”和“复制”两个算法的优点。<br>  该算法标记阶段和“标志-清除”算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8878793-147802e319c69914.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/679/format/webp" alt="img"></p>
<center>标志-整理算法图</center>

<h3 id="2-4-分代收集（Generational-Collection）算法"><a href="#2-4-分代收集（Generational-Collection）算法" class="headerlink" title="2.4 分代收集（Generational Collection）算法"></a>2.4 分代收集（Generational Collection）算法</h3><p>分代收集算法是目前大部分 JVM 的垃圾收集器采用的算法。<br>核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8878793-23e72c97b64a692b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/563/format/webp" alt="img"></p>
<center>分代算法图</center>

<p>区域划分：</p>
<blockquote>
<p>年轻代（Young Generation）</p>
</blockquote>
<blockquote>
<ol>
<li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li>
<li>新生代内存按照8:1:1的比例分为一个 eden 区和两个 survivor(survivor0,survivor1) 区。一个 Eden 区，两个 Survivor 区(一般而言)。大部分对象在 Eden 区中生成。回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的，然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。</li>
<li>当 survivor1区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次 Full GC ，也就是新生代、老年代都进行回收。</li>
<li>新生代发生的 GC 也叫做 Minor GC ，Minor GC 发生频率比较高(不一定等 Eden 区满了才触发)。</li>
</ol>
</blockquote>
<blockquote>
<p>年老代（Old Generation）</p>
</blockquote>
<blockquote>
<ol>
<li>在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</li>
<li>内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li>
</ol>
</blockquote>
<blockquote>
<p>持久代（Permanent Generation）</p>
</blockquote>
<blockquote>
<p> 用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class ，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>
</blockquote>
<p>GC 类型：</p>
<blockquote>
<ol>
<li>Minor GC(新生代 GC):<br>新生代 GC，指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生熄灭的特点，所以 Minor GC 十分频繁，回收速度也较快。<br>Major GC(老年代 GC):</li>
<li>老年代 GC，指发生在老年代的垃圾收集动作，当出现 Major GC 时，一般也会伴有至少一次的 Minor GC（并非绝对，例如 Parallel Scavenge 收集器会单独直接触发 Major GC 的机制）。 Major GC 的速度一般会比 Minor GC 慢十倍以上。</li>
<li>Full GC:<br>清理整个堆空间—包括年轻代和老年代。Major GC == Full GC。参考： </li>
</ol>
</blockquote>
<blockquote>
<p>产生 Full GC 可能的原因：</p>
</blockquote>
<blockquote>
<ol>
<li>年老代被写满。</li>
<li>持久代被写满。</li>
<li>System.gc() 被显式调用。</li>
<li>上一次 GC 之后 Heap 的各域分配策略动态变化。</li>
</ol>
</blockquote>
<h2 id="垃圾收集器（GC）"><a href="#垃圾收集器（GC）" class="headerlink" title="垃圾收集器（GC）"></a>垃圾收集器（GC）</h2><p>不同虚拟机所提供的垃圾收集器可能会有很大差别，下面的例子是 HotSpot。</p>
<p>新生代收集器使用的收集器：<code>Serial</code>、<code>PraNew</code>、<code>Parallel Scavenge</code>。<br>老年代收集器使用的收集器：<code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8878793-fecb38bcfee88c25.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp" alt="img"></p>
<center>垃圾收集器图</center>

<ol>
<li><p>Serial 收集器（复制算法)<br>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>
</li>
<li><p>Serial Old收集器(标记-整理算法)<br>老年代单线程收集器，Serial 收集器的老年代版本。</p>
</li>
<li><p>ParNew 收集器(停止-复制算法) 　<br>新生代收集器，可以认为是 Serial 收集器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现。</p>
</li>
<li><p>Parallel Scavenge 收集器(停止-复制算法)<br>并行收集器，追求高吞吐量，高效利用 CPU。吞吐量一般为 99%， 吞吐量 = 用户线程时间 / (用户线程时间 + GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>
</li>
<li><p>Parallel Old 收集器(停止-复制算法)<br>Parallel Scavenge 收集器的老年代版本，并行收集器，吞吐量优先。</p>
</li>
<li><p>CMS(Concurrent Mark Sweep) 收集器（标记-清理算法）<br>高并发、低停顿，追求最短 GC 回收停顿时间，cpu 占用比较高，响应时间快，停顿时间短，多核 cpu 追求高响应时间的选择。</p>
</li>
</ol>
<p>根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。</p>
<h2 id="四种引用状态"><a href="#四种引用状态" class="headerlink" title="四种引用状态"></a>四种引用状态</h2><p>在实际开发中，我们对 new 出来的对象也会根据重要程度，有个等级划分。有些必须用到的对象，我们希望它在其被引用的周期内能一直存在；有些对象可能没那么重要，当内存空间还足够时，可以保留在内存中，如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。<br>由此，Java 对引用划分为四种：强引用、软引用、弱引用、虚引用，四种引用强度依次减弱。</p>
<ol>
<li><p>强引用<br>代码中普遍存在的类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。2.</p>
</li>
<li><p>软引用<br>描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java 中的类 SoftReference 表示软引用。</p>
</li>
<li><p>弱引用</p>
<p>描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java 中的类 WeakReference 表示弱引用。</p>
</li>
<li><p>虚引用<br>这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java 中的类 PhantomReference 表示虚引用。</p>
</li>
</ol>
<p>作者：安静的蓝孩子<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b78ac4bf13ae">https://www.jianshu.com/p/b78ac4bf13ae</a><br>来源：简书</p>
</div></div><a class="button-hover more" href="/2020/05/26/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">Lambda 表达式</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/">匿名函数</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a></div></div><div class="post-content"><div class="main-content content"><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式是使用<strong>最小可能</strong>语法编写的函数定义：</p>
<ol>
<li>Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。</li>
<li>Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。</li>
</ol>
<p>我们在 <strong>Strategize.java</strong> 中看到了一个 Lambda 表达式，但还有其他语法变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/LambdaExpressions.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Description</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">brief</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">detailed</span><span class="params">(String head)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Multi</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">twoArg</span><span class="params">(String head, Double d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExpressions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Body bod = h -&gt; h + <span class="string">&quot; No Parens!&quot;</span>; <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Body bod2 = (h) -&gt; h + <span class="string">&quot; More details&quot;</span>; <span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Description desc = () -&gt; <span class="string">&quot;Short info&quot;</span>; <span class="comment">// [3]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Multi mult = (h, n) -&gt; h + n; <span class="comment">// [4]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Description moreLines = () -&gt; &#123; <span class="comment">// [5]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;moreLines()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;from moreLines()&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(bod.detailed(<span class="string">&quot;Oh!&quot;</span>));</span><br><span class="line">    System.out.println(bod2.detailed(<span class="string">&quot;Hi!&quot;</span>));</span><br><span class="line">    System.out.println(desc.brief());</span><br><span class="line">    System.out.println(mult.twoArg(<span class="string">&quot;Pi! &quot;</span>, <span class="number">3.14159</span>));</span><br><span class="line">    System.out.println(moreLines.brief());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Oh! No Parens!</span><br><span class="line">Hi! More details</span><br><span class="line">Short info</span><br><span class="line">Pi! <span class="number">3.14159</span></span><br><span class="line">moreLines()</span><br><span class="line"><span class="function">from <span class="title">moreLines</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>我们从三个接口开始，每个接口都有一个单独的方法（很快就会理解它的重要性）。但是，每个方法都有不同数量的参数，以便演示 Lambda 表达式语法。</p>
<p>任何 Lambda 表达式的基本语法是：</p>
<ol>
<li>参数。</li>
<li>接着 <code>-&gt;</code>，可视为“产出”。</li>
<li><code>-&gt;</code> 之后的内容都是方法体。</li>
</ol>
<ul>
<li><strong>[1]</strong> 当只用一个参数，可以不需要括号 <code>()</code>。 然而，这是一个特例。</li>
<li><strong>[2]</strong> 正常情况使用括号 <code>()</code> 包裹参数。 为了保持一致性，也可以使用括号 <code>()</code> 包裹单个参数，虽然这种情况并不常见。</li>
<li><strong>[3]</strong> 如果没有参数，则必须使用括号 <code>()</code> 表示空参数列表。</li>
<li><strong>[4]</strong> 对于多个参数，将参数列表放在括号 <code>()</code> 中。</li>
</ul>
<p>到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 <strong>return</strong> 关键字是非法的。 这是 Lambda 表达式简化相应语法的另一种方式。</p>
<ul>
<li>**[5] **如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 <strong>return</strong>。</li>
</ul>
<p>Lambda 表达式通常比<strong>匿名内部类</strong>产生更易读的代码，因此我们将在本书中尽可能使用它们。</p>
</div></div><a class="button-hover more" href="/2020/05/26/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/JavaAssist/">Javassist</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/">字节码</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/javaassist/">javaassist</a></div></div><div class="post-content"><div class="main-content content"><p>Javassist是用来处理java字节码的类库。字节码保存在二进制文件中称为类文件。每个类文件夹包括一个java类或接口。</p>
<p>Javasssist.CtClass这个类是一个类文件的抽象表示。一个CtClass(compile-time class编译时类)对象处理一个类文件。下面是个简单的例子：</p>
<pre><code>ClassPool pool = ClassPool.getDefault();
CtClass cc = pool.get(&quot;test.Rectangle&quot;);
cc.setSuperclass(pool.get(&quot;test.Point&quot;));
cc.writeFile();
</code></pre>
</div></div><a class="button-hover more" href="/2020/05/26/JavaAssist/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/ThreadLocal%20%E6%BA%90%E7%A0%81/">JAVA ThreadLocal</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/ThreadLocal/">ThreadLocal</a></div></div><div class="post-content"><div class="main-content content"><h1 id="ThreadLocal-源码解读"><a href="#ThreadLocal-源码解读" class="headerlink" title="ThreadLocal 源码解读"></a>ThreadLocal 源码解读</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>首先每个threadLocal类都具有一个其自身的threadlocalhashcode，通过nextHashCode(),获取下一个hashcode，<br>Thread 可以具有初始值，通过withInitial进行设置，它的入参是一个supplier 接口。</p>
<p>get 函数通过拿到当前Thread ，然后再通过getMap 函数得到当前Thread 绑定的threadlocals (一个ThreadLocalMap)，Map 的Entry是各种各样的ThreadLocal类，通过对应的ThreadLocal类得到对应的Entry，如果找到了当前ThreadLocal对象(即threadLocalHashCode映射在了table中，并且table中对应位置不为空)。<br>如果没有找到通过这个函数进行下一步的处理</p>
<pre><code>getEntryAfterMiss(key, i, e)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           int len = tab.length;</span><br><span class="line"></span><br><span class="line">           while (e != null) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               if (k == key)</span><br><span class="line">                   return e;</span><br><span class="line">               if (k == null)</span><br><span class="line">                   expungeStaleEntry(i);</span><br><span class="line">               else</span><br><span class="line">                   i = nextIndex(i, len);</span><br><span class="line">               e = tab[i];</span><br><span class="line">           &#125;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


<p>这个函数通过一个while循环，只要没找到存在的Entry，就继续通过一定的策略进行查找。</p>
</div></div><a class="button-hover more" href="/2020/05/26/ThreadLocal%20%E6%BA%90%E7%A0%81/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/static%E4%BB%A3%E7%A0%81%E6%AE%B5%20addall%20aslist/">代码段及容器</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E4%BB%A3%E7%A0%81%E6%AE%B5/">代码段</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E9%9D%99%E6%80%81/">静态</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%AE%B9%E5%99%A8/">容器</a></div></div><div class="post-content"><div class="main-content content"><h2 id="static代码段"><a href="#static代码段" class="headerlink" title="static代码段"></a>static代码段</h2><p>仅仅在类被初始化的时候加载一次，之后都不再加载,比如业务代码中的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        MessageFieldTagNums.addAll(Arrays.asList(</span><br><span class="line">            <span class="string">&quot;7193&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7198&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7300&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7301&quot;</span>));</span><br><span class="line">        MessageFieldTags.addAll(Arrays.asList(</span><br><span class="line">            <span class="string">&quot;ErrorMessage&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ClientConnInfo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FunctionInfo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CheckInfo&quot;</span>));</span><br><span class="line">        MessageFieldTypes.addAll(Arrays.asList(</span><br><span class="line">            (Class) ErrorMessage.class,</span><br><span class="line">            (Class) ClientConnInfo.class,</span><br><span class="line">            (Class) FunctionInfo.class,</span><br><span class="line">            (Class) CheckInfo.class));</span><br><span class="line">        MessageFieldDataTypes.addAll(Arrays.asList(</span><br><span class="line">            DataType.COMPONENT,</span><br><span class="line">            DataType.COMPONENT,</span><br><span class="line">            DataType.COMPONENT,</span><br><span class="line">            DataType.COMPONENT));</span><br><span class="line">        MessageFieldRequireds.addAll(Arrays.asList(</span><br><span class="line">                Boolean.FALSE,</span><br><span class="line">                Boolean.FALSE,</span><br><span class="line">                Boolean.FALSE,</span><br><span class="line">                Boolean.FALSE));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么类什么时候首次被加载呢？就是在主类中（包含main函数的类）new一个对象实例（包含static代码段的类没有main函数）或者此类有main函数，那么在进入main函数的时候首次加载此类，加载类的时候初始化顺序如下：如有父类，则按照静态成员、静态代码段、静态方法、一般成员、父类构造函数的顺序初始化父类，然后是子类的初始化，顺序与上述相同。</p>
<h2 id="addAll-函数"><a href="#addAll-函数" class="headerlink" title="addAll()函数"></a>addAll()函数</h2><p>addAll()函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">boolean</span>   <span class="title">addAll</span><span class="params">(Collection   c)</span>   </span>&#123; </span><br><span class="line">                         Object[]   a   =   c.toArray(); </span><br><span class="line">                         <span class="keyword">int</span>   numNew   =   a.length; </span><br><span class="line">ensureCapacity(size   +   numNew);      <span class="comment">//   Increments   modCount </span></span><br><span class="line">                         System.arraycopy(a,   <span class="number">0</span>,   elementData,   size,   numNew); </span><br><span class="line">                         size   +=   numNew; </span><br><span class="line"><span class="keyword">return</span>   numNew   !=   <span class="number">0</span>; </span><br><span class="line">             &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到其中用了一个arraycopy函数，这个函数是System函数内的，它调用的是一个本地的native函数，就是系统定义的接口，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                    Object dest, int destPos,</span><br><span class="line">                                    int length);</span><br></pre></td></tr></table></figure>

<p>在这个接口里，将内存某块地址的一些信息直接复制到内存的另一块中，所以针对于比较大的数据量来说，addAll()方法可以拥有更快的速度。</p>
<p>所谓addAll()就是将一个数据集合内的信息直接赋给另一个数据集合。</p>
<h2 id="ArrayList的asList-函数"><a href="#ArrayList的asList-函数" class="headerlink" title="ArrayList的asList()函数"></a>ArrayList的asList()函数</h2><p>asList使用的一些注意事项：</p>
<ol>
<li><p>由API可以知道返回的List称得上是对数组的一个引用，对List或者数组的更改都会传递给另一方。</p>
</li>
<li><p>使用这个函数还需注意不能使用基本数据类型的数组作为参数，因为函数参数是泛型，故需要引用数据类型的数组作为参数，若使用基本数据类型数组则会将该数组作为单个元素存进List中（因为数组也是引用数据类型）。若要使用基本数据类型数组，只能使用它们的包装类数组。</p>
</li>
<li><p>该List不能使用add()和remove()函数，虽然他有这两个函数，因为它的大小是固定的，所以这两个函数只有定义而没有实现，使用这两个函数会报java.lang.UnsupportedOperationException错误</p>
</li>
<li><p>可以通过创建一个ArrayList对象并以List作为参数使用addAll函数，就可以获得一个可以add和remove的列表了。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">aslistest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        List list = Arrays.asList(a);</span><br><span class="line">        <span class="keyword">for</span>(Object i:list)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println((<span class="keyword">int</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(Object i:list)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println((<span class="keyword">int</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
</div></div><a class="button-hover more" href="/2020/05/26/static%E4%BB%A3%E7%A0%81%E6%AE%B5%20addall%20aslist/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/">内部类和迭代器</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E8%BF%AD%E4%BB%A3/">迭代</a></div></div><div class="post-content"><div class="main-content content"><h1 id="内部类和迭代器删除数组元素"><a href="#内部类和迭代器删除数组元素" class="headerlink" title="内部类和迭代器删除数组元素"></a>内部类和迭代器删除数组元素</h1><h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><p>因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外部类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/InheritInner.java</span></span><br><span class="line"><span class="comment">// Inheriting an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//- InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>InheritInner</strong> 只继承自内部类，而不是外部类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外部类对象的引用。此外，必须在构造器内使用如下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内部类的引用.super();</span><br></pre></td></tr></table></figure>

<p>这样才提供了必要的引用，然后程序才能编译通过。</p>
<h2 id="内部类的覆盖"><a href="#内部类的覆盖" class="headerlink" title="内部类的覆盖"></a>内部类的覆盖</h2><p>如果创建了一个内部类，然后继承其外部类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？这看起来似乎是个很有用的思想，但是“覆盖”内部类就好像它是外部类的一个方法，其实并不起什么作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg.java</span></span><br><span class="line"><span class="comment">// An inner class cannot be overridden like a method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Egg() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">        y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New Egg()</span><br><span class="line">Egg.Yolk()</span><br></pre></td></tr></table></figure>

<p>默认的无参构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了 <strong>BigEgg</strong> 的对象，那么所使用的应该是“覆盖后”的 <strong>Yolk</strong> 版本，但从输出中可以看到实际情况并不是这样的。</p>
<p>这个例子说明，当继承了某个外部类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg2.java</span></span><br><span class="line"><span class="comment">// Proper inheritance of an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Yolk y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    Egg2() &#123; System.out.println(<span class="string">&quot;New Egg2()&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span> </span>&#123; y = yy; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; y.f(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg2</span> <span class="keyword">extends</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg2</span>.<span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigEgg2</span><span class="params">()</span> </span>&#123; insertYolk(<span class="keyword">new</span> Yolk()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Egg2 e2 = <span class="keyword">new</span> BigEgg2();</span><br><span class="line">        e2.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Egg2.Yolk()</span><br><span class="line"><span class="function">New <span class="title">Egg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Egg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.Yolk.<span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>现在 <strong>BigEgg2.Yolk</strong> 通过 <strong>extends Egg2.Yolk</strong> 明确地继承了此内部类，并且覆盖了其中的方法。<code>insertYolk()</code> 方法允许 <strong>BigEgg2</strong> 将它自己的 <strong>Yolk</strong> 对象向上转型为 <strong>Egg2</strong> 中的引用 <strong>y</strong>。所以当 <code>g()</code> 调用 <code>y.f()</code> 时，覆盖后的新版的 <code>f()</code> 被执行。第二次调用 <code>Egg2.Yolk()</code>，结果是 <strong>BigEgg2.Yolk</strong> 的构造器调用了其基类的构造器。可以看到在调用 <code>g()</code> 的时候，新版的 <code>f()</code> 被调用了。</p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外部类的一部分；但是它可以访问当前代码块内的常量，以及此外部类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerclasses/LocalInnerClass.java</span></span><br><span class="line"><span class="comment">// Holds a sequence of Objects</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A local inner class:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">            LocalCounter() &#123;</span><br><span class="line">                <span class="comment">// Local inner class can have a constructor</span></span><br><span class="line">                System.out.println(<span class="string">&quot;LocalCounter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Repeat, but with an anonymous inner class:</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            <span class="comment">// Anonymous inner class cannot have a named</span></span><br><span class="line">            <span class="comment">// constructor, only an instance initializer:</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Counter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">        Counter</span><br><span class="line">                c1 = lic.getCounter(<span class="string">&quot;Local inner &quot;</span>),</span><br><span class="line">                c2 = lic.getCounter2(<span class="string">&quot;Anonymous inner &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c1.next());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c2.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalCounter()</span><br><span class="line">Counter()</span><br><span class="line">Local inner <span class="number">0</span></span><br><span class="line">Local inner <span class="number">1</span></span><br><span class="line">Local inner <span class="number">2</span></span><br><span class="line">Local inner <span class="number">3</span></span><br><span class="line">Local inner <span class="number">4</span></span><br><span class="line">Anonymous inner <span class="number">5</span></span><br><span class="line">Anonymous inner <span class="number">6</span></span><br><span class="line">Anonymous inner <span class="number">7</span></span><br><span class="line">Anonymous inner <span class="number">8</span></span><br><span class="line">Anonymous inner <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>Counter</strong> 返回的是序列中的下一个值。我们分别使用局部内部类和匿名内部类实现了这个功能，它们具有相同的行为和能力，既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。</p>
<p><strong>所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。</strong></p>
<h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>由于编译后每个类都会产生一个**.class** 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个”meta-class”，叫做 <strong>Class</strong> 对象）。</p>
<p>你可能猜到了，内部类也必须生成一个**.class** 文件以包含它们的 <strong>Class</strong> 对象信息。这些类文件的命名有严格的规则：外部类的名字，加上“**$<strong>“，再加上内部类的名字。例如，</strong>LocalInnerClass.java** 生成的 <strong>.class</strong> 文件包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter.class</span><br><span class="line">LocalInnerClass$1.class</span><br><span class="line">LocalInnerClass$LocalCounter.class</span><br><span class="line">LocalInnerClass.class</span><br></pre></td></tr></table></figure>

<p>如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外部类标识符与“**$**”的后面。</p>
<p>虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是 java 的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java 编译器会尽可能地转换它们。） </p>
<h2 id="java集合遍历删除的方法"><a href="#java集合遍历删除的方法" class="headerlink" title="java集合遍历删除的方法"></a>java集合遍历删除的方法</h2><p>一般地，我们有两种方式进行Java集合的遍历删除:</p>
<p>1、实现方式就是讲遍历与移除操作分离，即在遍历的过程中，将需要移除的数据存放在另外一个集合当中，遍历结束之后，统一移除。</p>
<p>2、使用Iterator遍历删除。</p>
<p>使用Iterator遍历删除的原因：</p>
<p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。<br>所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象， Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; famous = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    famous.add(<span class="string">&quot;liudehua&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;madehua&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;liushishi&quot;</span>);</span><br><span class="line">    famous.add(<span class="string">&quot;tangwei&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : famous) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;madehua&quot;</span>)) &#123;</span><br><span class="line">            famous.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>运行出异常:</p>
<p>Exception in thread “main” java.util.ConcurrentModificationException</p>
<p>at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)</p>
<p>at java.util.AbstractList$Itr.next(AbstractList.java:343)</p>
<p>at com.bes.Test.main(Test.java:15)</p>
<p>Java新手最容易犯的错误，对JAVA集合进行遍历删除时务必要用迭代器。切记。</p>
<p>其实对于如上for循环，运行过程中还是转换成了如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it = famous.iterator();it.hasNext();)&#123;</span><br><span class="line">         String s = it.next();</span><br><span class="line">         <span class="keyword">if</span>(s.equals(<span class="string">&quot;madehua&quot;</span>))&#123;</span><br><span class="line">             famous.remove(s);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍然采用的是迭代器，但删除操作却用了错误的方法。如将famous.remove(s)改成it.remove()</p>
<p>为什么用了迭代码器就不能采用famous.remove(s)操作? 这种因为ArrayList与Iterator混合使用时会导致各自的状态出现不一样，最终出现异常。</p>
</div></div><a class="button-hover more" href="/2020/05/26/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8Cenum/">可变参数和枚举</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%9E%9A%E4%B8%BE/">枚举</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%96%B9%E6%B3%95/">方法</a></div></div><div class="post-content"><div class="main-content content"><h1 id="可变参数和enum"><a href="#可变参数和enum" class="headerlink" title="可变参数和enum"></a>可变参数和enum</h1><h2 id="JAVA的可变参数列表"><a href="#JAVA的可变参数列表" class="headerlink" title="JAVA的可变参数列表"></a>JAVA的可变参数列表</h2><p>如下面这段代码所呈现的一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object obj : args)</span><br><span class="line">      System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;</span><br><span class="line">      <span class="keyword">new</span> Integer(<span class="number">47</span>), <span class="keyword">new</span> Float(<span class="number">3.14</span>), <span class="keyword">new</span> Double(<span class="number">11.11</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span> &#125;);</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A()&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output: (Sample)</span></span><br><span class="line"><span class="comment">47 3.14 11.11</span></span><br><span class="line"><span class="comment">one two three</span></span><br><span class="line"><span class="comment">A@1a46e30 A@3e25a5 A@19821f</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>第一段里我们插入了一个Object数组，但是其实可以以另外一种更加优雅的形式呈现：</p>
<p>类似于我们在python中经常使用到的*args,**kwargs来收集剩余的参数一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTrailingArguments</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> required, String... trailing)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;required: &quot;</span> + required + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : trailing)</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">    f(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">required: 1 one</span></span><br><span class="line"><span class="comment">required: 2 two three</span></span><br><span class="line"><span class="comment">required: 0</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时，在使用可变参数时，应注意，在如下情况发生时可能会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(Character c : args)</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(Integer i : args)</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Long... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">    f(<span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//! f(); // Won&#x27;t compile -- ambiguous</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">first a b c</span></span><br><span class="line"><span class="comment">second 1</span></span><br><span class="line"><span class="comment">second 2 1</span></span><br><span class="line"><span class="comment">second 0</span></span><br><span class="line"><span class="comment">third</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当上例的f()被直接调用时可能会出现错误。</p>
<p>只有给两个方法都添加一个非可变参数，才能解决这个二义性问题，</p>
<h2 id="enum关键字"><a href="#enum关键字" class="headerlink" title="enum关键字"></a>enum关键字</h2><p>可以定义如下的enum类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Spiciness</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span> </span>&#123; <span class="keyword">this</span>.degree = degree;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:    System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM: System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:     System.out.println(<span class="string">&quot;maybe too hot.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Burrito</span><br><span class="line">                plain = <span class="keyword">new</span> Burrito(Spiciness.NOT),</span><br><span class="line">                greenChile = <span class="keyword">new</span> Burrito(Spiciness.MEDIUM),</span><br><span class="line">                jalapeno = <span class="keyword">new</span> Burrito(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们可以发现Spiciness实际上被定义成了一个对象，所以在这里的switch绝不仅仅是对enum中类型序号的输入，更多的是输入了一个限定对象中的某些成员。</p>
<p>如果在需要传入Spiciness对象的位置仅仅传入int数值则会报错，必须传入Spiciness.***</p>
<p>以上也是enum类型经常使用的一种情况，即在switch语句中使用。</p>
</div></div><a class="button-hover more" href="/2020/05/26/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8Cenum/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/05/26/%E5%A4%9A%E6%80%81/">多态</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-10-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%A4%9A%E6%80%81/">多态</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div></div><div class="post-content"><div class="main-content content"><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的意义其中之一就是上转型</p>
<p>如果针对于每个导出类我们都进行重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Stringed.play() &quot;</span> + n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Brass.play() &quot;</span> + n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Wind i)</span> </span>&#123;</span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Stringed i)</span> </span>&#123;</span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Brass i)</span> </span>&#123;</span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">    Stringed violin = <span class="keyword">new</span> Stringed();</span><br><span class="line">    Brass frenchHorn = <span class="keyword">new</span> Brass();</span><br><span class="line">    tune(flute); <span class="comment">// No upcasting</span></span><br><span class="line">    tune(violin);</span><br><span class="line">    tune(frenchHorn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Wind.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">Stringed.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">Brass.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>这将是很大的工作量，并且如果这样做，如果有时我们忘记了去重写父类的方法，那么我们就会收获未知的错误，因为他会继承父类的方法，并且不会有任何的提示。</p>
<h3 id="方法调用绑定"><a href="#方法调用绑定" class="headerlink" title="方法调用绑定"></a>方法调用绑定</h3><p>将一个方法调用和一个方法主体关联起来被称作绑定，若在程序执行前进行绑定，叫做前期绑定，它是面向过程的语言中默认的绑定方式，例如C语言。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">    tune(flute); <span class="comment">// Upcasting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Wind.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>像这段代码，编译器如何确定传入的Instrument就是Wind类型而非其他类型呢？</p>
<p>主要是通过后期绑定:</p>
<p>后期绑定是在运行时根据对象的类型进行绑定，后期绑定也叫做动态绑定或运行时绑定，如果一种语言想实现后期绑定，就必须有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法，后期绑定机制随编程语言的不同而有所不同，但是不管怎么样都必须在对象中安置某种“类型信息”。</p>
<p>java中除了static 和 final 方法之外，其他所有的方法都是后期绑定，也就是说，final方法可以有效地解除动态绑定，即我们不需要这个类继续被继承。</p>
<h3 id="产生正确的行为"><a href="#产生正确的行为" class="headerlink" title="产生正确的行为"></a>产生正确的行为</h3><p>向上转型可以像以下的语句一样简单：</p>
<p><code>Shape s= new Circle();</code></p>
<p>如果这时你调用一个基类的方法，它会调用的是导出类中重写过的方法（如果存在）而非基类的方法。这里就是动态绑定的体现。</p>
<h3 id="多态使用的注意事项"><a href="#多态使用的注意事项" class="headerlink" title="多态使用的注意事项"></a>多态使用的注意事项</h3><h4 id="1、私有方法不可覆盖"><a href="#1、私有方法不可覆盖" class="headerlink" title="1、私有方法不可覆盖"></a>1、私有方法不可覆盖</h4><h4 id="2、域与静态方法，静态方法不具有多态的意义"><a href="#2、域与静态方法，静态方法不具有多态的意义" class="headerlink" title="2、域与静态方法，静态方法不具有多态的意义"></a>2、域与静态方法，静态方法不具有多态的意义</h4><h3 id="构造器与多态"><a href="#构造器与多态" class="headerlink" title="构造器与多态"></a>构造器与多态</h3><p>构造器实际上是static方法，只不过它的static声明是隐式的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  Meal() &#123; print(<span class="string">&quot;Meal()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</span><br><span class="line">  Bread() &#123; print(<span class="string">&quot;Bread()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</span><br><span class="line">  Cheese() &#123; print(<span class="string">&quot;Cheese()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</span><br><span class="line">  Lettuce() &#123; print(<span class="string">&quot;Lettuce()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  Lunch() &#123; print(<span class="string">&quot;Lunch()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">  PortableLunch() &#123; print(<span class="string">&quot;PortableLunch()&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">  <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese();</span><br><span class="line">  <span class="keyword">private</span> Lettuce l = <span class="keyword">new</span> Lettuce();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sandwich</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;Sandwich()&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Sandwich();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Meal()</span></span><br><span class="line"><span class="comment">Lunch()</span></span><br><span class="line"><span class="comment">PortableLunch()</span></span><br><span class="line"><span class="comment">Bread()</span></span><br><span class="line"><span class="comment">Cheese()</span></span><br><span class="line"><span class="comment">Lettuce()</span></span><br><span class="line"><span class="comment">Sandwich()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子实际上展示了构造器的构造顺序</p>
<h4 id="继承与清理"><a href="#继承与清理" class="headerlink" title="继承与清理"></a>继承与清理</h4><p>如果我们在清理方法上对导出类做了一些特殊的处理，但是同时还要用到基类中的方法，这时候一定要记得使用super()来调用父类的清理方法，否则不会进行。</p>
<h4 id="构造器内部多态方法的行为"><a href="#构造器内部多态方法的行为" class="headerlink" title="构造器内部多态方法的行为"></a>构造器内部多态方法的行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;Glyph.draw()&quot;</span>); &#125;</span><br><span class="line">  Glyph() &#123;</span><br><span class="line">    print(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">    draw();</span><br><span class="line">    print(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">  RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">    radius = r;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Glyph() before draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.draw(), radius = 0  由动态绑定得到的答案。</span></span><br><span class="line"><span class="comment">Glyph() after draw()</span></span><br><span class="line"><span class="comment">RoundGlyph.RoundGlyph(), radius = 5</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如这个例子，在glyph的构造方法中调用了draw，这是一个需要被覆盖的方法。</p>
<p>这里引出了实际的初始化过程，首先第一步，将所有要分配的空间都初始化为二进制的0；</p>
<p>在构造器内唯一能够安全调用的方法就是基类中的final方法。</p>
<h3 id="向下转型与运行时类型识别"><a href="#向下转型与运行时类型识别" class="headerlink" title="向下转型与运行时类型识别"></a>向下转型与运行时类型识别</h3><p>RTTI 运行时类型识别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreUseful</span> <span class="keyword">extends</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RTTI</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Useful[] x = &#123;</span><br><span class="line">      <span class="keyword">new</span> Useful(),</span><br><span class="line">      <span class="keyword">new</span> MoreUseful()</span><br><span class="line">    &#125;;</span><br><span class="line">    x[<span class="number">0</span>].f();</span><br><span class="line">    x[<span class="number">1</span>].g();</span><br><span class="line">    <span class="comment">// Compile time: method not found in Useful:</span></span><br><span class="line">    <span class="comment">//! x[1].u();</span></span><br><span class="line">    ((MoreUseful)x[<span class="number">1</span>]).u(); <span class="comment">// Downcast/RTTI</span></span><br><span class="line">    ((MoreUseful)x[<span class="number">0</span>]).u(); <span class="comment">// Exception thrown</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上直接调用x[1].u()是无法实现的。但是向下转型之后可以进行调用，但是X[0]即使向下转型也无法调用。</p>
<h2 id="java-中-add-offer，element-peek，remove-poll"><a href="#java-中-add-offer，element-peek，remove-poll" class="headerlink" title="java 中 add/offer，element/peek，remove/poll"></a>java 中 add/offer，element/peek，remove/poll</h2><p>java LinkedList和Queue中 add/offer，element/peek，remove/poll中的三个方法均为重复的方法，在选择使用时不免有所疑惑，这里简单区别一下：</p>
<p>1、add()和offer()区别:</p>
<p>add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</p>
<p> 2、poll()和remove()区别：</p>
<p>remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p>
<p>3、element() 和 peek() 区别：</p>
<p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p>
<p>**下面是Java中Queue的一些常用方法：<br>add         增加一个元索                      如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove   移除并返回队列头部的元素     如果队列为空，则抛出一个NoSuchElementException异常<br>element  返回队列头部的元素              如果队列为空，则抛出一个NoSuchElementException异常<br>offer       添加一个元素并返回true        如果队列已满，则返回false<br>poll         移除并返问队列头部的元素     如果队列为空，则返回null<br>peek       返回队列头部的元素              如果队列为空，则返回null<br>put         添加一个元素                       如果队列满，则阻塞<br>take        移除并返回队列头部的元素   **</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这种方法是不完整的，仅有方法声明而没有方法体，包含抽象方法的类叫做抽象类，如果一个类包含一个或者多个抽象方法，该类必须被限定为抽象类。</p>
</div></div><a class="button-hover more" href="/2020/05/26/%E5%A4%9A%E6%80%81/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2021 By injune</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/haru02.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":50,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>